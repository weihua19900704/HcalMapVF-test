// Generated at Fri Feb 20 10:30:20 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc472/external/gccxml/20110825-cms4/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc472/external/gccxml/20110825-cms4/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc472/external/gccxml/20110825-cms4/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.7.2"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='7' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gccxml/20110825-cms4/share/gccxml-0.9/GCC/4.7" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc472/external/gccxml/20110825-cms4/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.7.2
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/CondFormats/HcalObjects/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_101 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_94 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2461 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_2549 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_4028 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_549 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_1181 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1488 = ::Reflex::TypeBuilder(Reflex::Literal("DetId"));
  ::Reflex::Type type_865 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1357 = ::Reflex::TypeBuilder(Reflex::Literal("HcalGain"));
  ::Reflex::Type type_804 = ::Reflex::TypeBuilder(Reflex::Literal("HcalGains"));
  ::Reflex::Type type_219 = ::Reflex::TypeBuilder(Reflex::Literal("HcalDcsMap"));
  ::Reflex::Type type_1256 = ::Reflex::TypeBuilder(Reflex::Literal("HcalDetId"));
  ::Reflex::Type type_43 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_27 = ::Reflex::TypeBuilder(Reflex::Literal("HcalTimeCorr"));
  ::Reflex::Type type_1530 = ::Reflex::TypeBuilder(Reflex::Literal("HcalPFCorr"));
  ::Reflex::Type type_900 = ::Reflex::TypeBuilder(Reflex::Literal("HcalPFCorrs"));
  ::Reflex::Type type_128 = ::Reflex::TypeBuilder(Reflex::Literal("HcalTopology"));
  ::Reflex::Type type_18 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_110 = ::Reflex::TypeBuilder(Reflex::Literal("HcalMCParams"));
  ::Reflex::Type type_172 = ::Reflex::TypeBuilder(Reflex::Literal("HcalQIECoder"));
  ::Reflex::Type type_718 = ::Reflex::TypeBuilder(Reflex::Literal("HcalQIEShape"));
  ::Reflex::Type type_1074 = ::Reflex::TypeBuilder(Reflex::Literal("HcalMCParam"));
  ::Reflex::Type type_1511 = ::Reflex::TypeBuilder(Reflex::Literal("HcalLUTCorr"));
  ::Reflex::Type type_231 = ::Reflex::TypeBuilder(Reflex::Literal("HcalRespCorr"));
  ::Reflex::Type type_360 = ::Reflex::TypeBuilder(Reflex::Literal("HcalDcsDetId"));
  ::Reflex::Type type_1432 = ::Reflex::TypeBuilder(Reflex::Literal("HcalQIEData"));
  ::Reflex::Type type_139 = ::Reflex::TypeBuilder(Reflex::Literal("HcalGainWidth"));
  ::Reflex::Type type_745 = ::Reflex::TypeBuilder(Reflex::Literal("HcalRecoParam"));
  ::Reflex::Type type_144 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_1230 = ::Reflex::TypeBuilder(Reflex::Literal("HcalPedestal"));
  ::Reflex::Type type_656 = ::Reflex::TypeBuilder(Reflex::Literal("HcalDcsValues"));
  ::Reflex::Type type_1419 = ::Reflex::TypeBuilder(Reflex::Literal("HcalDcsValue"));
  ::Reflex::Type type_1162 = ::Reflex::TypeBuilder(Reflex::Literal("HcalLUTCorrs"));
  ::Reflex::Type type_309 = ::Reflex::TypeBuilder(Reflex::Literal("HcalRecoParams"));
  ::Reflex::Type type_1306 = ::Reflex::TypeBuilder(Reflex::Literal("HcalPedestals"));
  ::Reflex::Type type_1350 = ::Reflex::TypeBuilder(Reflex::Literal("HcalTimeCorrs"));
  ::Reflex::Type type_1567 = ::Reflex::TypeBuilder(Reflex::Literal("HcalRespCorrs"));
  ::Reflex::Type type_103 = ::Reflex::TypeBuilder(Reflex::Literal("HcalTimingParam"));
  ::Reflex::Type type_530 = ::Reflex::TypeBuilder(Reflex::Literal("HcalZSThreshold"));
  ::Reflex::Type type_1297 = ::Reflex::TypeBuilder(Reflex::Literal("HcalGainWidths"));
  ::Reflex::Type type_4 = ::Reflex::TypeBuilder(Reflex::Literal("HcalLongRecoParams"));
  ::Reflex::Type type_753 = ::Reflex::TypeBuilder(Reflex::Literal("HcalZSThresholds"));
  ::Reflex::Type type_1491 = ::Reflex::TypeBuilder(Reflex::Literal("HcalLutMetadata"));
  ::Reflex::Type type_50 = ::Reflex::TypeBuilder(Reflex::Literal("HcalValidationCorr"));
  ::Reflex::Type type_853 = ::Reflex::TypeBuilder(Reflex::Literal("HcalElectronicsId"));
  ::Reflex::Type type_1231 = ::Reflex::TypeBuilder(Reflex::Literal("HcalGenericDetId"));
  ::Reflex::Type type_1624 = ::Reflex::TypeBuilder(Reflex::Literal("HcalLutMetadatum"));
  ::Reflex::Type type_716 = ::Reflex::TypeBuilder(Reflex::Literal("HcalPedestalWidth"));
  ::Reflex::Type type_1729 = ::Reflex::TypeBuilder(Reflex::Literal("HcalTimingParams"));
  ::Reflex::Type type_3088 = ::Reflex::TypeBuilder(Reflex::Literal("HcalDcsMap::Item"));
  ::Reflex::Type type_159 = ::Reflex::TypeBuilder(Reflex::Literal("HcalElectronicsMap"));
  ::Reflex::Type type_328 = ::Reflex::TypeBuilder(Reflex::Literal("HcalTrigTowerDetId"));
  ::Reflex::Type type_1748 = ::Reflex::TypeBuilder(Reflex::Literal("HcalLongRecoParam"));
  ::Reflex::Type type_1391 = ::Reflex::TypeBuilder(Reflex::Literal("HcalChannelStatus"));
  ::Reflex::Type type_278 = ::Reflex::TypeBuilder(Reflex::Literal("HcalPedestalWidths"));
  ::Reflex::Type type_868 = ::Reflex::TypeBuilder(Reflex::Literal("HcalChannelQuality"));
  ::Reflex::Type type_1877 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<DetId>"));
  ::Reflex::Type type_491 = ::Reflex::TypeBuilder(Reflex::Literal("HcalL1TriggerObject"));
  ::Reflex::Type type_1671 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCholeskyMatrix"));
  ::Reflex::Type type_1879 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_300 = ::Reflex::TypeBuilder(Reflex::Literal("HcalL1TriggerObjects"));
  ::Reflex::Type type_333 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCovarianceMatrix"));
  ::Reflex::Type type_506 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCholeskyMatrices"));
  ::Reflex::Type type_1187 = ::Reflex::TypeBuilder(Reflex::Literal("HcalValidationCorrs"));
  ::Reflex::Type type_1873 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalGain>"));
  ::Reflex::Type type_1886 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalDetId>"));
  ::Reflex::Type type_1300 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCalibrationQIEData"));
  ::Reflex::Type type_1469 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCovarianceMatrices"));
  ::Reflex::Type type_1923 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_1145 = ::Reflex::TypeBuilder(Reflex::Literal("HcalFlagHFDigiTimeParam"));
  ::Reflex::Type type_1863 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalPFCorr>"));
  ::Reflex::Type type_1252 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCalibrationQIECoder"));
  ::Reflex::Type type_330 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HcalOtherSubdetector"));
  ::Reflex::Type type_1851 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalMCParam>"));
  ::Reflex::Type type_1864 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalLUTCorr>"));
  ::Reflex::Type type_1120 = ::Reflex::TypeBuilder(Reflex::Literal("HcalFlagHFDigiTimeParams"));
  ::Reflex::Type type_2161 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalGain>"));
  ::Reflex::Type type_1853 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_1861 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalTimeCorr>"));
  ::Reflex::Type type_1865 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalRespCorr>"));
  ::Reflex::Type type_1871 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalQIECoder>"));
  ::Reflex::Type type_1875 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalPedestal>"));
  ::Reflex::Type type_1885 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalDcsDetId>"));
  ::Reflex::Type type_3243 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HcalDcsDetId::DcsType"));
  ::Reflex::Type type_1856 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalDcsValue>"));
  ::Reflex::Type type_524 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase"));
  ::Reflex::Type type_1852 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalRecoParam>"));
  ::Reflex::Type type_1872 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalGainWidth>"));
  ::Reflex::Type type_3082 = ::Reflex::TypeBuilder(Reflex::Literal("HcalDcsMap::const_iterator"));
  ::Reflex::Type type_2151 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalPFCorr>"));
  ::Reflex::Type type_2139 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalMCParam>"));
  ::Reflex::Type type_2152 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalLUTCorr>"));
  ::Reflex::Type type_1849 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalTimingParam>"));
  ::Reflex::Type type_1866 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalZSThreshold>"));
  ::Reflex::Type type_3427 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HcalDcsValues::DcsSubDet"));
  ::Reflex::Type type_2144 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalDcsValue>"));
  ::Reflex::Type type_2149 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalTimeCorr>"));
  ::Reflex::Type type_2153 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalRespCorr>"));
  ::Reflex::Type type_2159 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalQIECoder>"));
  ::Reflex::Type type_2163 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalPedestal>"));
  ::Reflex::Type type_1884 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalGenericDetId>"));
  ::Reflex::Type type_1859 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalLutMetadatum>"));
  ::Reflex::Type type_1855 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalDcsMap::Item>"));
  ::Reflex::Type type_2140 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalRecoParam>"));
  ::Reflex::Type type_2160 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalGainWidth>"));
  ::Reflex::Type type_1898 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalElectronicsId>"));
  ::Reflex::Type type_1854 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalLongRecoParam>"));
  ::Reflex::Type type_1867 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalChannelStatus>"));
  ::Reflex::Type type_1874 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalPedestalWidth>"));
  ::Reflex::Type type_1897 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalTrigTowerDetId>"));
  ::Reflex::Type type_1860 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalValidationCorr>"));
  ::Reflex::Type type_1858 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalCholeskyMatrix>"));
  ::Reflex::Type type_4282 = ::Reflex::TypeBuilder(Reflex::Literal("HcalLutMetadata::NonChannelData"));
  ::Reflex::Type type_2137 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalTimingParam>"));
  ::Reflex::Type type_2154 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalZSThreshold>"));
  ::Reflex::Type type_2577 = ::Reflex::TypeBuilder(Reflex::Literal("HcalElectronicsMap::TriggerItem"));
  ::Reflex::Type type_1862 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalL1TriggerObject>"));
  ::Reflex::Type type_190 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalGain>"));
  ::Reflex::Type type_2143 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalDcsMap::Item>"));
  ::Reflex::Type type_2147 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalLutMetadatum>"));
  ::Reflex::Type type_1857 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalCovarianceMatrix>"));
  ::Reflex::Type type_2142 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalLongRecoParam>"));
  ::Reflex::Type type_2155 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalChannelStatus>"));
  ::Reflex::Type type_2576 = ::Reflex::TypeBuilder(Reflex::Literal("HcalElectronicsMap::PrecisionItem"));
  ::Reflex::Type type_2162 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalPedestalWidth>"));
  ::Reflex::Type type_180 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalPFCorr>"));
  ::Reflex::Type type_2146 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalCholeskyMatrix>"));
  ::Reflex::Type type_2148 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalValidationCorr>"));
  ::Reflex::Type type_175 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalMCParam>"));
  ::Reflex::Type type_181 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalLUTCorr>"));
  ::Reflex::Type type_2150 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalL1TriggerObject>"));
  ::Reflex::Type type_1850 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>"));
  ::Reflex::Type type_182 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalTimeCorr>"));
  ::Reflex::Type type_184 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalRespCorr>"));
  ::Reflex::Type type_1870 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalCalibrationQIECoder>"));
  ::Reflex::Type type_188 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalQIECoder>"));
  ::Reflex::Type type_192 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalPedestal>"));
  ::Reflex::Type type_1883 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const HcalDcsMap::Item*>"));
  ::Reflex::Type type_2145 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalCovarianceMatrix>"));
  ::Reflex::Type type_177 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalRecoParam>"));
  ::Reflex::Type type_189 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalGainWidth>"));
  ::Reflex::Type type_173 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalTimingParam>"));
  ::Reflex::Type type_185 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalZSThreshold>"));
  ::Reflex::Type type_2138 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalFlagHFDigiTimeParam>"));
  ::Reflex::Type type_2158 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalCalibrationQIECoder>"));
  ::Reflex::Type type_178 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalLutMetadatum>"));
  ::Reflex::Type type_176 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalLongRecoParam>"));
  ::Reflex::Type type_186 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalChannelStatus>"));
  ::Reflex::Type type_191 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalPedestalWidth>"));
  ::Reflex::Type type_179 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalValidationCorr>"));
  ::Reflex::Type type_183 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalL1TriggerObject>"));
  ::Reflex::Type type_1868 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>"));
  ::Reflex::Type type_1869 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>"));
  ::Reflex::Type type_174 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalFlagHFDigiTimeParam>"));
  ::Reflex::Type type_187 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalCalibrationQIECoder>"));
  ::Reflex::Type type_2156 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalElectronicsMap::TriggerItem>"));
  ::Reflex::Type type_2157 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalElectronicsMap::PrecisionItem>"));
  ::Reflex::Type type_1895 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const HcalElectronicsMap::TriggerItem*>"));
  ::Reflex::Type type_3915 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalGain> >"));
  ::Reflex::Type type_1896 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const HcalElectronicsMap::PrecisionItem*>"));
  ::Reflex::Type type_1820 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalGain,std::allocator<HcalGain> >"));
  ::Reflex::Type type_3899 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalPFCorr> >"));
  ::Reflex::Type type_3888 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalMCParam> >"));
  ::Reflex::Type type_3900 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalLUTCorr> >"));
  ::Reflex::Type type_3896 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalDcsValue> >"));
  ::Reflex::Type type_3901 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalTimeCorr> >"));
  ::Reflex::Type type_3903 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalRespCorr> >"));
  ::Reflex::Type type_3911 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalQIECoder> >"));
  ::Reflex::Type type_3917 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalPedestal> >"));
  ::Reflex::Type type_2103 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalGain> >"));
  ::Reflex::Type type_3891 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalRecoParam> >"));
  ::Reflex::Type type_1804 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalPFCorr,std::allocator<HcalPFCorr> >"));
  ::Reflex::Type type_3913 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalGainWidth> >"));
  ::Reflex::Type type_2093 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalPFCorr> >"));
  ::Reflex::Type type_3885 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalTimingParam> >"));
  ::Reflex::Type type_1793 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalMCParam,std::allocator<HcalMCParam> >"));
  ::Reflex::Type type_1805 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalLUTCorr,std::allocator<HcalLUTCorr> >"));
  ::Reflex::Type type_3904 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalZSThreshold> >"));
  ::Reflex::Type type_2088 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalMCParam> >"));
  ::Reflex::Type type_2094 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalLUTCorr> >"));
  ::Reflex::Type type_3894 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalDcsMap::Item> >"));
  ::Reflex::Type type_3897 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalLutMetadatum> >"));
  ::Reflex::Type type_2095 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalTimeCorr> >"));
  ::Reflex::Type type_2097 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalRespCorr> >"));
  ::Reflex::Type type_2101 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalQIECoder> >"));
  ::Reflex::Type type_2105 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalPedestal> >"));
  ::Reflex::Type type_3889 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalLongRecoParam> >"));
  ::Reflex::Type type_1801 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalDcsValue,std::allocator<HcalDcsValue> >"));
  ::Reflex::Type type_1806 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalTimeCorr,std::allocator<HcalTimeCorr> >"));
  ::Reflex::Type type_1808 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalRespCorr,std::allocator<HcalRespCorr> >"));
  ::Reflex::Type type_3909 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalChannelStatus> >"));
  ::Reflex::Type type_1816 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalQIECoder,std::allocator<HcalQIECoder> >"));
  ::Reflex::Type type_3916 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalPedestalWidth> >"));
  ::Reflex::Type type_1822 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalPedestal,std::allocator<HcalPedestal> >"));
  ::Reflex::Type type_2090 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalRecoParam> >"));
  ::Reflex::Type type_2102 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalGainWidth> >"));
  ::Reflex::Type type_3893 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalCholeskyMatrix> >"));
  ::Reflex::Type type_3898 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalValidationCorr> >"));
  ::Reflex::Type type_3851 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >"));
  ::Reflex::Type type_1796 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalRecoParam,std::allocator<HcalRecoParam> >"));
  ::Reflex::Type type_3902 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalL1TriggerObject> >"));
  ::Reflex::Type type_1818 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalGainWidth,std::allocator<HcalGainWidth> >"));
  ::Reflex::Type type_2086 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalTimingParam> >"));
  ::Reflex::Type type_2098 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalZSThreshold> >"));
  ::Reflex::Type type_3892 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalCovarianceMatrix> >"));
  ::Reflex::Type type_2091 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalLutMetadatum> >"));
  ::Reflex::Type type_2089 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalLongRecoParam> >"));
  ::Reflex::Type type_2099 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalChannelStatus> >"));
  ::Reflex::Type type_2104 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalPedestalWidth> >"));
  ::Reflex::Type type_3819 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >"));
  ::Reflex::Type type_2092 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalValidationCorr> >"));
  ::Reflex::Type type_1790 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalTimingParam,std::allocator<HcalTimingParam> >"));
  ::Reflex::Type type_3886 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalFlagHFDigiTimeParam> >"));
  ::Reflex::Type type_1809 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalZSThreshold,std::allocator<HcalZSThreshold> >"));
  ::Reflex::Type type_3910 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalCalibrationQIECoder> >"));
  ::Reflex::Type type_2096 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalL1TriggerObject> >"));
  ::Reflex::Type type_3797 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >"));
  ::Reflex::Type type_3821 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >"));
  ::Reflex::Type type_3852 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalGain*,std::vector<HcalGain> >"));
  ::Reflex::Type type_1799 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalDcsMap::Item,std::allocator<HcalDcsMap::Item> >"));
  ::Reflex::Type type_1802 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalLutMetadatum,std::allocator<HcalLutMetadatum> >"));
  ::Reflex::Type type_3813 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >"));
  ::Reflex::Type type_3823 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >"));
  ::Reflex::Type type_3827 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >"));
  ::Reflex::Type type_3843 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >"));
  ::Reflex::Type type_3855 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >"));
  ::Reflex::Type type_1905 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalGain> > >"));
  ::Reflex::Type type_1794 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalLongRecoParam,std::allocator<HcalLongRecoParam> >"));
  ::Reflex::Type type_1814 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalChannelStatus,std::allocator<HcalChannelStatus> >"));
  ::Reflex::Type type_1821 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalPedestalWidth,std::allocator<HcalPedestalWidth> >"));
  ::Reflex::Type type_2087 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalFlagHFDigiTimeParam> >"));
  ::Reflex::Type type_2100 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<HcalCalibrationQIECoder> >"));
  ::Reflex::Type type_3803 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >"));
  ::Reflex::Type type_3820 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalPFCorr*,std::vector<HcalPFCorr> >"));
  ::Reflex::Type type_3847 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >"));
  ::Reflex::Type type_1889 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalPFCorr> > >"));
  ::Reflex::Type type_1798 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalCholeskyMatrix,std::allocator<HcalCholeskyMatrix> >"));
  ::Reflex::Type type_1803 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalValidationCorr,std::allocator<HcalValidationCorr> >"));
  ::Reflex::Type type_1880 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalMCParam> > >"));
  ::Reflex::Type type_1890 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalLUTCorr> > >"));
  ::Reflex::Type type_3798 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalMCParam*,std::vector<HcalMCParam> >"));
  ::Reflex::Type type_3822 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalLUTCorr*,std::vector<HcalLUTCorr> >"));
  ::Reflex::Type type_1891 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalTimeCorr> > >"));
  ::Reflex::Type type_1893 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalRespCorr> > >"));
  ::Reflex::Type type_1901 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalQIECoder> > >"));
  ::Reflex::Type type_1907 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalPedestal> > >"));
  ::Reflex::Type type_1807 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalL1TriggerObject,std::allocator<HcalL1TriggerObject> >"));
  ::Reflex::Type type_3907 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalElectronicsMap::TriggerItem> >"));
  ::Reflex::Type type_1882 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalRecoParam> > >"));
  ::Reflex::Type type_1903 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalGainWidth> > >"));
  ::Reflex::Type type_3791 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >"));
  ::Reflex::Type type_3814 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalDcsValue*,std::vector<HcalDcsValue> >"));
  ::Reflex::Type type_3824 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalTimeCorr*,std::vector<HcalTimeCorr> >"));
  ::Reflex::Type type_3828 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalRespCorr*,std::vector<HcalRespCorr> >"));
  ::Reflex::Type type_3829 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >"));
  ::Reflex::Type type_3844 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalQIECoder*,std::vector<HcalQIECoder> >"));
  ::Reflex::Type type_3856 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalPedestal*,std::vector<HcalPedestal> >"));
  ::Reflex::Type type_1797 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalCovarianceMatrix,std::allocator<HcalCovarianceMatrix> >"));
  ::Reflex::Type type_3908 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalElectronicsMap::PrecisionItem> >"));
  ::Reflex::Type type_1876 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalTimingParam> > >"));
  ::Reflex::Type type_1894 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalZSThreshold> > >"));
  ::Reflex::Type type_3804 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalRecoParam*,std::vector<HcalRecoParam> >"));
  ::Reflex::Type type_3810 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >"));
  ::Reflex::Type type_3815 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >"));
  ::Reflex::Type type_3848 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalGainWidth*,std::vector<HcalGainWidth> >"));
  ::Reflex::Type type_1887 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalLutMetadatum> > >"));
  ::Reflex::Type type_1881 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalLongRecoParam> > >"));
  ::Reflex::Type type_1899 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalChannelStatus> > >"));
  ::Reflex::Type type_1906 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalPedestalWidth> > >"));
  ::Reflex::Type type_3799 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >"));
  ::Reflex::Type type_3839 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >"));
  ::Reflex::Type type_3853 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >"));
  ::Reflex::Type type_1888 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalValidationCorr> > >"));
  ::Reflex::Type type_1892 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalL1TriggerObject> > >"));
  ::Reflex::Type type_3792 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalTimingParam*,std::vector<HcalTimingParam> >"));
  ::Reflex::Type type_3807 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >"));
  ::Reflex::Type type_3817 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >"));
  ::Reflex::Type type_3830 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalZSThreshold*,std::vector<HcalZSThreshold> >"));
  ::Reflex::Type type_1791 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalFlagHFDigiTimeParam,std::allocator<HcalFlagHFDigiTimeParam> >"));
  ::Reflex::Type type_1815 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalCalibrationQIECoder,std::allocator<HcalCalibrationQIECoder> >"));
  ::Reflex::Type type_3811 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >"));
  ::Reflex::Type type_3816 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalLutMetadatum*,std::vector<HcalLutMetadatum> >"));
  ::Reflex::Type type_3825 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >"));
  ::Reflex::Type type_1878 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalFlagHFDigiTimeParam> > >"));
  ::Reflex::Type type_1900 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<HcalCalibrationQIECoder> > >"));
  ::Reflex::Type type_3800 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalLongRecoParam*,std::vector<HcalLongRecoParam> >"));
  ::Reflex::Type type_3805 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >"));
  ::Reflex::Type type_3840 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalChannelStatus*,std::vector<HcalChannelStatus> >"));
  ::Reflex::Type type_2327 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> > >"));
  ::Reflex::Type type_3854 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalPedestalWidth*,std::vector<HcalPedestalWidth> >"));
  ::Reflex::Type type_3808 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >"));
  ::Reflex::Type type_3818 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalValidationCorr*,std::vector<HcalValidationCorr> >"));
  ::Reflex::Type type_3826 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >"));
  ::Reflex::Type type_2295 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> > >"));
  ::Reflex::Type type_3793 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >"));
  ::Reflex::Type type_2273 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> > >"));
  ::Reflex::Type type_3806 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >"));
  ::Reflex::Type type_2297 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> > >"));
  ::Reflex::Type type_3841 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >"));
  ::Reflex::Type type_2326 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalGain*,std::vector<HcalGain> > >"));
  ::Reflex::Type type_2289 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> > >"));
  ::Reflex::Type type_2299 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> > >"));
  ::Reflex::Type type_2303 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> > >"));
  ::Reflex::Type type_2319 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> > >"));
  ::Reflex::Type type_2331 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> > >"));
  ::Reflex::Type type_2279 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> > >"));
  ::Reflex::Type type_2294 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalPFCorr*,std::vector<HcalPFCorr> > >"));
  ::Reflex::Type type_2323 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> > >"));
  ::Reflex::Type type_3794 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >"));
  ::Reflex::Type type_2272 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalMCParam*,std::vector<HcalMCParam> > >"));
  ::Reflex::Type type_2296 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalLUTCorr*,std::vector<HcalLUTCorr> > >"));
  ::Reflex::Type type_3842 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >"));
  ::Reflex::Type type_1812 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalElectronicsMap::TriggerItem,std::allocator<HcalElectronicsMap::TriggerItem> >"));
  ::Reflex::Type type_2267 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> > >"));
  ::Reflex::Type type_2288 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalDcsValue*,std::vector<HcalDcsValue> > >"));
  ::Reflex::Type type_2298 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalTimeCorr*,std::vector<HcalTimeCorr> > >"));
  ::Reflex::Type type_2302 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalRespCorr*,std::vector<HcalRespCorr> > >"));
  ::Reflex::Type type_2305 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> > >"));
  ::Reflex::Type type_2318 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalQIECoder*,std::vector<HcalQIECoder> > >"));
  ::Reflex::Type type_2330 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalPedestal*,std::vector<HcalPedestal> > >"));
  ::Reflex::Type type_2278 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalRecoParam*,std::vector<HcalRecoParam> > >"));
  ::Reflex::Type type_2285 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> > >"));
  ::Reflex::Type type_2291 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> > >"));
  ::Reflex::Type type_2322 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalGainWidth*,std::vector<HcalGainWidth> > >"));
  ::Reflex::Type type_1813 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalElectronicsMap::PrecisionItem,std::allocator<HcalElectronicsMap::PrecisionItem> >"));
  ::Reflex::Type type_2275 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> > >"));
  ::Reflex::Type type_2315 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> > >"));
  ::Reflex::Type type_2329 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> > >"));
  ::Reflex::Type type_2266 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalTimingParam*,std::vector<HcalTimingParam> > >"));
  ::Reflex::Type type_2283 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> > >"));
  ::Reflex::Type type_2293 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> > >"));
  ::Reflex::Type type_2304 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalZSThreshold*,std::vector<HcalZSThreshold> > >"));
  ::Reflex::Type type_2284 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> > >"));
  ::Reflex::Type type_2290 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalLutMetadatum*,std::vector<HcalLutMetadatum> > >"));
  ::Reflex::Type type_2301 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> > >"));
  ::Reflex::Type type_3835 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >"));
  ::Reflex::Type type_2274 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalLongRecoParam*,std::vector<HcalLongRecoParam> > >"));
  ::Reflex::Type type_2281 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> > >"));
  ::Reflex::Type type_2314 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalChannelStatus*,std::vector<HcalChannelStatus> > >"));
  ::Reflex::Type type_2328 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalPedestalWidth*,std::vector<HcalPedestalWidth> > >"));
  ::Reflex::Type type_2282 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> > >"));
  ::Reflex::Type type_2292 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalValidationCorr*,std::vector<HcalValidationCorr> > >"));
  ::Reflex::Type type_3837 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >"));
  ::Reflex::Type type_2300 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> > >"));
  ::Reflex::Type type_3836 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >"));
  ::Reflex::Type type_2269 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> > >"));
  ::Reflex::Type type_2280 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> > >"));
  ::Reflex::Type type_2317 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> > >"));
  ::Reflex::Type type_3838 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >"));
  ::Reflex::Type type_2268 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> > >"));
  ::Reflex::Type type_2316 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> > >"));
  ::Reflex::Type type_2311 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> > >"));
  ::Reflex::Type type_2313 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> > >"));
  ::Reflex::Type type_2310 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> > >"));
  ::Reflex::Type type_2312 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> > >"));
  ::Reflex::Type type_9858 = ::Reflex::ReferenceBuilder(type_4);
  ::Reflex::Type type_4c = ::Reflex::ConstBuilder(type_4);
  ::Reflex::Type type_9859 = ::Reflex::ReferenceBuilder(type_4c);
  ::Reflex::Type type_128c = ::Reflex::ConstBuilder(type_128);
  ::Reflex::Type type_9860 = ::Reflex::PointerBuilder(type_128c);
  ::Reflex::Type type_1934 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_1923);
  ::Reflex::Type type_370 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_43);
  ::Reflex::Type type_6166 = ::Reflex::ReferenceBuilder(type_27);
  ::Reflex::Type type_27c = ::Reflex::ConstBuilder(type_27);
  ::Reflex::Type type_6168 = ::Reflex::ReferenceBuilder(type_27c);
  ::Reflex::Type type_6101 = ::Reflex::ReferenceBuilder(type_50);
  ::Reflex::Type type_50c = ::Reflex::ConstBuilder(type_50);
  ::Reflex::Type type_6103 = ::Reflex::ReferenceBuilder(type_50c);
  ::Reflex::Type type_5387 = ::Reflex::ReferenceBuilder(type_103);
  ::Reflex::Type type_103c = ::Reflex::ConstBuilder(type_103);
  ::Reflex::Type type_5389 = ::Reflex::ReferenceBuilder(type_103c);
  ::Reflex::Type type_9873 = ::Reflex::ReferenceBuilder(type_110);
  ::Reflex::Type type_110c = ::Reflex::ConstBuilder(type_110);
  ::Reflex::Type type_9874 = ::Reflex::ReferenceBuilder(type_110c);
  ::Reflex::Type type_6881 = ::Reflex::ReferenceBuilder(type_139);
  ::Reflex::Type type_139c = ::Reflex::ConstBuilder(type_139);
  ::Reflex::Type type_6883 = ::Reflex::ReferenceBuilder(type_139c);
  ::Reflex::Type type_1181c = ::Reflex::ConstBuilder(type_1181);
  ::Reflex::Type type_7462 = ::Reflex::PointerBuilder(type_1181c);
  ::Reflex::Type type_9892 = ::Reflex::ReferenceBuilder(type_159);
  ::Reflex::Type type_159c = ::Reflex::ConstBuilder(type_159);
  ::Reflex::Type type_9893 = ::Reflex::ReferenceBuilder(type_159c);
  ::Reflex::Type type_1488c = ::Reflex::ConstBuilder(type_1488);
  ::Reflex::Type type_853c = ::Reflex::ConstBuilder(type_853);
  ::Reflex::Type type_9896 = ::Reflex::ReferenceBuilder(type_853);
  ::Reflex::Type type_9897 = ::Reflex::ReferenceBuilder(type_1231);
  ::Reflex::Type type_9898 = ::Reflex::ReferenceBuilder(type_328);
  ::Reflex::Type type_6816 = ::Reflex::ReferenceBuilder(type_172);
  ::Reflex::Type type_172c = ::Reflex::ConstBuilder(type_172);
  ::Reflex::Type type_6818 = ::Reflex::ReferenceBuilder(type_172c);
  ::Reflex::Type type_718c = ::Reflex::ConstBuilder(type_718);
  ::Reflex::Type type_9952 = ::Reflex::ReferenceBuilder(type_718c);
  ::Reflex::Type type_9953 = ::Reflex::ReferenceBuilder(type_173);
  ::Reflex::Type type_173c = ::Reflex::ConstBuilder(type_173);
  ::Reflex::Type type_9954 = ::Reflex::ReferenceBuilder(type_173c);
  ::Reflex::Type type_5385 = ::Reflex::PointerBuilder(type_103c);
  ::Reflex::Type type_2461c = ::Reflex::ConstBuilder(type_2461);
  ::Reflex::Type type_1876c = ::Reflex::ConstBuilder(type_1876);
  ::Reflex::Type type_5452 = ::Reflex::ReferenceBuilder(type_1145);
  ::Reflex::Type type_1145c = ::Reflex::ConstBuilder(type_1145);
  ::Reflex::Type type_5454 = ::Reflex::ReferenceBuilder(type_1145c);
  ::Reflex::Type type_9957 = ::Reflex::ReferenceBuilder(type_174);
  ::Reflex::Type type_174c = ::Reflex::ConstBuilder(type_174);
  ::Reflex::Type type_9958 = ::Reflex::ReferenceBuilder(type_174c);
  ::Reflex::Type type_5450 = ::Reflex::PointerBuilder(type_1145c);
  ::Reflex::Type type_1878c = ::Reflex::ConstBuilder(type_1878);
  ::Reflex::Type type_5517 = ::Reflex::ReferenceBuilder(type_1074);
  ::Reflex::Type type_1074c = ::Reflex::ConstBuilder(type_1074);
  ::Reflex::Type type_5519 = ::Reflex::ReferenceBuilder(type_1074c);
  ::Reflex::Type type_9960 = ::Reflex::ReferenceBuilder(type_175);
  ::Reflex::Type type_175c = ::Reflex::ConstBuilder(type_175);
  ::Reflex::Type type_9961 = ::Reflex::ReferenceBuilder(type_175c);
  ::Reflex::Type type_5515 = ::Reflex::PointerBuilder(type_1074c);
  ::Reflex::Type type_1880c = ::Reflex::ConstBuilder(type_1880);
  ::Reflex::Type type_5712 = ::Reflex::ReferenceBuilder(type_1748);
  ::Reflex::Type type_1748c = ::Reflex::ConstBuilder(type_1748);
  ::Reflex::Type type_5714 = ::Reflex::ReferenceBuilder(type_1748c);
  ::Reflex::Type type_9963 = ::Reflex::ReferenceBuilder(type_176);
  ::Reflex::Type type_176c = ::Reflex::ConstBuilder(type_176);
  ::Reflex::Type type_9964 = ::Reflex::ReferenceBuilder(type_176c);
  ::Reflex::Type type_5710 = ::Reflex::PointerBuilder(type_1748c);
  ::Reflex::Type type_1881c = ::Reflex::ConstBuilder(type_1881);
  ::Reflex::Type type_5582 = ::Reflex::ReferenceBuilder(type_745);
  ::Reflex::Type type_745c = ::Reflex::ConstBuilder(type_745);
  ::Reflex::Type type_5584 = ::Reflex::ReferenceBuilder(type_745c);
  ::Reflex::Type type_9966 = ::Reflex::ReferenceBuilder(type_177);
  ::Reflex::Type type_177c = ::Reflex::ConstBuilder(type_177);
  ::Reflex::Type type_9967 = ::Reflex::ReferenceBuilder(type_177c);
  ::Reflex::Type type_5580 = ::Reflex::PointerBuilder(type_745c);
  ::Reflex::Type type_1882c = ::Reflex::ConstBuilder(type_1882);
  ::Reflex::Type type_145 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint8_t"), type_144);
  ::Reflex::Type type_6036 = ::Reflex::ReferenceBuilder(type_1624);
  ::Reflex::Type type_1624c = ::Reflex::ConstBuilder(type_1624);
  ::Reflex::Type type_6038 = ::Reflex::ReferenceBuilder(type_1624c);
  ::Reflex::Type type_9969 = ::Reflex::ReferenceBuilder(type_178);
  ::Reflex::Type type_178c = ::Reflex::ConstBuilder(type_178);
  ::Reflex::Type type_9970 = ::Reflex::ReferenceBuilder(type_178c);
  ::Reflex::Type type_6034 = ::Reflex::PointerBuilder(type_1624c);
  ::Reflex::Type type_1887c = ::Reflex::ConstBuilder(type_1887);
  ::Reflex::Type type_9972 = ::Reflex::ReferenceBuilder(type_179);
  ::Reflex::Type type_179c = ::Reflex::ConstBuilder(type_179);
  ::Reflex::Type type_9973 = ::Reflex::ReferenceBuilder(type_179c);
  ::Reflex::Type type_6099 = ::Reflex::PointerBuilder(type_50c);
  ::Reflex::Type type_1888c = ::Reflex::ConstBuilder(type_1888);
  ::Reflex::Type type_6296 = ::Reflex::ReferenceBuilder(type_1530);
  ::Reflex::Type type_1530c = ::Reflex::ConstBuilder(type_1530);
  ::Reflex::Type type_6298 = ::Reflex::ReferenceBuilder(type_1530c);
  ::Reflex::Type type_9975 = ::Reflex::ReferenceBuilder(type_180);
  ::Reflex::Type type_180c = ::Reflex::ConstBuilder(type_180);
  ::Reflex::Type type_9976 = ::Reflex::ReferenceBuilder(type_180c);
  ::Reflex::Type type_6294 = ::Reflex::PointerBuilder(type_1530c);
  ::Reflex::Type type_1889c = ::Reflex::ConstBuilder(type_1889);
  ::Reflex::Type type_6361 = ::Reflex::ReferenceBuilder(type_1511);
  ::Reflex::Type type_1511c = ::Reflex::ConstBuilder(type_1511);
  ::Reflex::Type type_6363 = ::Reflex::ReferenceBuilder(type_1511c);
  ::Reflex::Type type_9978 = ::Reflex::ReferenceBuilder(type_181);
  ::Reflex::Type type_181c = ::Reflex::ConstBuilder(type_181);
  ::Reflex::Type type_9979 = ::Reflex::ReferenceBuilder(type_181c);
  ::Reflex::Type type_6359 = ::Reflex::PointerBuilder(type_1511c);
  ::Reflex::Type type_1890c = ::Reflex::ConstBuilder(type_1890);
  ::Reflex::Type type_9981 = ::Reflex::ReferenceBuilder(type_182);
  ::Reflex::Type type_182c = ::Reflex::ConstBuilder(type_182);
  ::Reflex::Type type_9982 = ::Reflex::ReferenceBuilder(type_182c);
  ::Reflex::Type type_6164 = ::Reflex::PointerBuilder(type_27c);
  ::Reflex::Type type_1891c = ::Reflex::ConstBuilder(type_1891);
  ::Reflex::Type type_6231 = ::Reflex::ReferenceBuilder(type_491);
  ::Reflex::Type type_491c = ::Reflex::ConstBuilder(type_491);
  ::Reflex::Type type_6233 = ::Reflex::ReferenceBuilder(type_491c);
  ::Reflex::Type type_9984 = ::Reflex::ReferenceBuilder(type_183);
  ::Reflex::Type type_183c = ::Reflex::ConstBuilder(type_183);
  ::Reflex::Type type_9985 = ::Reflex::ReferenceBuilder(type_183c);
  ::Reflex::Type type_6229 = ::Reflex::PointerBuilder(type_491c);
  ::Reflex::Type type_1892c = ::Reflex::ConstBuilder(type_1892);
  ::Reflex::Type type_6426 = ::Reflex::ReferenceBuilder(type_231);
  ::Reflex::Type type_231c = ::Reflex::ConstBuilder(type_231);
  ::Reflex::Type type_6428 = ::Reflex::ReferenceBuilder(type_231c);
  ::Reflex::Type type_9987 = ::Reflex::ReferenceBuilder(type_184);
  ::Reflex::Type type_184c = ::Reflex::ConstBuilder(type_184);
  ::Reflex::Type type_9988 = ::Reflex::ReferenceBuilder(type_184c);
  ::Reflex::Type type_6424 = ::Reflex::PointerBuilder(type_231c);
  ::Reflex::Type type_1893c = ::Reflex::ConstBuilder(type_1893);
  ::Reflex::Type type_6491 = ::Reflex::ReferenceBuilder(type_530);
  ::Reflex::Type type_530c = ::Reflex::ConstBuilder(type_530);
  ::Reflex::Type type_6493 = ::Reflex::ReferenceBuilder(type_530c);
  ::Reflex::Type type_9990 = ::Reflex::ReferenceBuilder(type_185);
  ::Reflex::Type type_185c = ::Reflex::ConstBuilder(type_185);
  ::Reflex::Type type_9991 = ::Reflex::ReferenceBuilder(type_185c);
  ::Reflex::Type type_6489 = ::Reflex::PointerBuilder(type_530c);
  ::Reflex::Type type_1894c = ::Reflex::ConstBuilder(type_1894);
  ::Reflex::Type type_6556 = ::Reflex::ReferenceBuilder(type_1391);
  ::Reflex::Type type_1391c = ::Reflex::ConstBuilder(type_1391);
  ::Reflex::Type type_6558 = ::Reflex::ReferenceBuilder(type_1391c);
  ::Reflex::Type type_9993 = ::Reflex::ReferenceBuilder(type_186);
  ::Reflex::Type type_186c = ::Reflex::ConstBuilder(type_186);
  ::Reflex::Type type_9994 = ::Reflex::ReferenceBuilder(type_186c);
  ::Reflex::Type type_6554 = ::Reflex::PointerBuilder(type_1391c);
  ::Reflex::Type type_1899c = ::Reflex::ConstBuilder(type_1899);
  ::Reflex::Type type_6751 = ::Reflex::ReferenceBuilder(type_1252);
  ::Reflex::Type type_1252c = ::Reflex::ConstBuilder(type_1252);
  ::Reflex::Type type_6753 = ::Reflex::ReferenceBuilder(type_1252c);
  ::Reflex::Type type_43c = ::Reflex::ConstBuilder(type_43);
  ::Reflex::Type type_9996 = ::Reflex::ReferenceBuilder(type_187);
  ::Reflex::Type type_187c = ::Reflex::ConstBuilder(type_187);
  ::Reflex::Type type_9997 = ::Reflex::ReferenceBuilder(type_187c);
  ::Reflex::Type type_6749 = ::Reflex::PointerBuilder(type_1252c);
  ::Reflex::Type type_1900c = ::Reflex::ConstBuilder(type_1900);
  ::Reflex::Type type_9999 = ::Reflex::ReferenceBuilder(type_188);
  ::Reflex::Type type_188c = ::Reflex::ConstBuilder(type_188);
  ::Reflex::Type type_10000 = ::Reflex::ReferenceBuilder(type_188c);
  ::Reflex::Type type_6814 = ::Reflex::PointerBuilder(type_172c);
  ::Reflex::Type type_1901c = ::Reflex::ConstBuilder(type_1901);
  ::Reflex::Type type_10002 = ::Reflex::ReferenceBuilder(type_189);
  ::Reflex::Type type_189c = ::Reflex::ConstBuilder(type_189);
  ::Reflex::Type type_10003 = ::Reflex::ReferenceBuilder(type_189c);
  ::Reflex::Type type_6879 = ::Reflex::PointerBuilder(type_139c);
  ::Reflex::Type type_1903c = ::Reflex::ConstBuilder(type_1903);
  ::Reflex::Type type_6946 = ::Reflex::ReferenceBuilder(type_1357);
  ::Reflex::Type type_1357c = ::Reflex::ConstBuilder(type_1357);
  ::Reflex::Type type_6948 = ::Reflex::ReferenceBuilder(type_1357c);
  ::Reflex::Type type_10005 = ::Reflex::ReferenceBuilder(type_190);
  ::Reflex::Type type_190c = ::Reflex::ConstBuilder(type_190);
  ::Reflex::Type type_10006 = ::Reflex::ReferenceBuilder(type_190c);
  ::Reflex::Type type_6944 = ::Reflex::PointerBuilder(type_1357c);
  ::Reflex::Type type_1905c = ::Reflex::ConstBuilder(type_1905);
  ::Reflex::Type type_7011 = ::Reflex::ReferenceBuilder(type_716);
  ::Reflex::Type type_716c = ::Reflex::ConstBuilder(type_716);
  ::Reflex::Type type_7013 = ::Reflex::ReferenceBuilder(type_716c);
  ::Reflex::Type type_10008 = ::Reflex::ReferenceBuilder(type_191);
  ::Reflex::Type type_191c = ::Reflex::ConstBuilder(type_191);
  ::Reflex::Type type_10009 = ::Reflex::ReferenceBuilder(type_191c);
  ::Reflex::Type type_7009 = ::Reflex::PointerBuilder(type_716c);
  ::Reflex::Type type_1906c = ::Reflex::ConstBuilder(type_1906);
  ::Reflex::Type type_7076 = ::Reflex::ReferenceBuilder(type_1230);
  ::Reflex::Type type_1230c = ::Reflex::ConstBuilder(type_1230);
  ::Reflex::Type type_7078 = ::Reflex::ReferenceBuilder(type_1230c);
  ::Reflex::Type type_10011 = ::Reflex::ReferenceBuilder(type_192);
  ::Reflex::Type type_192c = ::Reflex::ConstBuilder(type_192);
  ::Reflex::Type type_10012 = ::Reflex::ReferenceBuilder(type_192c);
  ::Reflex::Type type_7074 = ::Reflex::PointerBuilder(type_1230c);
  ::Reflex::Type type_1907c = ::Reflex::ConstBuilder(type_1907);
  ::Reflex::Type type_10033 = ::Reflex::ReferenceBuilder(type_219);
  ::Reflex::Type type_219c = ::Reflex::ConstBuilder(type_219);
  ::Reflex::Type type_10034 = ::Reflex::ReferenceBuilder(type_219c);
  ::Reflex::Type type_1886c = ::Reflex::ConstBuilder(type_1886);
  ::Reflex::Type type_1885c = ::Reflex::ConstBuilder(type_1885);
  ::Reflex::Type type_10044 = ::Reflex::ReferenceBuilder(type_278);
  ::Reflex::Type type_278c = ::Reflex::ConstBuilder(type_278);
  ::Reflex::Type type_10045 = ::Reflex::ReferenceBuilder(type_278c);
  ::Reflex::Type type_1934c = ::Reflex::ConstBuilder(type_1934);
  ::Reflex::Type type_10062 = ::Reflex::ArrayBuilder(type_4028, 128);
  ::Reflex::Type type_10063 = ::Reflex::ReferenceBuilder(type_300);
  ::Reflex::Type type_300c = ::Reflex::ConstBuilder(type_300);
  ::Reflex::Type type_10064 = ::Reflex::ReferenceBuilder(type_300c);
  ::Reflex::Type type_10070 = ::Reflex::ReferenceBuilder(type_309);
  ::Reflex::Type type_309c = ::Reflex::ConstBuilder(type_309);
  ::Reflex::Type type_10071 = ::Reflex::ReferenceBuilder(type_309c);
  ::Reflex::Type type_14573 = ::Reflex::ArrayBuilder(type_1181, 10);
  ::Reflex::Type type_13470 = ::Reflex::ArrayBuilder(type_14573, 10);
  ::Reflex::Type type_10076 = ::Reflex::ArrayBuilder(type_13470, 4);
  ::Reflex::Type type_5906 = ::Reflex::ReferenceBuilder(type_333);
  ::Reflex::Type type_333c = ::Reflex::ConstBuilder(type_333);
  ::Reflex::Type type_5908 = ::Reflex::ReferenceBuilder(type_333c);
  ::Reflex::Type type_10129 = ::Reflex::ReferenceBuilder(type_506);
  ::Reflex::Type type_506c = ::Reflex::ConstBuilder(type_506);
  ::Reflex::Type type_10130 = ::Reflex::ReferenceBuilder(type_506c);
  ::Reflex::Type type_1671c = ::Reflex::ConstBuilder(type_1671);
  ::Reflex::Type type_5969 = ::Reflex::PointerBuilder(type_1671c);
  ::Reflex::Type type_5973 = ::Reflex::ReferenceBuilder(type_1671c);
  ::Reflex::Type type_10140 = ::Reflex::ReferenceBuilder(type_524);
  ::Reflex::Type type_524c = ::Reflex::ConstBuilder(type_524);
  ::Reflex::Type type_10141 = ::Reflex::ReferenceBuilder(type_524c);
  ::Reflex::Type type_10160 = ::Reflex::ReferenceBuilder(type_656);
  ::Reflex::Type type_656c = ::Reflex::ConstBuilder(type_656);
  ::Reflex::Type type_10161 = ::Reflex::ReferenceBuilder(type_656c);
  ::Reflex::Type type_1419c = ::Reflex::ConstBuilder(type_1419);
  ::Reflex::Type type_5843 = ::Reflex::ReferenceBuilder(type_1419c);
  ::Reflex::Type type_360c = ::Reflex::ConstBuilder(type_360);
  ::Reflex::Type type_4324 = ::Reflex::ReferenceBuilder(type_360c);
  ::Reflex::Type type_1856c = ::Reflex::ConstBuilder(type_1856);
  ::Reflex::Type type_10162 = ::Reflex::ReferenceBuilder(type_1856c);
  ::Reflex::Type type_10174 = ::Reflex::ReferenceBuilder(type_753);
  ::Reflex::Type type_753c = ::Reflex::ConstBuilder(type_753);
  ::Reflex::Type type_10175 = ::Reflex::ReferenceBuilder(type_753c);
  ::Reflex::Type type_10179 = ::Reflex::ReferenceBuilder(type_804);
  ::Reflex::Type type_804c = ::Reflex::ConstBuilder(type_804);
  ::Reflex::Type type_10180 = ::Reflex::ReferenceBuilder(type_804c);
  ::Reflex::Type type_10219 = ::Reflex::ReferenceBuilder(type_868);
  ::Reflex::Type type_868c = ::Reflex::ConstBuilder(type_868);
  ::Reflex::Type type_10220 = ::Reflex::ReferenceBuilder(type_868c);
  ::Reflex::Type type_10242 = ::Reflex::ReferenceBuilder(type_900);
  ::Reflex::Type type_900c = ::Reflex::ConstBuilder(type_900);
  ::Reflex::Type type_10243 = ::Reflex::ReferenceBuilder(type_900c);
  ::Reflex::Type type_11877 = ::Reflex::ReferenceBuilder(type_1120);
  ::Reflex::Type type_1120c = ::Reflex::ConstBuilder(type_1120);
  ::Reflex::Type type_11878 = ::Reflex::ReferenceBuilder(type_1120c);
  ::Reflex::Type type_11879 = ::Reflex::ReferenceBuilder(type_1162);
  ::Reflex::Type type_1162c = ::Reflex::ConstBuilder(type_1162);
  ::Reflex::Type type_11880 = ::Reflex::ReferenceBuilder(type_1162c);
  ::Reflex::Type type_11881 = ::Reflex::ReferenceBuilder(type_1187);
  ::Reflex::Type type_1187c = ::Reflex::ConstBuilder(type_1187);
  ::Reflex::Type type_11882 = ::Reflex::ReferenceBuilder(type_1187c);
  ::Reflex::Type type_11950 = ::Reflex::ReferenceBuilder(type_1297);
  ::Reflex::Type type_1297c = ::Reflex::ConstBuilder(type_1297);
  ::Reflex::Type type_11951 = ::Reflex::ReferenceBuilder(type_1297c);
  ::Reflex::Type type_11952 = ::Reflex::ReferenceBuilder(type_1300);
  ::Reflex::Type type_1300c = ::Reflex::ConstBuilder(type_1300);
  ::Reflex::Type type_11953 = ::Reflex::ReferenceBuilder(type_1300c);
  ::Reflex::Type type_11954 = ::Reflex::ReferenceBuilder(type_1306);
  ::Reflex::Type type_1306c = ::Reflex::ConstBuilder(type_1306);
  ::Reflex::Type type_11955 = ::Reflex::ReferenceBuilder(type_1306c);
  ::Reflex::Type type_11957 = ::Reflex::ReferenceBuilder(type_1350);
  ::Reflex::Type type_1350c = ::Reflex::ConstBuilder(type_1350);
  ::Reflex::Type type_11958 = ::Reflex::ReferenceBuilder(type_1350c);
  ::Reflex::Type type_5841 = ::Reflex::ReferenceBuilder(type_1419);
  ::Reflex::Type type_11961 = ::Reflex::ArrayBuilder(type_718, 2);
  ::Reflex::Type type_11962 = ::Reflex::ReferenceBuilder(type_1432);
  ::Reflex::Type type_1432c = ::Reflex::ConstBuilder(type_1432);
  ::Reflex::Type type_11963 = ::Reflex::ReferenceBuilder(type_1432c);
  ::Reflex::Type type_11964 = ::Reflex::ReferenceBuilder(type_1469);
  ::Reflex::Type type_1469c = ::Reflex::ConstBuilder(type_1469);
  ::Reflex::Type type_11965 = ::Reflex::ReferenceBuilder(type_1469c);
  ::Reflex::Type type_5904 = ::Reflex::PointerBuilder(type_333c);
  ::Reflex::Type type_11972 = ::Reflex::ReferenceBuilder(type_1491);
  ::Reflex::Type type_1491c = ::Reflex::ConstBuilder(type_1491);
  ::Reflex::Type type_11973 = ::Reflex::ReferenceBuilder(type_1491c);
  ::Reflex::Type type_11975 = ::Reflex::ReferenceBuilder(type_1567);
  ::Reflex::Type type_1567c = ::Reflex::ConstBuilder(type_1567);
  ::Reflex::Type type_11976 = ::Reflex::ReferenceBuilder(type_1567c);
  ::Reflex::Type type_14221 = ::Reflex::ArrayBuilder(type_549, 55);
  ::Reflex::Type type_12362 = ::Reflex::ArrayBuilder(type_14221, 4);
  ::Reflex::Type type_5971 = ::Reflex::ReferenceBuilder(type_1671);
  ::Reflex::Type type_12365 = ::Reflex::ReferenceBuilder(type_1729);
  ::Reflex::Type type_1729c = ::Reflex::ConstBuilder(type_1729);
  ::Reflex::Type type_12366 = ::Reflex::ReferenceBuilder(type_1729c);
  ::Reflex::Type type_4693 = ::Reflex::PointerBuilder(type_103);
  ::Reflex::Type type_2122 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_18);
  ::Reflex::Type type_1966 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_94);
  ::Reflex::Type type_2137c = ::Reflex::ConstBuilder(type_2137);
  ::Reflex::Type type_12395 = ::Reflex::ReferenceBuilder(type_2137c);
  ::Reflex::Type type_1849c = ::Reflex::ConstBuilder(type_1849);
  ::Reflex::Type type_12839 = ::Reflex::ReferenceBuilder(type_1849c);
  ::Reflex::Type type_12840 = ::Reflex::ReferenceBuilder(type_1849);
  ::Reflex::Type type_4712 = ::Reflex::PointerBuilder(type_1145);
  ::Reflex::Type type_2138c = ::Reflex::ConstBuilder(type_2138);
  ::Reflex::Type type_12408 = ::Reflex::ReferenceBuilder(type_2138c);
  ::Reflex::Type type_1850c = ::Reflex::ConstBuilder(type_1850);
  ::Reflex::Type type_12842 = ::Reflex::ReferenceBuilder(type_1850c);
  ::Reflex::Type type_12843 = ::Reflex::ReferenceBuilder(type_1850);
  ::Reflex::Type type_4749 = ::Reflex::PointerBuilder(type_1074);
  ::Reflex::Type type_2139c = ::Reflex::ConstBuilder(type_2139);
  ::Reflex::Type type_12434 = ::Reflex::ReferenceBuilder(type_2139c);
  ::Reflex::Type type_1851c = ::Reflex::ConstBuilder(type_1851);
  ::Reflex::Type type_12845 = ::Reflex::ReferenceBuilder(type_1851c);
  ::Reflex::Type type_12846 = ::Reflex::ReferenceBuilder(type_1851);
  ::Reflex::Type type_4805 = ::Reflex::PointerBuilder(type_745);
  ::Reflex::Type type_2140c = ::Reflex::ConstBuilder(type_2140);
  ::Reflex::Type type_12473 = ::Reflex::ReferenceBuilder(type_2140c);
  ::Reflex::Type type_1852c = ::Reflex::ConstBuilder(type_1852);
  ::Reflex::Type type_12848 = ::Reflex::ReferenceBuilder(type_1852c);
  ::Reflex::Type type_12849 = ::Reflex::ReferenceBuilder(type_1852);
  ::Reflex::Type type_4768 = ::Reflex::PointerBuilder(type_1748);
  ::Reflex::Type type_2142c = ::Reflex::ConstBuilder(type_2142);
  ::Reflex::Type type_12447 = ::Reflex::ReferenceBuilder(type_2142c);
  ::Reflex::Type type_1854c = ::Reflex::ConstBuilder(type_1854);
  ::Reflex::Type type_12853 = ::Reflex::ReferenceBuilder(type_1854c);
  ::Reflex::Type type_12854 = ::Reflex::ReferenceBuilder(type_1854);
  ::Reflex::Type type_5776 = ::Reflex::ReferenceBuilder(type_3088);
  ::Reflex::Type type_3088c = ::Reflex::ConstBuilder(type_3088);
  ::Reflex::Type type_5778 = ::Reflex::ReferenceBuilder(type_3088c);
  ::Reflex::Type type_4862 = ::Reflex::PointerBuilder(type_3088);
  ::Reflex::Type type_5348 = ::Reflex::PointerBuilder(type_3088c);
  ::Reflex::Type type_2143c = ::Reflex::ConstBuilder(type_2143);
  ::Reflex::Type type_12512 = ::Reflex::ReferenceBuilder(type_2143c);
  ::Reflex::Type type_1855c = ::Reflex::ConstBuilder(type_1855);
  ::Reflex::Type type_12855 = ::Reflex::ReferenceBuilder(type_1855c);
  ::Reflex::Type type_12856 = ::Reflex::ReferenceBuilder(type_1855);
  ::Reflex::Type type_4900 = ::Reflex::PointerBuilder(type_1419);
  ::Reflex::Type type_5839 = ::Reflex::PointerBuilder(type_1419c);
  ::Reflex::Type type_2144c = ::Reflex::ConstBuilder(type_2144);
  ::Reflex::Type type_12538 = ::Reflex::ReferenceBuilder(type_2144c);
  ::Reflex::Type type_10163 = ::Reflex::ReferenceBuilder(type_1856);
  ::Reflex::Type type_4824 = ::Reflex::PointerBuilder(type_333);
  ::Reflex::Type type_2145c = ::Reflex::ConstBuilder(type_2145);
  ::Reflex::Type type_12486 = ::Reflex::ReferenceBuilder(type_2145c);
  ::Reflex::Type type_1857c = ::Reflex::ConstBuilder(type_1857);
  ::Reflex::Type type_12859 = ::Reflex::ReferenceBuilder(type_1857c);
  ::Reflex::Type type_12860 = ::Reflex::ReferenceBuilder(type_1857);
  ::Reflex::Type type_4843 = ::Reflex::PointerBuilder(type_1671);
  ::Reflex::Type type_2146c = ::Reflex::ConstBuilder(type_2146);
  ::Reflex::Type type_12499 = ::Reflex::ReferenceBuilder(type_2146c);
  ::Reflex::Type type_1858c = ::Reflex::ConstBuilder(type_1858);
  ::Reflex::Type type_12862 = ::Reflex::ReferenceBuilder(type_1858c);
  ::Reflex::Type type_12863 = ::Reflex::ReferenceBuilder(type_1858);
  ::Reflex::Type type_4919 = ::Reflex::PointerBuilder(type_1624);
  ::Reflex::Type type_2147c = ::Reflex::ConstBuilder(type_2147);
  ::Reflex::Type type_12551 = ::Reflex::ReferenceBuilder(type_2147c);
  ::Reflex::Type type_1859c = ::Reflex::ConstBuilder(type_1859);
  ::Reflex::Type type_12865 = ::Reflex::ReferenceBuilder(type_1859c);
  ::Reflex::Type type_12866 = ::Reflex::ReferenceBuilder(type_1859);
  ::Reflex::Type type_4938 = ::Reflex::PointerBuilder(type_50);
  ::Reflex::Type type_2148c = ::Reflex::ConstBuilder(type_2148);
  ::Reflex::Type type_12564 = ::Reflex::ReferenceBuilder(type_2148c);
  ::Reflex::Type type_1860c = ::Reflex::ConstBuilder(type_1860);
  ::Reflex::Type type_12868 = ::Reflex::ReferenceBuilder(type_1860c);
  ::Reflex::Type type_12869 = ::Reflex::ReferenceBuilder(type_1860);
  ::Reflex::Type type_4995 = ::Reflex::PointerBuilder(type_27);
  ::Reflex::Type type_2149c = ::Reflex::ConstBuilder(type_2149);
  ::Reflex::Type type_12603 = ::Reflex::ReferenceBuilder(type_2149c);
  ::Reflex::Type type_1861c = ::Reflex::ConstBuilder(type_1861);
  ::Reflex::Type type_12871 = ::Reflex::ReferenceBuilder(type_1861c);
  ::Reflex::Type type_12872 = ::Reflex::ReferenceBuilder(type_1861);
  ::Reflex::Type type_5014 = ::Reflex::PointerBuilder(type_491);
  ::Reflex::Type type_2150c = ::Reflex::ConstBuilder(type_2150);
  ::Reflex::Type type_12616 = ::Reflex::ReferenceBuilder(type_2150c);
  ::Reflex::Type type_1862c = ::Reflex::ConstBuilder(type_1862);
  ::Reflex::Type type_12874 = ::Reflex::ReferenceBuilder(type_1862c);
  ::Reflex::Type type_12875 = ::Reflex::ReferenceBuilder(type_1862);
  ::Reflex::Type type_4957 = ::Reflex::PointerBuilder(type_1530);
  ::Reflex::Type type_2151c = ::Reflex::ConstBuilder(type_2151);
  ::Reflex::Type type_12577 = ::Reflex::ReferenceBuilder(type_2151c);
  ::Reflex::Type type_1863c = ::Reflex::ConstBuilder(type_1863);
  ::Reflex::Type type_12877 = ::Reflex::ReferenceBuilder(type_1863c);
  ::Reflex::Type type_12878 = ::Reflex::ReferenceBuilder(type_1863);
  ::Reflex::Type type_4976 = ::Reflex::PointerBuilder(type_1511);
  ::Reflex::Type type_2152c = ::Reflex::ConstBuilder(type_2152);
  ::Reflex::Type type_12590 = ::Reflex::ReferenceBuilder(type_2152c);
  ::Reflex::Type type_1864c = ::Reflex::ConstBuilder(type_1864);
  ::Reflex::Type type_12880 = ::Reflex::ReferenceBuilder(type_1864c);
  ::Reflex::Type type_12881 = ::Reflex::ReferenceBuilder(type_1864);
  ::Reflex::Type type_5033 = ::Reflex::PointerBuilder(type_231);
  ::Reflex::Type type_2153c = ::Reflex::ConstBuilder(type_2153);
  ::Reflex::Type type_12629 = ::Reflex::ReferenceBuilder(type_2153c);
  ::Reflex::Type type_1865c = ::Reflex::ConstBuilder(type_1865);
  ::Reflex::Type type_12883 = ::Reflex::ReferenceBuilder(type_1865c);
  ::Reflex::Type type_12884 = ::Reflex::ReferenceBuilder(type_1865);
  ::Reflex::Type type_5052 = ::Reflex::PointerBuilder(type_530);
  ::Reflex::Type type_2154c = ::Reflex::ConstBuilder(type_2154);
  ::Reflex::Type type_12642 = ::Reflex::ReferenceBuilder(type_2154c);
  ::Reflex::Type type_1866c = ::Reflex::ConstBuilder(type_1866);
  ::Reflex::Type type_12886 = ::Reflex::ReferenceBuilder(type_1866c);
  ::Reflex::Type type_12887 = ::Reflex::ReferenceBuilder(type_1866);
  ::Reflex::Type type_5147 = ::Reflex::PointerBuilder(type_1391);
  ::Reflex::Type type_2155c = ::Reflex::ConstBuilder(type_2155);
  ::Reflex::Type type_12707 = ::Reflex::ReferenceBuilder(type_2155c);
  ::Reflex::Type type_1867c = ::Reflex::ConstBuilder(type_1867);
  ::Reflex::Type type_12889 = ::Reflex::ReferenceBuilder(type_1867c);
  ::Reflex::Type type_12890 = ::Reflex::ReferenceBuilder(type_1867);
  ::Reflex::Type type_6621 = ::Reflex::ReferenceBuilder(type_2577);
  ::Reflex::Type type_2577c = ::Reflex::ConstBuilder(type_2577);
  ::Reflex::Type type_6623 = ::Reflex::ReferenceBuilder(type_2577c);
  ::Reflex::Type type_5109 = ::Reflex::PointerBuilder(type_2577);
  ::Reflex::Type type_6619 = ::Reflex::PointerBuilder(type_2577c);
  ::Reflex::Type type_2156c = ::Reflex::ConstBuilder(type_2156);
  ::Reflex::Type type_12681 = ::Reflex::ReferenceBuilder(type_2156c);
  ::Reflex::Type type_1868c = ::Reflex::ConstBuilder(type_1868);
  ::Reflex::Type type_12892 = ::Reflex::ReferenceBuilder(type_1868c);
  ::Reflex::Type type_12893 = ::Reflex::ReferenceBuilder(type_1868);
  ::Reflex::Type type_6686 = ::Reflex::ReferenceBuilder(type_2576);
  ::Reflex::Type type_2576c = ::Reflex::ConstBuilder(type_2576);
  ::Reflex::Type type_6688 = ::Reflex::ReferenceBuilder(type_2576c);
  ::Reflex::Type type_5128 = ::Reflex::PointerBuilder(type_2576);
  ::Reflex::Type type_6684 = ::Reflex::PointerBuilder(type_2576c);
  ::Reflex::Type type_2157c = ::Reflex::ConstBuilder(type_2157);
  ::Reflex::Type type_12694 = ::Reflex::ReferenceBuilder(type_2157c);
  ::Reflex::Type type_1869c = ::Reflex::ConstBuilder(type_1869);
  ::Reflex::Type type_12895 = ::Reflex::ReferenceBuilder(type_1869c);
  ::Reflex::Type type_12896 = ::Reflex::ReferenceBuilder(type_1869);
  ::Reflex::Type type_5166 = ::Reflex::PointerBuilder(type_1252);
  ::Reflex::Type type_2158c = ::Reflex::ConstBuilder(type_2158);
  ::Reflex::Type type_12720 = ::Reflex::ReferenceBuilder(type_2158c);
  ::Reflex::Type type_1870c = ::Reflex::ConstBuilder(type_1870);
  ::Reflex::Type type_12898 = ::Reflex::ReferenceBuilder(type_1870c);
  ::Reflex::Type type_12899 = ::Reflex::ReferenceBuilder(type_1870);
  ::Reflex::Type type_5185 = ::Reflex::PointerBuilder(type_172);
  ::Reflex::Type type_2159c = ::Reflex::ConstBuilder(type_2159);
  ::Reflex::Type type_12733 = ::Reflex::ReferenceBuilder(type_2159c);
  ::Reflex::Type type_1871c = ::Reflex::ConstBuilder(type_1871);
  ::Reflex::Type type_12901 = ::Reflex::ReferenceBuilder(type_1871c);
  ::Reflex::Type type_12902 = ::Reflex::ReferenceBuilder(type_1871);
  ::Reflex::Type type_5222 = ::Reflex::PointerBuilder(type_139);
  ::Reflex::Type type_2160c = ::Reflex::ConstBuilder(type_2160);
  ::Reflex::Type type_12759 = ::Reflex::ReferenceBuilder(type_2160c);
  ::Reflex::Type type_1872c = ::Reflex::ConstBuilder(type_1872);
  ::Reflex::Type type_12904 = ::Reflex::ReferenceBuilder(type_1872c);
  ::Reflex::Type type_12905 = ::Reflex::ReferenceBuilder(type_1872);
  ::Reflex::Type type_5260 = ::Reflex::PointerBuilder(type_1357);
  ::Reflex::Type type_2161c = ::Reflex::ConstBuilder(type_2161);
  ::Reflex::Type type_12785 = ::Reflex::ReferenceBuilder(type_2161c);
  ::Reflex::Type type_1873c = ::Reflex::ConstBuilder(type_1873);
  ::Reflex::Type type_12907 = ::Reflex::ReferenceBuilder(type_1873c);
  ::Reflex::Type type_12908 = ::Reflex::ReferenceBuilder(type_1873);
  ::Reflex::Type type_5279 = ::Reflex::PointerBuilder(type_716);
  ::Reflex::Type type_2162c = ::Reflex::ConstBuilder(type_2162);
  ::Reflex::Type type_12798 = ::Reflex::ReferenceBuilder(type_2162c);
  ::Reflex::Type type_1874c = ::Reflex::ConstBuilder(type_1874);
  ::Reflex::Type type_12910 = ::Reflex::ReferenceBuilder(type_1874c);
  ::Reflex::Type type_12911 = ::Reflex::ReferenceBuilder(type_1874);
  ::Reflex::Type type_5298 = ::Reflex::PointerBuilder(type_1230);
  ::Reflex::Type type_2163c = ::Reflex::ConstBuilder(type_2163);
  ::Reflex::Type type_12811 = ::Reflex::ReferenceBuilder(type_2163c);
  ::Reflex::Type type_1875c = ::Reflex::ConstBuilder(type_1875);
  ::Reflex::Type type_12913 = ::Reflex::ReferenceBuilder(type_1875c);
  ::Reflex::Type type_12914 = ::Reflex::ReferenceBuilder(type_1875);
  ::Reflex::Type type_13813 = ::Reflex::ReferenceBuilder(type_4282);
  ::Reflex::Type type_4282c = ::Reflex::ConstBuilder(type_4282);
  ::Reflex::Type type_13814 = ::Reflex::ReferenceBuilder(type_4282c);
  ::Reflex::Type type_1876f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalTimingParam> > >"), type_1876);
  ::Reflex::Type type_1878f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalFlagHFDigiTimeParam> > >"), type_1878);
  ::Reflex::Type type_1880f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalMCParam> > >"), type_1880);
  ::Reflex::Type type_1881f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalLongRecoParam> > >"), type_1881);
  ::Reflex::Type type_1882f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalRecoParam> > >"), type_1882);
  ::Reflex::Type type_1887f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalLutMetadatum> > >"), type_1887);
  ::Reflex::Type type_1888f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalValidationCorr> > >"), type_1888);
  ::Reflex::Type type_1889f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalPFCorr> > >"), type_1889);
  ::Reflex::Type type_1890f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalLUTCorr> > >"), type_1890);
  ::Reflex::Type type_1891f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalTimeCorr> > >"), type_1891);
  ::Reflex::Type type_1892f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalL1TriggerObject> > >"), type_1892);
  ::Reflex::Type type_1893f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalRespCorr> > >"), type_1893);
  ::Reflex::Type type_1894f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalZSThreshold> > >"), type_1894);
  ::Reflex::Type type_1899f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalChannelStatus> > >"), type_1899);
  ::Reflex::Type type_1900f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalCalibrationQIECoder> > >"), type_1900);
  ::Reflex::Type type_1901f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalQIECoder> > >"), type_1901);
  ::Reflex::Type type_1903f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalGainWidth> > >"), type_1903);
  ::Reflex::Type type_1905f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalGain> > >"), type_1905);
  ::Reflex::Type type_1906f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalPedestalWidth> > >"), type_1906);
  ::Reflex::Type type_1907f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::pair<std::string, std::vector<HcalPedestal> > >"), type_1907);
  ::Reflex::Type type_2086f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalTimingParam> >"), type_2086);
  ::Reflex::Type type_2087f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalFlagHFDigiTimeParam> >"), type_2087);
  ::Reflex::Type type_2088f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalMCParam> >"), type_2088);
  ::Reflex::Type type_2089f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalLongRecoParam> >"), type_2089);
  ::Reflex::Type type_2090f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalRecoParam> >"), type_2090);
  ::Reflex::Type type_2091f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalLutMetadatum> >"), type_2091);
  ::Reflex::Type type_2092f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalValidationCorr> >"), type_2092);
  ::Reflex::Type type_2093f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalPFCorr> >"), type_2093);
  ::Reflex::Type type_2094f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalLUTCorr> >"), type_2094);
  ::Reflex::Type type_2095f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalTimeCorr> >"), type_2095);
  ::Reflex::Type type_2096f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalL1TriggerObject> >"), type_2096);
  ::Reflex::Type type_2097f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalRespCorr> >"), type_2097);
  ::Reflex::Type type_2098f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalZSThreshold> >"), type_2098);
  ::Reflex::Type type_2099f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalChannelStatus> >"), type_2099);
  ::Reflex::Type type_2100f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalCalibrationQIECoder> >"), type_2100);
  ::Reflex::Type type_2101f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalQIECoder> >"), type_2101);
  ::Reflex::Type type_2102f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalGainWidth> >"), type_2102);
  ::Reflex::Type type_2103f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalGain> >"), type_2103);
  ::Reflex::Type type_2104f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalPedestalWidth> >"), type_2104);
  ::Reflex::Type type_2105f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, std::vector<HcalPedestal> >"), type_2105);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __HcalLongRecoParams
#undef __HcalLongRecoParams
#endif
class __HcalLongRecoParams : public ::HcalCondObjectContainer<HcalLongRecoParam> {
  public:
  __HcalLongRecoParams();
  virtual ~__HcalLongRecoParams() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalTimeCorr
#undef __HcalTimeCorr
#endif
class __HcalTimeCorr {
  public:
  __HcalTimeCorr();
  ::uint32_t mId;
  float mValue;
};
#ifdef __HcalValidationCorr
#undef __HcalValidationCorr
#endif
class __HcalValidationCorr {
  public:
  __HcalValidationCorr();
  ::uint32_t mId;
  float mValue;
};
#ifdef __HcalTimingParam
#undef __HcalTimingParam
#endif
class __HcalTimingParam {
  public:
  __HcalTimingParam();
  ::uint32_t mId;
  ::uint32_t m_nhits;
  float m_phase;
  float m_rms;
};
#ifdef __HcalMCParams
#undef __HcalMCParams
#endif
class __HcalMCParams : public ::HcalCondObjectContainer<HcalMCParam> {
  public:
  __HcalMCParams();
  virtual ~__HcalMCParams() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalGainWidth
#undef __HcalGainWidth
#endif
class __HcalGainWidth {
  public:
  __HcalGainWidth();
  ::uint32_t mId;
  float mValue0;
  float mValue1;
  float mValue2;
  float mValue3;
};
#ifdef __HcalElectronicsMap
#undef __HcalElectronicsMap
#endif
class __HcalElectronicsMap {
  public:
  __HcalElectronicsMap();
  ::std::vector<HcalElectronicsMap::PrecisionItem> mPItems;
  ::std::vector<HcalElectronicsMap::TriggerItem> mTItems;
  ::std::vector<const HcalElectronicsMap::PrecisionItem*> mPItemsById;
  bool sortedByPId;
  ::std::vector<const HcalElectronicsMap::TriggerItem*> mTItemsByTrigId;
  bool sortedByTId;
};
#ifdef __HcalQIECoder
#undef __HcalQIECoder
#endif
class __HcalQIECoder {
  public:
  __HcalQIECoder();
  ::uint32_t mId;
  float mOffset00;
  float mOffset01;
  float mOffset02;
  float mOffset03;
  float mOffset10;
  float mOffset11;
  float mOffset12;
  float mOffset13;
  float mOffset20;
  float mOffset21;
  float mOffset22;
  float mOffset23;
  float mOffset30;
  float mOffset31;
  float mOffset32;
  float mOffset33;
  float mSlope00;
  float mSlope01;
  float mSlope02;
  float mSlope03;
  float mSlope10;
  float mSlope11;
  float mSlope12;
  float mSlope13;
  float mSlope20;
  float mSlope21;
  float mSlope22;
  float mSlope23;
  float mSlope30;
  float mSlope31;
  float mSlope32;
  float mSlope33;
  unsigned int mQIEIndex;
};
#ifdef __HcalCondObjectContainer_HcalTimingParam_
#undef __HcalCondObjectContainer_HcalTimingParam_
#endif
class __HcalCondObjectContainer_HcalTimingParam_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalTimingParam_();
  virtual ~__HcalCondObjectContainer_HcalTimingParam_() throw();
  ::std::vector<HcalTimingParam> HBcontainer;
  ::std::vector<HcalTimingParam> HEcontainer;
  ::std::vector<HcalTimingParam> HOcontainer;
  ::std::vector<HcalTimingParam> HFcontainer;
  ::std::vector<HcalTimingParam> HTcontainer;
  ::std::vector<HcalTimingParam> ZDCcontainer;
  ::std::vector<HcalTimingParam> CALIBcontainer;
  ::std::vector<HcalTimingParam> CASTORcontainer;
};
#ifdef __HcalFlagHFDigiTimeParam
#undef __HcalFlagHFDigiTimeParam
#endif
class __HcalFlagHFDigiTimeParam {
  public:
  __HcalFlagHFDigiTimeParam();
  ::uint32_t mId;
  ::uint32_t mHFdigiflagFirstSample;
  ::uint32_t mHFdigiflagSamplesToAdd;
  ::uint32_t mHFdigiflagExpectedPeak;
  double mHFdigiflagMinEthreshold;
  ::std::vector<double> mHFdigiflagCoefficients;
};
#ifdef __HcalCondObjectContainer_HcalFlagHFDigiTimeParam_
#undef __HcalCondObjectContainer_HcalFlagHFDigiTimeParam_
#endif
class __HcalCondObjectContainer_HcalFlagHFDigiTimeParam_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalFlagHFDigiTimeParam_();
  virtual ~__HcalCondObjectContainer_HcalFlagHFDigiTimeParam_() throw();
  ::std::vector<HcalFlagHFDigiTimeParam> HBcontainer;
  ::std::vector<HcalFlagHFDigiTimeParam> HEcontainer;
  ::std::vector<HcalFlagHFDigiTimeParam> HOcontainer;
  ::std::vector<HcalFlagHFDigiTimeParam> HFcontainer;
  ::std::vector<HcalFlagHFDigiTimeParam> HTcontainer;
  ::std::vector<HcalFlagHFDigiTimeParam> ZDCcontainer;
  ::std::vector<HcalFlagHFDigiTimeParam> CALIBcontainer;
  ::std::vector<HcalFlagHFDigiTimeParam> CASTORcontainer;
};
#ifdef __HcalMCParam
#undef __HcalMCParam
#endif
class __HcalMCParam {
  public:
  __HcalMCParam();
  ::uint32_t mId;
  ::uint32_t mParam1;
};
#ifdef __HcalCondObjectContainer_HcalMCParam_
#undef __HcalCondObjectContainer_HcalMCParam_
#endif
class __HcalCondObjectContainer_HcalMCParam_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalMCParam_();
  virtual ~__HcalCondObjectContainer_HcalMCParam_() throw();
  ::std::vector<HcalMCParam> HBcontainer;
  ::std::vector<HcalMCParam> HEcontainer;
  ::std::vector<HcalMCParam> HOcontainer;
  ::std::vector<HcalMCParam> HFcontainer;
  ::std::vector<HcalMCParam> HTcontainer;
  ::std::vector<HcalMCParam> ZDCcontainer;
  ::std::vector<HcalMCParam> CALIBcontainer;
  ::std::vector<HcalMCParam> CASTORcontainer;
};
#ifdef __HcalLongRecoParam
#undef __HcalLongRecoParam
#endif
class __HcalLongRecoParam {
  public:
  __HcalLongRecoParam();
  ::uint32_t mId;
  ::std::vector<unsigned int> mSignalTS;
  ::std::vector<unsigned int> mNoiseTS;
};
#ifdef __HcalCondObjectContainer_HcalLongRecoParam_
#undef __HcalCondObjectContainer_HcalLongRecoParam_
#endif
class __HcalCondObjectContainer_HcalLongRecoParam_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalLongRecoParam_();
  virtual ~__HcalCondObjectContainer_HcalLongRecoParam_() throw();
  ::std::vector<HcalLongRecoParam> HBcontainer;
  ::std::vector<HcalLongRecoParam> HEcontainer;
  ::std::vector<HcalLongRecoParam> HOcontainer;
  ::std::vector<HcalLongRecoParam> HFcontainer;
  ::std::vector<HcalLongRecoParam> HTcontainer;
  ::std::vector<HcalLongRecoParam> ZDCcontainer;
  ::std::vector<HcalLongRecoParam> CALIBcontainer;
  ::std::vector<HcalLongRecoParam> CASTORcontainer;
};
#ifdef __HcalRecoParam
#undef __HcalRecoParam
#endif
class __HcalRecoParam {
  public:
  __HcalRecoParam();
  ::uint32_t mId;
  ::uint32_t mParam1;
  ::uint32_t mParam2;
};
#ifdef __HcalCondObjectContainer_HcalRecoParam_
#undef __HcalCondObjectContainer_HcalRecoParam_
#endif
class __HcalCondObjectContainer_HcalRecoParam_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalRecoParam_();
  virtual ~__HcalCondObjectContainer_HcalRecoParam_() throw();
  ::std::vector<HcalRecoParam> HBcontainer;
  ::std::vector<HcalRecoParam> HEcontainer;
  ::std::vector<HcalRecoParam> HOcontainer;
  ::std::vector<HcalRecoParam> HFcontainer;
  ::std::vector<HcalRecoParam> HTcontainer;
  ::std::vector<HcalRecoParam> ZDCcontainer;
  ::std::vector<HcalRecoParam> CALIBcontainer;
  ::std::vector<HcalRecoParam> CASTORcontainer;
};
#ifdef __HcalLutMetadatum
#undef __HcalLutMetadatum
#endif
class __HcalLutMetadatum {
  public:
  __HcalLutMetadatum();
  ::uint32_t mId;
  float mRCalib;
  ::uint8_t mLutGranularity;
  ::uint8_t mOutputLutThreshold;
};
#ifdef __HcalCondObjectContainer_HcalLutMetadatum_
#undef __HcalCondObjectContainer_HcalLutMetadatum_
#endif
class __HcalCondObjectContainer_HcalLutMetadatum_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalLutMetadatum_();
  virtual ~__HcalCondObjectContainer_HcalLutMetadatum_() throw();
  ::std::vector<HcalLutMetadatum> HBcontainer;
  ::std::vector<HcalLutMetadatum> HEcontainer;
  ::std::vector<HcalLutMetadatum> HOcontainer;
  ::std::vector<HcalLutMetadatum> HFcontainer;
  ::std::vector<HcalLutMetadatum> HTcontainer;
  ::std::vector<HcalLutMetadatum> ZDCcontainer;
  ::std::vector<HcalLutMetadatum> CALIBcontainer;
  ::std::vector<HcalLutMetadatum> CASTORcontainer;
};
#ifdef __HcalCondObjectContainer_HcalValidationCorr_
#undef __HcalCondObjectContainer_HcalValidationCorr_
#endif
class __HcalCondObjectContainer_HcalValidationCorr_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalValidationCorr_();
  virtual ~__HcalCondObjectContainer_HcalValidationCorr_() throw();
  ::std::vector<HcalValidationCorr> HBcontainer;
  ::std::vector<HcalValidationCorr> HEcontainer;
  ::std::vector<HcalValidationCorr> HOcontainer;
  ::std::vector<HcalValidationCorr> HFcontainer;
  ::std::vector<HcalValidationCorr> HTcontainer;
  ::std::vector<HcalValidationCorr> ZDCcontainer;
  ::std::vector<HcalValidationCorr> CALIBcontainer;
  ::std::vector<HcalValidationCorr> CASTORcontainer;
};
#ifdef __HcalPFCorr
#undef __HcalPFCorr
#endif
class __HcalPFCorr {
  public:
  __HcalPFCorr();
  ::uint32_t mId;
  float mValue;
};
#ifdef __HcalCondObjectContainer_HcalPFCorr_
#undef __HcalCondObjectContainer_HcalPFCorr_
#endif
class __HcalCondObjectContainer_HcalPFCorr_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalPFCorr_();
  virtual ~__HcalCondObjectContainer_HcalPFCorr_() throw();
  ::std::vector<HcalPFCorr> HBcontainer;
  ::std::vector<HcalPFCorr> HEcontainer;
  ::std::vector<HcalPFCorr> HOcontainer;
  ::std::vector<HcalPFCorr> HFcontainer;
  ::std::vector<HcalPFCorr> HTcontainer;
  ::std::vector<HcalPFCorr> ZDCcontainer;
  ::std::vector<HcalPFCorr> CALIBcontainer;
  ::std::vector<HcalPFCorr> CASTORcontainer;
};
#ifdef __HcalLUTCorr
#undef __HcalLUTCorr
#endif
class __HcalLUTCorr {
  public:
  __HcalLUTCorr();
  ::uint32_t mId;
  float mValue;
};
#ifdef __HcalCondObjectContainer_HcalLUTCorr_
#undef __HcalCondObjectContainer_HcalLUTCorr_
#endif
class __HcalCondObjectContainer_HcalLUTCorr_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalLUTCorr_();
  virtual ~__HcalCondObjectContainer_HcalLUTCorr_() throw();
  ::std::vector<HcalLUTCorr> HBcontainer;
  ::std::vector<HcalLUTCorr> HEcontainer;
  ::std::vector<HcalLUTCorr> HOcontainer;
  ::std::vector<HcalLUTCorr> HFcontainer;
  ::std::vector<HcalLUTCorr> HTcontainer;
  ::std::vector<HcalLUTCorr> ZDCcontainer;
  ::std::vector<HcalLUTCorr> CALIBcontainer;
  ::std::vector<HcalLUTCorr> CASTORcontainer;
};
#ifdef __HcalCondObjectContainer_HcalTimeCorr_
#undef __HcalCondObjectContainer_HcalTimeCorr_
#endif
class __HcalCondObjectContainer_HcalTimeCorr_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalTimeCorr_();
  virtual ~__HcalCondObjectContainer_HcalTimeCorr_() throw();
  ::std::vector<HcalTimeCorr> HBcontainer;
  ::std::vector<HcalTimeCorr> HEcontainer;
  ::std::vector<HcalTimeCorr> HOcontainer;
  ::std::vector<HcalTimeCorr> HFcontainer;
  ::std::vector<HcalTimeCorr> HTcontainer;
  ::std::vector<HcalTimeCorr> ZDCcontainer;
  ::std::vector<HcalTimeCorr> CALIBcontainer;
  ::std::vector<HcalTimeCorr> CASTORcontainer;
};
#ifdef __HcalL1TriggerObject
#undef __HcalL1TriggerObject
#endif
class __HcalL1TriggerObject {
  public:
  __HcalL1TriggerObject();
  ::uint32_t mId;
  float mAvrgPed;
  float mRespCorrGain;
  ::uint32_t mFlag;
};
#ifdef __HcalCondObjectContainer_HcalL1TriggerObject_
#undef __HcalCondObjectContainer_HcalL1TriggerObject_
#endif
class __HcalCondObjectContainer_HcalL1TriggerObject_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalL1TriggerObject_();
  virtual ~__HcalCondObjectContainer_HcalL1TriggerObject_() throw();
  ::std::vector<HcalL1TriggerObject> HBcontainer;
  ::std::vector<HcalL1TriggerObject> HEcontainer;
  ::std::vector<HcalL1TriggerObject> HOcontainer;
  ::std::vector<HcalL1TriggerObject> HFcontainer;
  ::std::vector<HcalL1TriggerObject> HTcontainer;
  ::std::vector<HcalL1TriggerObject> ZDCcontainer;
  ::std::vector<HcalL1TriggerObject> CALIBcontainer;
  ::std::vector<HcalL1TriggerObject> CASTORcontainer;
};
#ifdef __HcalRespCorr
#undef __HcalRespCorr
#endif
class __HcalRespCorr {
  public:
  __HcalRespCorr();
  ::uint32_t mId;
  float mValue;
};
#ifdef __HcalCondObjectContainer_HcalRespCorr_
#undef __HcalCondObjectContainer_HcalRespCorr_
#endif
class __HcalCondObjectContainer_HcalRespCorr_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalRespCorr_();
  virtual ~__HcalCondObjectContainer_HcalRespCorr_() throw();
  ::std::vector<HcalRespCorr> HBcontainer;
  ::std::vector<HcalRespCorr> HEcontainer;
  ::std::vector<HcalRespCorr> HOcontainer;
  ::std::vector<HcalRespCorr> HFcontainer;
  ::std::vector<HcalRespCorr> HTcontainer;
  ::std::vector<HcalRespCorr> ZDCcontainer;
  ::std::vector<HcalRespCorr> CALIBcontainer;
  ::std::vector<HcalRespCorr> CASTORcontainer;
};
#ifdef __HcalZSThreshold
#undef __HcalZSThreshold
#endif
class __HcalZSThreshold {
  public:
  __HcalZSThreshold();
  ::uint32_t mId;
  int mLevel;
};
#ifdef __HcalCondObjectContainer_HcalZSThreshold_
#undef __HcalCondObjectContainer_HcalZSThreshold_
#endif
class __HcalCondObjectContainer_HcalZSThreshold_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalZSThreshold_();
  virtual ~__HcalCondObjectContainer_HcalZSThreshold_() throw();
  ::std::vector<HcalZSThreshold> HBcontainer;
  ::std::vector<HcalZSThreshold> HEcontainer;
  ::std::vector<HcalZSThreshold> HOcontainer;
  ::std::vector<HcalZSThreshold> HFcontainer;
  ::std::vector<HcalZSThreshold> HTcontainer;
  ::std::vector<HcalZSThreshold> ZDCcontainer;
  ::std::vector<HcalZSThreshold> CALIBcontainer;
  ::std::vector<HcalZSThreshold> CASTORcontainer;
};
#ifdef __HcalChannelStatus
#undef __HcalChannelStatus
#endif
class __HcalChannelStatus {
  public:
  __HcalChannelStatus();
  ::uint32_t mId;
  ::uint32_t mStatus;
};
#ifdef __HcalCondObjectContainer_HcalChannelStatus_
#undef __HcalCondObjectContainer_HcalChannelStatus_
#endif
class __HcalCondObjectContainer_HcalChannelStatus_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalChannelStatus_();
  virtual ~__HcalCondObjectContainer_HcalChannelStatus_() throw();
  ::std::vector<HcalChannelStatus> HBcontainer;
  ::std::vector<HcalChannelStatus> HEcontainer;
  ::std::vector<HcalChannelStatus> HOcontainer;
  ::std::vector<HcalChannelStatus> HFcontainer;
  ::std::vector<HcalChannelStatus> HTcontainer;
  ::std::vector<HcalChannelStatus> ZDCcontainer;
  ::std::vector<HcalChannelStatus> CALIBcontainer;
  ::std::vector<HcalChannelStatus> CASTORcontainer;
};
#ifdef __HcalCalibrationQIECoder
#undef __HcalCalibrationQIECoder
#endif
class __HcalCalibrationQIECoder {
  public:
  __HcalCalibrationQIECoder();
  ::uint32_t mId;
  float bin0;
  float bin1;
  float bin2;
  float bin3;
  float bin4;
  float bin5;
  float bin6;
  float bin7;
  float bin8;
  float bin9;
  float bin10;
  float bin11;
  float bin12;
  float bin13;
  float bin14;
  float bin15;
  float bin16;
  float bin17;
  float bin18;
  float bin19;
  float bin20;
  float bin21;
  float bin22;
  float bin23;
  float bin24;
  float bin25;
  float bin26;
  float bin27;
  float bin28;
  float bin29;
  float bin30;
  float bin31;
};
#ifdef __HcalCondObjectContainer_HcalCalibrationQIECoder_
#undef __HcalCondObjectContainer_HcalCalibrationQIECoder_
#endif
class __HcalCondObjectContainer_HcalCalibrationQIECoder_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalCalibrationQIECoder_();
  virtual ~__HcalCondObjectContainer_HcalCalibrationQIECoder_() throw();
  ::std::vector<HcalCalibrationQIECoder> HBcontainer;
  ::std::vector<HcalCalibrationQIECoder> HEcontainer;
  ::std::vector<HcalCalibrationQIECoder> HOcontainer;
  ::std::vector<HcalCalibrationQIECoder> HFcontainer;
  ::std::vector<HcalCalibrationQIECoder> HTcontainer;
  ::std::vector<HcalCalibrationQIECoder> ZDCcontainer;
  ::std::vector<HcalCalibrationQIECoder> CALIBcontainer;
  ::std::vector<HcalCalibrationQIECoder> CASTORcontainer;
};
#ifdef __HcalCondObjectContainer_HcalQIECoder_
#undef __HcalCondObjectContainer_HcalQIECoder_
#endif
class __HcalCondObjectContainer_HcalQIECoder_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalQIECoder_();
  virtual ~__HcalCondObjectContainer_HcalQIECoder_() throw();
  ::std::vector<HcalQIECoder> HBcontainer;
  ::std::vector<HcalQIECoder> HEcontainer;
  ::std::vector<HcalQIECoder> HOcontainer;
  ::std::vector<HcalQIECoder> HFcontainer;
  ::std::vector<HcalQIECoder> HTcontainer;
  ::std::vector<HcalQIECoder> ZDCcontainer;
  ::std::vector<HcalQIECoder> CALIBcontainer;
  ::std::vector<HcalQIECoder> CASTORcontainer;
};
#ifdef __HcalCondObjectContainer_HcalGainWidth_
#undef __HcalCondObjectContainer_HcalGainWidth_
#endif
class __HcalCondObjectContainer_HcalGainWidth_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalGainWidth_();
  virtual ~__HcalCondObjectContainer_HcalGainWidth_() throw();
  ::std::vector<HcalGainWidth> HBcontainer;
  ::std::vector<HcalGainWidth> HEcontainer;
  ::std::vector<HcalGainWidth> HOcontainer;
  ::std::vector<HcalGainWidth> HFcontainer;
  ::std::vector<HcalGainWidth> HTcontainer;
  ::std::vector<HcalGainWidth> ZDCcontainer;
  ::std::vector<HcalGainWidth> CALIBcontainer;
  ::std::vector<HcalGainWidth> CASTORcontainer;
};
#ifdef __HcalGain
#undef __HcalGain
#endif
class __HcalGain {
  public:
  __HcalGain();
  ::uint32_t mId;
  float mValue0;
  float mValue1;
  float mValue2;
  float mValue3;
};
#ifdef __HcalCondObjectContainer_HcalGain_
#undef __HcalCondObjectContainer_HcalGain_
#endif
class __HcalCondObjectContainer_HcalGain_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalGain_();
  virtual ~__HcalCondObjectContainer_HcalGain_() throw();
  ::std::vector<HcalGain> HBcontainer;
  ::std::vector<HcalGain> HEcontainer;
  ::std::vector<HcalGain> HOcontainer;
  ::std::vector<HcalGain> HFcontainer;
  ::std::vector<HcalGain> HTcontainer;
  ::std::vector<HcalGain> ZDCcontainer;
  ::std::vector<HcalGain> CALIBcontainer;
  ::std::vector<HcalGain> CASTORcontainer;
};
#ifdef __HcalPedestalWidth
#undef __HcalPedestalWidth
#endif
class __HcalPedestalWidth {
  public:
  __HcalPedestalWidth();
  ::uint32_t mId;
  float mSigma00;
  float mSigma01;
  float mSigma02;
  float mSigma03;
  float mSigma10;
  float mSigma11;
  float mSigma12;
  float mSigma13;
  float mSigma20;
  float mSigma21;
  float mSigma22;
  float mSigma23;
  float mSigma30;
  float mSigma31;
  float mSigma32;
  float mSigma33;
};
#ifdef __HcalCondObjectContainer_HcalPedestalWidth_
#undef __HcalCondObjectContainer_HcalPedestalWidth_
#endif
class __HcalCondObjectContainer_HcalPedestalWidth_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalPedestalWidth_();
  virtual ~__HcalCondObjectContainer_HcalPedestalWidth_() throw();
  ::std::vector<HcalPedestalWidth> HBcontainer;
  ::std::vector<HcalPedestalWidth> HEcontainer;
  ::std::vector<HcalPedestalWidth> HOcontainer;
  ::std::vector<HcalPedestalWidth> HFcontainer;
  ::std::vector<HcalPedestalWidth> HTcontainer;
  ::std::vector<HcalPedestalWidth> ZDCcontainer;
  ::std::vector<HcalPedestalWidth> CALIBcontainer;
  ::std::vector<HcalPedestalWidth> CASTORcontainer;
};
#ifdef __HcalPedestal
#undef __HcalPedestal
#endif
class __HcalPedestal {
  public:
  __HcalPedestal();
  ::uint32_t mId;
  float mValue0;
  float mValue1;
  float mValue2;
  float mValue3;
  float mWidth0;
  float mWidth1;
  float mWidth2;
  float mWidth3;
};
#ifdef __HcalCondObjectContainer_HcalPedestal_
#undef __HcalCondObjectContainer_HcalPedestal_
#endif
class __HcalCondObjectContainer_HcalPedestal_ : public ::HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainer_HcalPedestal_();
  virtual ~__HcalCondObjectContainer_HcalPedestal_() throw();
  ::std::vector<HcalPedestal> HBcontainer;
  ::std::vector<HcalPedestal> HEcontainer;
  ::std::vector<HcalPedestal> HOcontainer;
  ::std::vector<HcalPedestal> HFcontainer;
  ::std::vector<HcalPedestal> HTcontainer;
  ::std::vector<HcalPedestal> ZDCcontainer;
  ::std::vector<HcalPedestal> CALIBcontainer;
  ::std::vector<HcalPedestal> CASTORcontainer;
};
#ifdef __HcalDcsMap
#undef __HcalDcsMap
#endif
class __HcalDcsMap {
  public:
  __HcalDcsMap();
  ::std::vector<HcalDcsMap::Item> mItems;
  ::std::vector<const HcalDcsMap::Item*> mItemsById;
  bool sortedById;
  ::std::vector<const HcalDcsMap::Item*> mItemsByDcsId;
  bool sortedByDcsId;
};
#ifdef __HcalPedestalWidths
#undef __HcalPedestalWidths
#endif
class __HcalPedestalWidths : public ::HcalCondObjectContainer<HcalPedestalWidth> {
  public:
  __HcalPedestalWidths();
  virtual ~__HcalPedestalWidths() throw();
  bool unitIsADC;
};
#ifdef __HcalL1TriggerObjects
#undef __HcalL1TriggerObjects
#endif
class __HcalL1TriggerObjects : public ::HcalCondObjectContainer<HcalL1TriggerObject> {
  public:
  __HcalL1TriggerObjects();
  virtual ~__HcalL1TriggerObjects() throw();
  virtual ::std::string myname() const throw();
  char mTag[128];
  char mAlgo[128];
};
#ifdef __HcalRecoParams
#undef __HcalRecoParams
#endif
class __HcalRecoParams : public ::HcalCondObjectContainer<HcalRecoParam> {
  public:
  __HcalRecoParams();
  virtual ~__HcalRecoParams() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalCovarianceMatrix
#undef __HcalCovarianceMatrix
#endif
class __HcalCovarianceMatrix {
  public:
  __HcalCovarianceMatrix();
  ::uint32_t mId;
  float covariancematrix[4][10][10];
};
#ifdef __HcalCholeskyMatrices
#undef __HcalCholeskyMatrices
#endif
class __HcalCholeskyMatrices : public ::HcalCondObjectContainerBase {
  public:
  __HcalCholeskyMatrices();
  ::std::vector<HcalCholeskyMatrix> HBcontainer;
  ::std::vector<HcalCholeskyMatrix> HEcontainer;
  ::std::vector<HcalCholeskyMatrix> HOcontainer;
  ::std::vector<HcalCholeskyMatrix> HFcontainer;
};
#ifdef __HcalCondObjectContainerBase
#undef __HcalCondObjectContainerBase
#endif
class __HcalCondObjectContainerBase {
  public:
  __HcalCondObjectContainerBase();
  int packedIndexVersion_;
  void* topo_;
};
#ifdef __HcalDcsValues
#undef __HcalDcsValues
#endif
class __HcalDcsValues {
  public:
  __HcalDcsValues();
  virtual ~__HcalDcsValues() throw();
  ::std::vector<HcalDcsValue> mHBValues;
  bool mHBsorted;
  ::std::vector<HcalDcsValue> mHEValues;
  bool mHEsorted;
  ::std::vector<HcalDcsValue> mHO0Values;
  bool mHO0sorted;
  ::std::vector<HcalDcsValue> mHO12Values;
  bool mHO12sorted;
  ::std::vector<HcalDcsValue> mHFValues;
  bool mHFsorted;
};
#ifdef __HcalZSThresholds
#undef __HcalZSThresholds
#endif
class __HcalZSThresholds : public ::HcalCondObjectContainer<HcalZSThreshold> {
  public:
  __HcalZSThresholds();
  virtual ~__HcalZSThresholds() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalGains
#undef __HcalGains
#endif
class __HcalGains : public ::HcalCondObjectContainer<HcalGain> {
  public:
  __HcalGains();
  virtual ~__HcalGains() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalChannelQuality
#undef __HcalChannelQuality
#endif
class __HcalChannelQuality : public ::HcalCondObjectContainer<HcalChannelStatus> {
  public:
  __HcalChannelQuality();
  virtual ~__HcalChannelQuality() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalPFCorrs
#undef __HcalPFCorrs
#endif
class __HcalPFCorrs : public ::HcalCondObjectContainer<HcalPFCorr> {
  public:
  __HcalPFCorrs();
  virtual ~__HcalPFCorrs() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalFlagHFDigiTimeParams
#undef __HcalFlagHFDigiTimeParams
#endif
class __HcalFlagHFDigiTimeParams : public ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam> {
  public:
  __HcalFlagHFDigiTimeParams();
  virtual ~__HcalFlagHFDigiTimeParams() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalLUTCorrs
#undef __HcalLUTCorrs
#endif
class __HcalLUTCorrs : public ::HcalCondObjectContainer<HcalLUTCorr> {
  public:
  __HcalLUTCorrs();
  virtual ~__HcalLUTCorrs() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalValidationCorrs
#undef __HcalValidationCorrs
#endif
class __HcalValidationCorrs : public ::HcalCondObjectContainer<HcalValidationCorr> {
  public:
  __HcalValidationCorrs();
  virtual ~__HcalValidationCorrs() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalGainWidths
#undef __HcalGainWidths
#endif
class __HcalGainWidths : public ::HcalCondObjectContainer<HcalGainWidth> {
  public:
  __HcalGainWidths();
  virtual ~__HcalGainWidths() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalCalibrationQIEData
#undef __HcalCalibrationQIEData
#endif
class __HcalCalibrationQIEData : public ::HcalCondObjectContainer<HcalCalibrationQIECoder> {
  public:
  __HcalCalibrationQIEData();
  virtual ~__HcalCalibrationQIEData() throw();
};
#ifdef __HcalPedestals
#undef __HcalPedestals
#endif
class __HcalPedestals : public ::HcalCondObjectContainer<HcalPedestal> {
  public:
  __HcalPedestals();
  virtual ~__HcalPedestals() throw();
  virtual ::std::string myname() const throw();
  bool unitIsADC;
};
#ifdef __HcalTimeCorrs
#undef __HcalTimeCorrs
#endif
class __HcalTimeCorrs : public ::HcalCondObjectContainer<HcalTimeCorr> {
  public:
  __HcalTimeCorrs();
  virtual ~__HcalTimeCorrs() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalDcsValue
#undef __HcalDcsValue
#endif
class __HcalDcsValue {
  public:
  __HcalDcsValue();
  virtual ~__HcalDcsValue() throw();
  ::uint32_t mId;
  int mLS;
  float mValue;
  float mUpperLimit;
  float mLowerLimit;
};
#ifdef __HcalQIEData
#undef __HcalQIEData
#endif
class __HcalQIEData : public ::HcalCondObjectContainer<HcalQIECoder> {
  public:
  __HcalQIEData();
  virtual ~__HcalQIEData() throw();
  virtual ::std::string myname() const throw();
  ::HcalQIEShape mShape[2];
};
#ifdef __HcalCovarianceMatrices
#undef __HcalCovarianceMatrices
#endif
class __HcalCovarianceMatrices : public ::HcalCondObjectContainerBase {
  public:
  __HcalCovarianceMatrices();
  ::std::vector<HcalCovarianceMatrix> HBcontainer;
  ::std::vector<HcalCovarianceMatrix> HEcontainer;
  ::std::vector<HcalCovarianceMatrix> HOcontainer;
  ::std::vector<HcalCovarianceMatrix> HFcontainer;
};
#ifdef __HcalLutMetadata
#undef __HcalLutMetadata
#endif
class __HcalLutMetadata : public ::HcalCondObjectContainer<HcalLutMetadatum> {
  public:
  __HcalLutMetadata();
  virtual ~__HcalLutMetadata() throw();
  virtual ::std::string myname() const throw();
  ::HcalLutMetadata::NonChannelData mNonChannelData;
};
#ifdef __HcalRespCorrs
#undef __HcalRespCorrs
#endif
class __HcalRespCorrs : public ::HcalCondObjectContainer<HcalRespCorr> {
  public:
  __HcalRespCorrs();
  virtual ~__HcalRespCorrs() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __HcalCholeskyMatrix
#undef __HcalCholeskyMatrix
#endif
class __HcalCholeskyMatrix {
  public:
  __HcalCholeskyMatrix();
  short cmatrix[4][55];
  ::uint32_t mId;
};
#ifdef __HcalTimingParams
#undef __HcalTimingParams
#endif
class __HcalTimingParams : public ::HcalCondObjectContainer<HcalTimingParam> {
  public:
  __HcalTimingParams();
  virtual ~__HcalTimingParams() throw();
  virtual ::std::string myname() const throw();
};
#ifdef __std__vector_HcalTimingParam_
#undef __std__vector_HcalTimingParam_
#endif
class __std__vector_HcalTimingParam_ : protected ::std::_Vector_base<HcalTimingParam,std::allocator<HcalTimingParam> > {
  public:
  __std__vector_HcalTimingParam_();
};
#ifdef __std__vector_HcalFlagHFDigiTimeParam_
#undef __std__vector_HcalFlagHFDigiTimeParam_
#endif
class __std__vector_HcalFlagHFDigiTimeParam_ : protected ::std::_Vector_base<HcalFlagHFDigiTimeParam,std::allocator<HcalFlagHFDigiTimeParam> > {
  public:
  __std__vector_HcalFlagHFDigiTimeParam_();
};
#ifdef __std__vector_HcalMCParam_
#undef __std__vector_HcalMCParam_
#endif
class __std__vector_HcalMCParam_ : protected ::std::_Vector_base<HcalMCParam,std::allocator<HcalMCParam> > {
  public:
  __std__vector_HcalMCParam_();
};
#ifdef __std__vector_HcalRecoParam_
#undef __std__vector_HcalRecoParam_
#endif
class __std__vector_HcalRecoParam_ : protected ::std::_Vector_base<HcalRecoParam,std::allocator<HcalRecoParam> > {
  public:
  __std__vector_HcalRecoParam_();
};
#ifdef __std__vector_HcalLongRecoParam_
#undef __std__vector_HcalLongRecoParam_
#endif
class __std__vector_HcalLongRecoParam_ : protected ::std::_Vector_base<HcalLongRecoParam,std::allocator<HcalLongRecoParam> > {
  public:
  __std__vector_HcalLongRecoParam_();
};
#ifdef __HcalDcsMap__Item
#undef __HcalDcsMap__Item
#endif
class __HcalDcsMap__Item {
  public:
  __HcalDcsMap__Item();
  ::uint32_t mId;
  ::uint32_t mDcsId;
};
#ifdef __std__vector_HcalDcsMap__Item_
#undef __std__vector_HcalDcsMap__Item_
#endif
class __std__vector_HcalDcsMap__Item_ : protected ::std::_Vector_base<HcalDcsMap::Item,std::allocator<HcalDcsMap::Item> > {
  public:
  __std__vector_HcalDcsMap__Item_();
};
#ifdef __std__vector_HcalDcsValue_
#undef __std__vector_HcalDcsValue_
#endif
class __std__vector_HcalDcsValue_ : protected ::std::_Vector_base<HcalDcsValue,std::allocator<HcalDcsValue> > {
  public:
  __std__vector_HcalDcsValue_();
};
#ifdef __std__vector_HcalCovarianceMatrix_
#undef __std__vector_HcalCovarianceMatrix_
#endif
class __std__vector_HcalCovarianceMatrix_ : protected ::std::_Vector_base<HcalCovarianceMatrix,std::allocator<HcalCovarianceMatrix> > {
  public:
  __std__vector_HcalCovarianceMatrix_();
};
#ifdef __std__vector_HcalCholeskyMatrix_
#undef __std__vector_HcalCholeskyMatrix_
#endif
class __std__vector_HcalCholeskyMatrix_ : protected ::std::_Vector_base<HcalCholeskyMatrix,std::allocator<HcalCholeskyMatrix> > {
  public:
  __std__vector_HcalCholeskyMatrix_();
};
#ifdef __std__vector_HcalLutMetadatum_
#undef __std__vector_HcalLutMetadatum_
#endif
class __std__vector_HcalLutMetadatum_ : protected ::std::_Vector_base<HcalLutMetadatum,std::allocator<HcalLutMetadatum> > {
  public:
  __std__vector_HcalLutMetadatum_();
};
#ifdef __std__vector_HcalValidationCorr_
#undef __std__vector_HcalValidationCorr_
#endif
class __std__vector_HcalValidationCorr_ : protected ::std::_Vector_base<HcalValidationCorr,std::allocator<HcalValidationCorr> > {
  public:
  __std__vector_HcalValidationCorr_();
};
#ifdef __std__vector_HcalTimeCorr_
#undef __std__vector_HcalTimeCorr_
#endif
class __std__vector_HcalTimeCorr_ : protected ::std::_Vector_base<HcalTimeCorr,std::allocator<HcalTimeCorr> > {
  public:
  __std__vector_HcalTimeCorr_();
};
#ifdef __std__vector_HcalL1TriggerObject_
#undef __std__vector_HcalL1TriggerObject_
#endif
class __std__vector_HcalL1TriggerObject_ : protected ::std::_Vector_base<HcalL1TriggerObject,std::allocator<HcalL1TriggerObject> > {
  public:
  __std__vector_HcalL1TriggerObject_();
};
#ifdef __std__vector_HcalPFCorr_
#undef __std__vector_HcalPFCorr_
#endif
class __std__vector_HcalPFCorr_ : protected ::std::_Vector_base<HcalPFCorr,std::allocator<HcalPFCorr> > {
  public:
  __std__vector_HcalPFCorr_();
};
#ifdef __std__vector_HcalLUTCorr_
#undef __std__vector_HcalLUTCorr_
#endif
class __std__vector_HcalLUTCorr_ : protected ::std::_Vector_base<HcalLUTCorr,std::allocator<HcalLUTCorr> > {
  public:
  __std__vector_HcalLUTCorr_();
};
#ifdef __std__vector_HcalRespCorr_
#undef __std__vector_HcalRespCorr_
#endif
class __std__vector_HcalRespCorr_ : protected ::std::_Vector_base<HcalRespCorr,std::allocator<HcalRespCorr> > {
  public:
  __std__vector_HcalRespCorr_();
};
#ifdef __std__vector_HcalZSThreshold_
#undef __std__vector_HcalZSThreshold_
#endif
class __std__vector_HcalZSThreshold_ : protected ::std::_Vector_base<HcalZSThreshold,std::allocator<HcalZSThreshold> > {
  public:
  __std__vector_HcalZSThreshold_();
};
#ifdef __std__vector_HcalChannelStatus_
#undef __std__vector_HcalChannelStatus_
#endif
class __std__vector_HcalChannelStatus_ : protected ::std::_Vector_base<HcalChannelStatus,std::allocator<HcalChannelStatus> > {
  public:
  __std__vector_HcalChannelStatus_();
};
#ifdef __HcalElectronicsMap__TriggerItem
#undef __HcalElectronicsMap__TriggerItem
#endif
class __HcalElectronicsMap__TriggerItem {
  public:
  __HcalElectronicsMap__TriggerItem();
  ::uint32_t mTrigId;
  ::uint32_t mElId;
};
#ifdef __std__vector_HcalElectronicsMap__TriggerItem_
#undef __std__vector_HcalElectronicsMap__TriggerItem_
#endif
class __std__vector_HcalElectronicsMap__TriggerItem_ : protected ::std::_Vector_base<HcalElectronicsMap::TriggerItem,std::allocator<HcalElectronicsMap::TriggerItem> > {
  public:
  __std__vector_HcalElectronicsMap__TriggerItem_();
};
#ifdef __HcalElectronicsMap__PrecisionItem
#undef __HcalElectronicsMap__PrecisionItem
#endif
class __HcalElectronicsMap__PrecisionItem {
  public:
  __HcalElectronicsMap__PrecisionItem();
  ::uint32_t mId;
  ::uint32_t mElId;
};
#ifdef __std__vector_HcalElectronicsMap__PrecisionItem_
#undef __std__vector_HcalElectronicsMap__PrecisionItem_
#endif
class __std__vector_HcalElectronicsMap__PrecisionItem_ : protected ::std::_Vector_base<HcalElectronicsMap::PrecisionItem,std::allocator<HcalElectronicsMap::PrecisionItem> > {
  public:
  __std__vector_HcalElectronicsMap__PrecisionItem_();
};
#ifdef __std__vector_HcalCalibrationQIECoder_
#undef __std__vector_HcalCalibrationQIECoder_
#endif
class __std__vector_HcalCalibrationQIECoder_ : protected ::std::_Vector_base<HcalCalibrationQIECoder,std::allocator<HcalCalibrationQIECoder> > {
  public:
  __std__vector_HcalCalibrationQIECoder_();
};
#ifdef __std__vector_HcalQIECoder_
#undef __std__vector_HcalQIECoder_
#endif
class __std__vector_HcalQIECoder_ : protected ::std::_Vector_base<HcalQIECoder,std::allocator<HcalQIECoder> > {
  public:
  __std__vector_HcalQIECoder_();
};
#ifdef __std__vector_HcalGainWidth_
#undef __std__vector_HcalGainWidth_
#endif
class __std__vector_HcalGainWidth_ : protected ::std::_Vector_base<HcalGainWidth,std::allocator<HcalGainWidth> > {
  public:
  __std__vector_HcalGainWidth_();
};
#ifdef __std__vector_HcalGain_
#undef __std__vector_HcalGain_
#endif
class __std__vector_HcalGain_ : protected ::std::_Vector_base<HcalGain,std::allocator<HcalGain> > {
  public:
  __std__vector_HcalGain_();
};
#ifdef __std__vector_HcalPedestalWidth_
#undef __std__vector_HcalPedestalWidth_
#endif
class __std__vector_HcalPedestalWidth_ : protected ::std::_Vector_base<HcalPedestalWidth,std::allocator<HcalPedestalWidth> > {
  public:
  __std__vector_HcalPedestalWidth_();
};
#ifdef __std__vector_HcalPedestal_
#undef __std__vector_HcalPedestal_
#endif
class __std__vector_HcalPedestal_ : protected ::std::_Vector_base<HcalPedestal,std::allocator<HcalPedestal> > {
  public:
  __std__vector_HcalPedestal_();
};
#ifdef __HcalLutMetadata__NonChannelData
#undef __HcalLutMetadata__NonChannelData
#endif
class __HcalLutMetadata__NonChannelData {
  public:
  __HcalLutMetadata__NonChannelData();
  float mRctLsb;
  float mNominalGain;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class HcalLongRecoParams -------------------------------
static  void operator_2401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalLongRecoParams*)o)->operator=)(*(const ::HcalLongRecoParams*)arg[0]);
  else   (((::HcalLongRecoParams*)o)->operator=)(*(const ::HcalLongRecoParams*)arg[0]);
}

static void constructor_2402( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLongRecoParams(*(const ::HcalLongRecoParams*)arg[0]);
  else ::new(mem) ::HcalLongRecoParams(*(const ::HcalLongRecoParams*)arg[0]);
}

static void constructor_2403( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLongRecoParams();
  else ::new(mem) ::HcalLongRecoParams();
}

static void constructor_2404( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLongRecoParams((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalLongRecoParams((const ::HcalTopology*)arg[0]);
}

static  void method_2405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalLongRecoParams*)o)->myname)());
  else   (((const ::HcalLongRecoParams*)o)->myname)();
}

static void destructor_2406(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalLongRecoParams*)o)->::HcalLongRecoParams::~HcalLongRecoParams)();
}
static void method_newdel_4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalLongRecoParams >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalLongRecoParams >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalLongRecoParams >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalLongRecoParams >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalLongRecoParams >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalLongRecoParam>")), ::Reflex::BaseOffset< ::HcalLongRecoParams,::HcalCondObjectContainer<HcalLongRecoParam> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalLongRecoParams,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalLongRecoParams -------------------------------
void __HcalLongRecoParams_db_datamem(Reflex::Class*);
void __HcalLongRecoParams_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalLongRecoParams_datamem_bld(&__HcalLongRecoParams_db_datamem);
Reflex::GenreflexMemberBuilder __HcalLongRecoParams_funcmem_bld(&__HcalLongRecoParams_db_funcmem);
void __HcalLongRecoParams_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalLongRecoParams"), typeid(::HcalLongRecoParams), sizeof(::HcalLongRecoParams), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("class_version"), "0")
  .AddBase(type_176, ::Reflex::BaseOffset< ::HcalLongRecoParams, ::HcalCondObjectContainer<HcalLongRecoParam> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9858, type_9859), Reflex::Literal("operator="), operator_2401, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9859), Reflex::Literal("HcalLongRecoParams"), constructor_2402, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalLongRecoParams"), constructor_2403, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalLongRecoParams"), constructor_2404, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalLongRecoParams"), destructor_2406, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalLongRecoParams_funcmem_bld);
}

//------Delayed data member builder for class HcalLongRecoParams -------------------
void __HcalLongRecoParams_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalLongRecoParams -------------------
void __HcalLongRecoParams_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_2405, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalTimeCorr -------------------------------
static void destructor_2450(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalTimeCorr*)o)->::HcalTimeCorr::~HcalTimeCorr)();
}
static  void operator_2451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalTimeCorr*)o)->operator=)(*(const ::HcalTimeCorr*)arg[0]);
  else   (((::HcalTimeCorr*)o)->operator=)(*(const ::HcalTimeCorr*)arg[0]);
}

static void constructor_2452( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimeCorr(*(const ::HcalTimeCorr*)arg[0]);
  else ::new(mem) ::HcalTimeCorr(*(const ::HcalTimeCorr*)arg[0]);
}

static void constructor_2453( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimeCorr();
  else ::new(mem) ::HcalTimeCorr();
}

static void constructor_2454( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimeCorr(*(unsigned long*)arg[0],
      *(float*)arg[1]);
  else ::new(mem) ::HcalTimeCorr(*(unsigned long*)arg[0],
      *(float*)arg[1]);
}

static  void method_2455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalTimeCorr*)o)->rawId)());
  else   (((const ::HcalTimeCorr*)o)->rawId)();
}

static  void method_2456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalTimeCorr*)o)->getValue)());
  else   (((const ::HcalTimeCorr*)o)->getValue)();
}

static void method_newdel_27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalTimeCorr >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalTimeCorr >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalTimeCorr >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalTimeCorr >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalTimeCorr >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalTimeCorr -------------------------------
void __HcalTimeCorr_db_datamem(Reflex::Class*);
void __HcalTimeCorr_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalTimeCorr_datamem_bld(&__HcalTimeCorr_db_datamem);
Reflex::GenreflexMemberBuilder __HcalTimeCorr_funcmem_bld(&__HcalTimeCorr_db_funcmem);
void __HcalTimeCorr_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalTimeCorr"), typeid(::HcalTimeCorr), sizeof(::HcalTimeCorr), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalTimeCorr"), destructor_2450, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6166, type_6168), Reflex::Literal("operator="), operator_2451, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6168), Reflex::Literal("HcalTimeCorr"), constructor_2452, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalTimeCorr"), constructor_2453, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1181), Reflex::Literal("HcalTimeCorr"), constructor_2454, 0, "fid;value", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalTimeCorr_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalTimeCorr_funcmem_bld);
}

//------Delayed data member builder for class HcalTimeCorr -------------------
void __HcalTimeCorr_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalTimeCorr, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue"), OffsetOf(__shadow__::__HcalTimeCorr, mValue), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalTimeCorr -------------------
void __HcalTimeCorr_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_2455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getValue"), method_2456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalValidationCorr -------------------------------
static void destructor_2464(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalValidationCorr*)o)->::HcalValidationCorr::~HcalValidationCorr)();
}
static  void operator_2465( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalValidationCorr*)o)->operator=)(*(const ::HcalValidationCorr*)arg[0]);
  else   (((::HcalValidationCorr*)o)->operator=)(*(const ::HcalValidationCorr*)arg[0]);
}

static void constructor_2466( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalValidationCorr(*(const ::HcalValidationCorr*)arg[0]);
  else ::new(mem) ::HcalValidationCorr(*(const ::HcalValidationCorr*)arg[0]);
}

static void constructor_2467( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalValidationCorr();
  else ::new(mem) ::HcalValidationCorr();
}

static void constructor_2468( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalValidationCorr(*(unsigned long*)arg[0],
      *(float*)arg[1]);
  else ::new(mem) ::HcalValidationCorr(*(unsigned long*)arg[0],
      *(float*)arg[1]);
}

static  void method_2469( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalValidationCorr*)o)->rawId)());
  else   (((const ::HcalValidationCorr*)o)->rawId)();
}

static  void method_2470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalValidationCorr*)o)->getValue)());
  else   (((const ::HcalValidationCorr*)o)->getValue)();
}

static void method_newdel_50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalValidationCorr >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalValidationCorr >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalValidationCorr >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalValidationCorr >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalValidationCorr >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalValidationCorr -------------------------------
void __HcalValidationCorr_db_datamem(Reflex::Class*);
void __HcalValidationCorr_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalValidationCorr_datamem_bld(&__HcalValidationCorr_db_datamem);
Reflex::GenreflexMemberBuilder __HcalValidationCorr_funcmem_bld(&__HcalValidationCorr_db_funcmem);
void __HcalValidationCorr_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalValidationCorr"), typeid(::HcalValidationCorr), sizeof(::HcalValidationCorr), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalValidationCorr"), destructor_2464, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6101, type_6103), Reflex::Literal("operator="), operator_2465, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6103), Reflex::Literal("HcalValidationCorr"), constructor_2466, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalValidationCorr"), constructor_2467, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1181), Reflex::Literal("HcalValidationCorr"), constructor_2468, 0, "fid;value", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalValidationCorr_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalValidationCorr_funcmem_bld);
}

//------Delayed data member builder for class HcalValidationCorr -------------------
void __HcalValidationCorr_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalValidationCorr, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue"), OffsetOf(__shadow__::__HcalValidationCorr, mValue), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalValidationCorr -------------------
void __HcalValidationCorr_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_2469, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getValue"), method_2470, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalTimingParam -------------------------------
static void destructor_2526(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalTimingParam*)o)->::HcalTimingParam::~HcalTimingParam)();
}
static  void operator_2527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalTimingParam*)o)->operator=)(*(const ::HcalTimingParam*)arg[0]);
  else   (((::HcalTimingParam*)o)->operator=)(*(const ::HcalTimingParam*)arg[0]);
}

static void constructor_2528( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimingParam(*(const ::HcalTimingParam*)arg[0]);
  else ::new(mem) ::HcalTimingParam(*(const ::HcalTimingParam*)arg[0]);
}

static void constructor_2529( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimingParam();
  else ::new(mem) ::HcalTimingParam();
}

static void constructor_2530( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimingParam(*(unsigned long*)arg[0],
      *(unsigned int*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3]);
  else ::new(mem) ::HcalTimingParam(*(unsigned long*)arg[0],
      *(unsigned int*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3]);
}

static  void method_2531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalTimingParam*)o)->rawId)());
  else   (((const ::HcalTimingParam*)o)->rawId)();
}

static  void method_2532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalTimingParam*)o)->phase)());
  else   (((const ::HcalTimingParam*)o)->phase)();
}

static  void method_2533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalTimingParam*)o)->rms)());
  else   (((const ::HcalTimingParam*)o)->rms)();
}

static  void method_2534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalTimingParam*)o)->nhits)());
  else   (((const ::HcalTimingParam*)o)->nhits)();
}

static void method_newdel_103( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalTimingParam >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalTimingParam >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalTimingParam >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalTimingParam >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalTimingParam >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalTimingParam -------------------------------
void __HcalTimingParam_db_datamem(Reflex::Class*);
void __HcalTimingParam_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalTimingParam_datamem_bld(&__HcalTimingParam_db_datamem);
Reflex::GenreflexMemberBuilder __HcalTimingParam_funcmem_bld(&__HcalTimingParam_db_funcmem);
void __HcalTimingParam_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalTimingParam"), typeid(::HcalTimingParam), sizeof(::HcalTimingParam), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalTimingParam"), destructor_2526, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5387, type_5389), Reflex::Literal("operator="), operator_2527, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5389), Reflex::Literal("HcalTimingParam"), constructor_2528, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalTimingParam"), constructor_2529, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_43, type_1181, type_1181), Reflex::Literal("HcalTimingParam"), constructor_2530, 0, "fId;nhits;phase;rms", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalTimingParam_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalTimingParam_funcmem_bld);
}

//------Delayed data member builder for class HcalTimingParam -------------------
void __HcalTimingParam_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalTimingParam, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("m_nhits"), OffsetOf(__shadow__::__HcalTimingParam, m_nhits), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("m_phase"), OffsetOf(__shadow__::__HcalTimingParam, m_phase), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("m_rms"), OffsetOf(__shadow__::__HcalTimingParam, m_rms), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalTimingParam -------------------
void __HcalTimingParam_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_2531, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("phase"), method_2532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("rms"), method_2533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("nhits"), method_2534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalMCParams -------------------------------
static  void operator_2541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalMCParams*)o)->operator=)(*(const ::HcalMCParams*)arg[0]);
  else   (((::HcalMCParams*)o)->operator=)(*(const ::HcalMCParams*)arg[0]);
}

static void constructor_2542( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalMCParams(*(const ::HcalMCParams*)arg[0]);
  else ::new(mem) ::HcalMCParams(*(const ::HcalMCParams*)arg[0]);
}

static void constructor_2543( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalMCParams();
  else ::new(mem) ::HcalMCParams();
}

static void constructor_2544( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalMCParams((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalMCParams((const ::HcalTopology*)arg[0]);
}

static  void method_2545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalMCParams*)o)->myname)());
  else   (((const ::HcalMCParams*)o)->myname)();
}

static void destructor_2546(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalMCParams*)o)->::HcalMCParams::~HcalMCParams)();
}
static void method_newdel_110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalMCParams >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalMCParams >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalMCParams >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalMCParams >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalMCParams >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalMCParam>")), ::Reflex::BaseOffset< ::HcalMCParams,::HcalCondObjectContainer<HcalMCParam> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalMCParams,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalMCParams -------------------------------
void __HcalMCParams_db_datamem(Reflex::Class*);
void __HcalMCParams_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalMCParams_datamem_bld(&__HcalMCParams_db_datamem);
Reflex::GenreflexMemberBuilder __HcalMCParams_funcmem_bld(&__HcalMCParams_db_funcmem);
void __HcalMCParams_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalMCParams"), typeid(::HcalMCParams), sizeof(::HcalMCParams), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("class_version"), "0")
  .AddBase(type_175, ::Reflex::BaseOffset< ::HcalMCParams, ::HcalCondObjectContainer<HcalMCParam> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9873, type_9874), Reflex::Literal("operator="), operator_2541, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9874), Reflex::Literal("HcalMCParams"), constructor_2542, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalMCParams"), constructor_2543, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalMCParams"), constructor_2544, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalMCParams"), destructor_2546, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalMCParams_funcmem_bld);
}

//------Delayed data member builder for class HcalMCParams -------------------
void __HcalMCParams_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalMCParams -------------------
void __HcalMCParams_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_2545, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalGainWidth -------------------------------
static void destructor_2556(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalGainWidth*)o)->::HcalGainWidth::~HcalGainWidth)();
}
static  void operator_2557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalGainWidth*)o)->operator=)(*(const ::HcalGainWidth*)arg[0]);
  else   (((::HcalGainWidth*)o)->operator=)(*(const ::HcalGainWidth*)arg[0]);
}

static void constructor_2558( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGainWidth(*(const ::HcalGainWidth*)arg[0]);
  else ::new(mem) ::HcalGainWidth(*(const ::HcalGainWidth*)arg[0]);
}

static  void method_2559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalGainWidth*)o)->getValues)());
  else   (((const ::HcalGainWidth*)o)->getValues)();
}

static  void method_2560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalGainWidth*)o)->getValue)(*(int*)arg[0]));
  else   (((const ::HcalGainWidth*)o)->getValue)(*(int*)arg[0]);
}

static void constructor_2561( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGainWidth();
  else ::new(mem) ::HcalGainWidth();
}

static void constructor_2562( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGainWidth(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
  else ::new(mem) ::HcalGainWidth(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
}

static  void method_2563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalGainWidth*)o)->rawId)());
  else   (((const ::HcalGainWidth*)o)->rawId)();
}

static void method_newdel_139( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalGainWidth >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalGainWidth >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalGainWidth >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalGainWidth >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalGainWidth >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalGainWidth -------------------------------
void __HcalGainWidth_db_datamem(Reflex::Class*);
void __HcalGainWidth_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalGainWidth_datamem_bld(&__HcalGainWidth_db_datamem);
Reflex::GenreflexMemberBuilder __HcalGainWidth_funcmem_bld(&__HcalGainWidth_db_funcmem);
void __HcalGainWidth_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalGainWidth"), typeid(::HcalGainWidth), sizeof(::HcalGainWidth), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalGainWidth"), destructor_2556, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6881, type_6883), Reflex::Literal("operator="), operator_2557, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6883), Reflex::Literal("HcalGainWidth"), constructor_2558, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalGainWidth"), constructor_2561, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1181, type_1181, type_1181, type_1181), Reflex::Literal("HcalGainWidth"), constructor_2562, 0, "fId;fCap0;fCap1;fCap2;fCap3", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_139, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalGainWidth_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalGainWidth_funcmem_bld);
}

//------Delayed data member builder for class HcalGainWidth -------------------
void __HcalGainWidth_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalGainWidth, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue0"), OffsetOf(__shadow__::__HcalGainWidth, mValue0), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue1"), OffsetOf(__shadow__::__HcalGainWidth, mValue1), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue2"), OffsetOf(__shadow__::__HcalGainWidth, mValue2), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue3"), OffsetOf(__shadow__::__HcalGainWidth, mValue3), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalGainWidth -------------------
void __HcalGainWidth_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7462), Reflex::Literal("getValues"), method_2559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_101), Reflex::Literal("getValue"), method_2560, 0, "fCapId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_2563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalElectronicsMap -------------------------------
static  void operator_2578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalElectronicsMap*)o)->operator=)(*(const ::HcalElectronicsMap*)arg[0]);
  else   (((::HcalElectronicsMap*)o)->operator=)(*(const ::HcalElectronicsMap*)arg[0]);
}

static void constructor_2579( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsMap(*(const ::HcalElectronicsMap*)arg[0]);
  else ::new(mem) ::HcalElectronicsMap(*(const ::HcalElectronicsMap*)arg[0]);
}

static void constructor_2580( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsMap();
  else ::new(mem) ::HcalElectronicsMap();
}

static void destructor_2581(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalElectronicsMap*)o)->::HcalElectronicsMap::~HcalElectronicsMap)();
}
static  void method_2582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (DetId)((((const ::HcalElectronicsMap*)o)->lookup)(*(::HcalElectronicsId*)arg[0]));
  else   (((const ::HcalElectronicsMap*)o)->lookup)(*(::HcalElectronicsId*)arg[0]);
}

static  void method_2583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HcalElectronicsId)((((const ::HcalElectronicsMap*)o)->lookup)(*(::DetId*)arg[0]));
  else   (((const ::HcalElectronicsMap*)o)->lookup)(*(::DetId*)arg[0]);
}

static  void method_2584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (DetId)((((const ::HcalElectronicsMap*)o)->lookupTrigger)(*(::HcalElectronicsId*)arg[0]));
  else   (((const ::HcalElectronicsMap*)o)->lookupTrigger)(*(::HcalElectronicsId*)arg[0]);
}

static  void method_2585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HcalElectronicsId)((((const ::HcalElectronicsMap*)o)->lookupTrigger)(*(::DetId*)arg[0]));
  else   (((const ::HcalElectronicsMap*)o)->lookupTrigger)(*(::DetId*)arg[0]);
}

static  void method_2586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalElectronicsMap*)o)->lookup)(*(const ::HcalElectronicsId*)arg[0],
    *(::HcalElectronicsId*)arg[1],
    *(::HcalGenericDetId*)arg[2]));
  else   (((const ::HcalElectronicsMap*)o)->lookup)(*(const ::HcalElectronicsId*)arg[0],
    *(::HcalElectronicsId*)arg[1],
    *(::HcalGenericDetId*)arg[2]);
}

static  void method_2587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalElectronicsMap*)o)->lookup)(*(const ::HcalElectronicsId*)arg[0],
    *(::HcalElectronicsId*)arg[1],
    *(::HcalTrigTowerDetId*)arg[2]));
  else   (((const ::HcalElectronicsMap*)o)->lookup)(*(const ::HcalElectronicsId*)arg[0],
    *(::HcalElectronicsId*)arg[1],
    *(::HcalTrigTowerDetId*)arg[2]);
}

static  void method_2588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<HcalElectronicsId>)((((const ::HcalElectronicsMap*)o)->allElectronicsId)());
  else   (((const ::HcalElectronicsMap*)o)->allElectronicsId)();
}

static  void method_2589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<HcalElectronicsId>)((((const ::HcalElectronicsMap*)o)->allElectronicsIdPrecision)());
  else   (((const ::HcalElectronicsMap*)o)->allElectronicsIdPrecision)();
}

static  void method_2590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<HcalElectronicsId>)((((const ::HcalElectronicsMap*)o)->allElectronicsIdTrigger)());
  else   (((const ::HcalElectronicsMap*)o)->allElectronicsIdTrigger)();
}

static  void method_2591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<HcalGenericDetId>)((((const ::HcalElectronicsMap*)o)->allPrecisionId)());
  else   (((const ::HcalElectronicsMap*)o)->allPrecisionId)();
}

static  void method_2592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<HcalTrigTowerDetId>)((((const ::HcalElectronicsMap*)o)->allTriggerId)());
  else   (((const ::HcalElectronicsMap*)o)->allTriggerId)();
}

static  void method_2593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalElectronicsMap*)o)->mapEId2tId)(*(::HcalElectronicsId*)arg[0],
    *(::HcalTrigTowerDetId*)arg[1]));
  else   (((::HcalElectronicsMap*)o)->mapEId2tId)(*(::HcalElectronicsId*)arg[0],
    *(::HcalTrigTowerDetId*)arg[1]);
}

static  void method_2594( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalElectronicsMap*)o)->mapEId2chId)(*(::HcalElectronicsId*)arg[0],
    *(::DetId*)arg[1]));
  else   (((::HcalElectronicsMap*)o)->mapEId2chId)(*(::HcalElectronicsId*)arg[0],
    *(::DetId*)arg[1]);
}

static  void method_2595( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::HcalElectronicsMap*)o)->sortById)();
}

static  void method_2596( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::HcalElectronicsMap*)o)->sortByTriggerId)();
}

static  void method_2597( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HcalElectronicsMap*)o)->sort)();
}

static void method_newdel_159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalElectronicsMap -------------------------------
void __HcalElectronicsMap_db_datamem(Reflex::Class*);
void __HcalElectronicsMap_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalElectronicsMap_datamem_bld(&__HcalElectronicsMap_db_datamem);
Reflex::GenreflexMemberBuilder __HcalElectronicsMap_funcmem_bld(&__HcalElectronicsMap_db_funcmem);
void __HcalElectronicsMap_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalElectronicsMap"), typeid(::HcalElectronicsMap), sizeof(::HcalElectronicsMap), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9892, type_9893), Reflex::Literal("operator="), operator_2578, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9893), Reflex::Literal("HcalElectronicsMap"), constructor_2579, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalElectronicsMap"), constructor_2580, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalElectronicsMap"), destructor_2581, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalElectronicsMap_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalElectronicsMap_funcmem_bld);
}

//------Delayed data member builder for class HcalElectronicsMap -------------------
void __HcalElectronicsMap_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1869, Reflex::Literal("mPItems"), OffsetOf(__shadow__::__HcalElectronicsMap, mPItems), ::Reflex::PROTECTED)
  .AddDataMember(type_1868, Reflex::Literal("mTItems"), OffsetOf(__shadow__::__HcalElectronicsMap, mTItems), ::Reflex::PROTECTED)
  .AddDataMember(type_1896, Reflex::Literal("mPItemsById"), OffsetOf(__shadow__::__HcalElectronicsMap, mPItemsById), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2461, Reflex::Literal("sortedByPId"), OffsetOf(__shadow__::__HcalElectronicsMap, sortedByPId), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1895, Reflex::Literal("mTItemsByTrigId"), OffsetOf(__shadow__::__HcalElectronicsMap, mTItemsByTrigId), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2461, Reflex::Literal("sortedByTId"), OffsetOf(__shadow__::__HcalElectronicsMap, sortedByTId), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class HcalElectronicsMap -------------------
void __HcalElectronicsMap_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1488c, type_853), Reflex::Literal("lookup"), method_2582, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_853c, type_1488), Reflex::Literal("lookup"), method_2583, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1488c, type_853), Reflex::Literal("lookupTrigger"), method_2584, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_853c, type_1488), Reflex::Literal("lookupTrigger"), method_2585, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_853c, type_9896, type_9897), Reflex::Literal("lookup"), method_2586, 0, "pId;eid;did", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_853c, type_9896, type_9898), Reflex::Literal("lookup"), method_2587, 0, "pId;eid;did", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1898), Reflex::Literal("allElectronicsId"), method_2588, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1898), Reflex::Literal("allElectronicsIdPrecision"), method_2589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1898), Reflex::Literal("allElectronicsIdTrigger"), method_2590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1884), Reflex::Literal("allPrecisionId"), method_2591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1897), Reflex::Literal("allTriggerId"), method_2592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_853, type_328), Reflex::Literal("mapEId2tId"), method_2593, 0, "fElectronicsId;fTriggerId", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_853, type_1488), Reflex::Literal("mapEId2chId"), method_2594, 0, "fElectronicsId;fId", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("sortById"), method_2595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("sortByTriggerId"), method_2596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("sort"), method_2597, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class HcalQIECoder -------------------------------
static void destructor_2645(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalQIECoder*)o)->::HcalQIECoder::~HcalQIECoder)();
}
static  void operator_2646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalQIECoder*)o)->operator=)(*(const ::HcalQIECoder*)arg[0]);
  else   (((::HcalQIECoder*)o)->operator=)(*(const ::HcalQIECoder*)arg[0]);
}

static void constructor_2647( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalQIECoder(*(const ::HcalQIECoder*)arg[0]);
  else ::new(mem) ::HcalQIECoder(*(const ::HcalQIECoder*)arg[0]);
}

static void constructor_2648( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalQIECoder();
  else ::new(mem) ::HcalQIECoder();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalQIECoder(*(unsigned long*)arg[0]);
  else ::new(mem) ::HcalQIECoder(*(unsigned long*)arg[0]);
  }
}

static  void method_2649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalQIECoder*)o)->charge)(*(const ::HcalQIEShape*)arg[0],
    *(unsigned int*)arg[1],
    *(unsigned int*)arg[2]));
  else   (((const ::HcalQIECoder*)o)->charge)(*(const ::HcalQIEShape*)arg[0],
    *(unsigned int*)arg[1],
    *(unsigned int*)arg[2]);
}

static  void method_2650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalQIECoder*)o)->adc)(*(const ::HcalQIEShape*)arg[0],
    *(float*)arg[1],
    *(unsigned int*)arg[2]));
  else   (((const ::HcalQIECoder*)o)->adc)(*(const ::HcalQIEShape*)arg[0],
    *(float*)arg[1],
    *(unsigned int*)arg[2]);
}

static  void method_2651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalQIECoder*)o)->offset)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1]));
  else   (((const ::HcalQIECoder*)o)->offset)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1]);
}

static  void method_2652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalQIECoder*)o)->slope)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1]));
  else   (((const ::HcalQIECoder*)o)->slope)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1]);
}

static  void method_2653( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalQIECoder*)o)->setOffset)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1],
    *(float*)arg[2]);
}

static  void method_2654( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalQIECoder*)o)->setSlope)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1],
    *(float*)arg[2]);
}

static  void method_2655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalQIECoder*)o)->rawId)());
  else   (((const ::HcalQIECoder*)o)->rawId)();
}

static  void method_2656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalQIECoder*)o)->qieIndex)());
  else   (((const ::HcalQIECoder*)o)->qieIndex)();
}

static  void method_2657( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalQIECoder*)o)->setQIEIndex)(*(::uint32_t*)arg[0]);
}

static void constructor_x9( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalQIECoder();
  else ::new(mem) ::HcalQIECoder();
}

static void method_newdel_172( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalQIECoder >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalQIECoder >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalQIECoder >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalQIECoder >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalQIECoder >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalQIECoder -------------------------------
void __HcalQIECoder_db_datamem(Reflex::Class*);
void __HcalQIECoder_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalQIECoder_datamem_bld(&__HcalQIECoder_db_datamem);
Reflex::GenreflexMemberBuilder __HcalQIECoder_funcmem_bld(&__HcalQIECoder_db_funcmem);
void __HcalQIECoder_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalQIECoder"), typeid(::HcalQIECoder), sizeof(::HcalQIECoder), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalQIECoder"), destructor_2645, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6816, type_6818), Reflex::Literal("operator="), operator_2646, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6818), Reflex::Literal("HcalQIECoder"), constructor_2647, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18), Reflex::Literal("HcalQIECoder"), constructor_2648, 0, "fId=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalQIECoder"), constructor_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_172, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalQIECoder_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalQIECoder_funcmem_bld);
}

//------Delayed data member builder for class HcalQIECoder -------------------
void __HcalQIECoder_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalQIECoder, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset00"), OffsetOf(__shadow__::__HcalQIECoder, mOffset00), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset01"), OffsetOf(__shadow__::__HcalQIECoder, mOffset01), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset02"), OffsetOf(__shadow__::__HcalQIECoder, mOffset02), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset03"), OffsetOf(__shadow__::__HcalQIECoder, mOffset03), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset10"), OffsetOf(__shadow__::__HcalQIECoder, mOffset10), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset11"), OffsetOf(__shadow__::__HcalQIECoder, mOffset11), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset12"), OffsetOf(__shadow__::__HcalQIECoder, mOffset12), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset13"), OffsetOf(__shadow__::__HcalQIECoder, mOffset13), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset20"), OffsetOf(__shadow__::__HcalQIECoder, mOffset20), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset21"), OffsetOf(__shadow__::__HcalQIECoder, mOffset21), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset22"), OffsetOf(__shadow__::__HcalQIECoder, mOffset22), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset23"), OffsetOf(__shadow__::__HcalQIECoder, mOffset23), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset30"), OffsetOf(__shadow__::__HcalQIECoder, mOffset30), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset31"), OffsetOf(__shadow__::__HcalQIECoder, mOffset31), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset32"), OffsetOf(__shadow__::__HcalQIECoder, mOffset32), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mOffset33"), OffsetOf(__shadow__::__HcalQIECoder, mOffset33), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope00"), OffsetOf(__shadow__::__HcalQIECoder, mSlope00), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope01"), OffsetOf(__shadow__::__HcalQIECoder, mSlope01), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope02"), OffsetOf(__shadow__::__HcalQIECoder, mSlope02), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope03"), OffsetOf(__shadow__::__HcalQIECoder, mSlope03), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope10"), OffsetOf(__shadow__::__HcalQIECoder, mSlope10), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope11"), OffsetOf(__shadow__::__HcalQIECoder, mSlope11), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope12"), OffsetOf(__shadow__::__HcalQIECoder, mSlope12), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope13"), OffsetOf(__shadow__::__HcalQIECoder, mSlope13), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope20"), OffsetOf(__shadow__::__HcalQIECoder, mSlope20), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope21"), OffsetOf(__shadow__::__HcalQIECoder, mSlope21), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope22"), OffsetOf(__shadow__::__HcalQIECoder, mSlope22), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope23"), OffsetOf(__shadow__::__HcalQIECoder, mSlope23), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope30"), OffsetOf(__shadow__::__HcalQIECoder, mSlope30), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope31"), OffsetOf(__shadow__::__HcalQIECoder, mSlope31), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope32"), OffsetOf(__shadow__::__HcalQIECoder, mSlope32), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSlope33"), OffsetOf(__shadow__::__HcalQIECoder, mSlope33), ::Reflex::PRIVATE)
  .AddDataMember(type_43, Reflex::Literal("mQIEIndex"), OffsetOf(__shadow__::__HcalQIECoder, mQIEIndex), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class HcalQIECoder -------------------
void __HcalQIECoder_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_9952, type_43, type_43), Reflex::Literal("charge"), method_2649, 0, "fShape;fAdc;fCapId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43, type_9952, type_1181, type_43), Reflex::Literal("adc"), method_2650, 0, "fShape;fCharge;fCapId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_43, type_43), Reflex::Literal("offset"), method_2651, 0, "fCapId;fRange", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_43, type_43), Reflex::Literal("slope"), method_2652, 0, "fCapId;fRange", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_43, type_43, type_1181), Reflex::Literal("setOffset"), method_2653, 0, "fCapId;fRange;fValue", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_43, type_43, type_1181), Reflex::Literal("setSlope"), method_2654, 0, "fCapId;fRange;fValue", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_2655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("qieIndex"), method_2656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_370), Reflex::Literal("setQIEIndex"), method_2657, 0, "v", ::Reflex::PUBLIC);
}
//------Stub functions for class HcalCondObjectContainer<HcalTimingParam> -------------------------------
static  void operator_2668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalTimingParam>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalTimingParam>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalTimingParam>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalTimingParam>*)arg[0]);
}

static void constructor_2669( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalTimingParam>(*(const ::HcalCondObjectContainer<HcalTimingParam>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalTimingParam>(*(const ::HcalCondObjectContainer<HcalTimingParam>*)arg[0]);
}

static void constructor_2670( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalTimingParam>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalTimingParam>((const ::HcalTopology*)arg[0]);
}

static void destructor_2671(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalTimingParam>*)o)->::HcalCondObjectContainer<HcalTimingParam>::~HcalCondObjectContainer)();
}
static  void method_2672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2674( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalTimingParam>*)o)->addValues)(*(const ::HcalTimingParam*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalTimingParam>*)o)->addValues)(*(const ::HcalTimingParam*)arg[0]);
}

static  void method_2675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->getAllChannels)();
}

static  void method_2676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->myname)();
}

static  void method_2677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalTimingParam> > >)((((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalTimingParam>*)o)->getAllContainers)();
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalTimingParam>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalTimingParam> -------------------------------
void __HcalCondObjectContainer_HcalTimingParam__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalTimingParam__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalTimingParam__datamem_bld(&__HcalCondObjectContainer_HcalTimingParam__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalTimingParam__funcmem_bld(&__HcalCondObjectContainer_HcalTimingParam__db_funcmem);
void __HcalCondObjectContainer_HcalTimingParam__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalTimingParam>"), typeid(::HcalCondObjectContainer<HcalTimingParam>), sizeof(::HcalCondObjectContainer<HcalTimingParam>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalTimingParam>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2086, Reflex::Literal("HcalCondObjectContainer<HcalTimingParam>::tHcalCont"))
  .AddTypedef(type_1876, Reflex::Literal("HcalCondObjectContainer<HcalTimingParam>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9953, type_9954), Reflex::Literal("operator="), operator_2668, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9954), Reflex::Literal("HcalCondObjectContainer"), constructor_2669, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2670, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2671, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalTimingParam__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalTimingParam__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalTimingParam> -------------------
void __HcalCondObjectContainer_HcalTimingParam__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1849, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimingParam_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1849, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimingParam_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1849, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimingParam_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1849, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimingParam_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1849, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimingParam_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1849, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimingParam_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1849, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimingParam_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1849, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimingParam_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalTimingParam> -------------------
void __HcalCondObjectContainer_HcalTimingParam__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5385, type_1488, type_2461), Reflex::Literal("getValues"), method_2672, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2673, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_5389), Reflex::Literal("addValues"), method_2674, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2676, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1876c), Reflex::Literal("getAllContainers"), method_2677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalFlagHFDigiTimeParam -------------------------------
static void destructor_4000(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalFlagHFDigiTimeParam*)o)->::HcalFlagHFDigiTimeParam::~HcalFlagHFDigiTimeParam)();
}
static  void operator_4001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalFlagHFDigiTimeParam*)o)->operator=)(*(const ::HcalFlagHFDigiTimeParam*)arg[0]);
  else   (((::HcalFlagHFDigiTimeParam*)o)->operator=)(*(const ::HcalFlagHFDigiTimeParam*)arg[0]);
}

static void constructor_4002( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalFlagHFDigiTimeParam(*(const ::HcalFlagHFDigiTimeParam*)arg[0]);
  else ::new(mem) ::HcalFlagHFDigiTimeParam(*(const ::HcalFlagHFDigiTimeParam*)arg[0]);
}

static void constructor_4003( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalFlagHFDigiTimeParam();
  else ::new(mem) ::HcalFlagHFDigiTimeParam();
}

static void constructor_4004( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalFlagHFDigiTimeParam(*(unsigned long*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2],
      *(unsigned int*)arg[3],
      *(double*)arg[4],
      *(::std::vector<double>*)arg[5]);
  else ::new(mem) ::HcalFlagHFDigiTimeParam(*(unsigned long*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2],
      *(unsigned int*)arg[3],
      *(double*)arg[4],
      *(::std::vector<double>*)arg[5]);
}

static  void method_4005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalFlagHFDigiTimeParam*)o)->rawId)());
  else   (((const ::HcalFlagHFDigiTimeParam*)o)->rawId)();
}

static  void method_4006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalFlagHFDigiTimeParam*)o)->HFdigiflagFirstSample)());
  else   (((const ::HcalFlagHFDigiTimeParam*)o)->HFdigiflagFirstSample)();
}

static  void method_4007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalFlagHFDigiTimeParam*)o)->HFdigiflagSamplesToAdd)());
  else   (((const ::HcalFlagHFDigiTimeParam*)o)->HFdigiflagSamplesToAdd)();
}

static  void method_4008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalFlagHFDigiTimeParam*)o)->HFdigiflagExpectedPeak)());
  else   (((const ::HcalFlagHFDigiTimeParam*)o)->HFdigiflagExpectedPeak)();
}

static  void method_4009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HcalFlagHFDigiTimeParam*)o)->HFdigiflagMinEThreshold)());
  else   (((const ::HcalFlagHFDigiTimeParam*)o)->HFdigiflagMinEThreshold)();
}

static  void method_4010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<double>)((((const ::HcalFlagHFDigiTimeParam*)o)->HFdigiflagCoefficients)());
  else   (((const ::HcalFlagHFDigiTimeParam*)o)->HFdigiflagCoefficients)();
}

static void method_newdel_1145( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalFlagHFDigiTimeParam >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalFlagHFDigiTimeParam >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalFlagHFDigiTimeParam >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalFlagHFDigiTimeParam >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalFlagHFDigiTimeParam >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalFlagHFDigiTimeParam -------------------------------
void __HcalFlagHFDigiTimeParam_db_datamem(Reflex::Class*);
void __HcalFlagHFDigiTimeParam_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalFlagHFDigiTimeParam_datamem_bld(&__HcalFlagHFDigiTimeParam_db_datamem);
Reflex::GenreflexMemberBuilder __HcalFlagHFDigiTimeParam_funcmem_bld(&__HcalFlagHFDigiTimeParam_db_funcmem);
void __HcalFlagHFDigiTimeParam_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalFlagHFDigiTimeParam"), typeid(::HcalFlagHFDigiTimeParam), sizeof(::HcalFlagHFDigiTimeParam), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalFlagHFDigiTimeParam"), destructor_4000, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5452, type_5454), Reflex::Literal("operator="), operator_4001, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5454), Reflex::Literal("HcalFlagHFDigiTimeParam"), constructor_4002, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalFlagHFDigiTimeParam"), constructor_4003, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_43, type_43, type_43, type_865, type_1879), Reflex::Literal("HcalFlagHFDigiTimeParam"), constructor_4004, 0, "fId;fFirstSample;fSamplesToAdd;fExpectedPeak;fminEThreshold;fcoef", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1145, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalFlagHFDigiTimeParam_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalFlagHFDigiTimeParam_funcmem_bld);
}

//------Delayed data member builder for class HcalFlagHFDigiTimeParam -------------------
void __HcalFlagHFDigiTimeParam_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalFlagHFDigiTimeParam, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("mHFdigiflagFirstSample"), OffsetOf(__shadow__::__HcalFlagHFDigiTimeParam, mHFdigiflagFirstSample), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("mHFdigiflagSamplesToAdd"), OffsetOf(__shadow__::__HcalFlagHFDigiTimeParam, mHFdigiflagSamplesToAdd), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("mHFdigiflagExpectedPeak"), OffsetOf(__shadow__::__HcalFlagHFDigiTimeParam, mHFdigiflagExpectedPeak), ::Reflex::PRIVATE)
  .AddDataMember(type_865, Reflex::Literal("mHFdigiflagMinEthreshold"), OffsetOf(__shadow__::__HcalFlagHFDigiTimeParam, mHFdigiflagMinEthreshold), ::Reflex::PRIVATE)
  .AddDataMember(type_1879, Reflex::Literal("mHFdigiflagCoefficients"), OffsetOf(__shadow__::__HcalFlagHFDigiTimeParam, mHFdigiflagCoefficients), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalFlagHFDigiTimeParam -------------------
void __HcalFlagHFDigiTimeParam_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_4005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("HFdigiflagFirstSample"), method_4006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("HFdigiflagSamplesToAdd"), method_4007, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("HFdigiflagExpectedPeak"), method_4008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_865), Reflex::Literal("HFdigiflagMinEThreshold"), method_4009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1879), Reflex::Literal("HFdigiflagCoefficients"), method_4010, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalFlagHFDigiTimeParam> -------------------------------
static  void operator_2689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)arg[0]);
}

static void constructor_2690( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>(*(const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>(*(const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)arg[0]);
}

static void constructor_2691( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>((const ::HcalTopology*)arg[0]);
}

static void destructor_2692(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>::~HcalCondObjectContainer)();
}
static  void method_2693( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2694( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->addValues)(*(const ::HcalFlagHFDigiTimeParam*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->addValues)(*(const ::HcalFlagHFDigiTimeParam*)arg[0]);
}

static  void method_2696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->getAllChannels)();
}

static  void method_2697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->myname)();
}

static  void method_2698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalFlagHFDigiTimeParam> > >)((((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>*)o)->getAllContainers)();
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalFlagHFDigiTimeParam> -------------------------------
void __HcalCondObjectContainer_HcalFlagHFDigiTimeParam__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalFlagHFDigiTimeParam__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalFlagHFDigiTimeParam__datamem_bld(&__HcalCondObjectContainer_HcalFlagHFDigiTimeParam__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalFlagHFDigiTimeParam__funcmem_bld(&__HcalCondObjectContainer_HcalFlagHFDigiTimeParam__db_funcmem);
void __HcalCondObjectContainer_HcalFlagHFDigiTimeParam__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalFlagHFDigiTimeParam>"), typeid(::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>), sizeof(::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2087, Reflex::Literal("HcalCondObjectContainer<HcalFlagHFDigiTimeParam>::tHcalCont"))
  .AddTypedef(type_1878, Reflex::Literal("HcalCondObjectContainer<HcalFlagHFDigiTimeParam>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9957, type_9958), Reflex::Literal("operator="), operator_2689, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9958), Reflex::Literal("HcalCondObjectContainer"), constructor_2690, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2691, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2692, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalFlagHFDigiTimeParam__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalFlagHFDigiTimeParam__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalFlagHFDigiTimeParam> -------------------
void __HcalCondObjectContainer_HcalFlagHFDigiTimeParam__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1850, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalFlagHFDigiTimeParam_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1850, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalFlagHFDigiTimeParam_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1850, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalFlagHFDigiTimeParam_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1850, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalFlagHFDigiTimeParam_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1850, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalFlagHFDigiTimeParam_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1850, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalFlagHFDigiTimeParam_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1850, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalFlagHFDigiTimeParam_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1850, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalFlagHFDigiTimeParam_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalFlagHFDigiTimeParam> -------------------
void __HcalCondObjectContainer_HcalFlagHFDigiTimeParam__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5450, type_1488, type_2461), Reflex::Literal("getValues"), method_2693, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2694, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_5454), Reflex::Literal("addValues"), method_2695, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2696, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2697, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1878c), Reflex::Literal("getAllContainers"), method_2698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalMCParam -------------------------------
static void destructor_3973(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalMCParam*)o)->::HcalMCParam::~HcalMCParam)();
}
static  void operator_3974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalMCParam*)o)->operator=)(*(const ::HcalMCParam*)arg[0]);
  else   (((::HcalMCParam*)o)->operator=)(*(const ::HcalMCParam*)arg[0]);
}

static void constructor_3975( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalMCParam(*(const ::HcalMCParam*)arg[0]);
  else ::new(mem) ::HcalMCParam(*(const ::HcalMCParam*)arg[0]);
}

static void constructor_3976( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalMCParam();
  else ::new(mem) ::HcalMCParam();
}

static void constructor_3977( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalMCParam(*(unsigned long*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::HcalMCParam(*(unsigned long*)arg[0],
      *(unsigned int*)arg[1]);
}

static  void method_3978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalMCParam*)o)->rawId)());
  else   (((const ::HcalMCParam*)o)->rawId)();
}

static  void method_3979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalMCParam*)o)->param1)());
  else   (((const ::HcalMCParam*)o)->param1)();
}

static  void method_3980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalMCParam*)o)->signalShape)());
  else   (((const ::HcalMCParam*)o)->signalShape)();
}

static  void method_3981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalMCParam*)o)->syncPhase)());
  else   (((const ::HcalMCParam*)o)->syncPhase)();
}

static  void method_3982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalMCParam*)o)->binOfMaximum)());
  else   (((const ::HcalMCParam*)o)->binOfMaximum)();
}

static  void method_3983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalMCParam*)o)->timePhase)());
  else   (((const ::HcalMCParam*)o)->timePhase)();
}

static  void method_3984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalMCParam*)o)->timeSmearing)());
  else   (((const ::HcalMCParam*)o)->timeSmearing)();
}

static  void method_3985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalMCParam*)o)->packingScheme)());
  else   (((const ::HcalMCParam*)o)->packingScheme)();
}

static void method_newdel_1074( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalMCParam >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalMCParam >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalMCParam >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalMCParam >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalMCParam >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalMCParam -------------------------------
void __HcalMCParam_db_datamem(Reflex::Class*);
void __HcalMCParam_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalMCParam_datamem_bld(&__HcalMCParam_db_datamem);
Reflex::GenreflexMemberBuilder __HcalMCParam_funcmem_bld(&__HcalMCParam_db_funcmem);
void __HcalMCParam_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalMCParam"), typeid(::HcalMCParam), sizeof(::HcalMCParam), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalMCParam"), destructor_3973, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5517, type_5519), Reflex::Literal("operator="), operator_3974, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5519), Reflex::Literal("HcalMCParam"), constructor_3975, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalMCParam"), constructor_3976, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_43), Reflex::Literal("HcalMCParam"), constructor_3977, 0, "fId;fParam1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1074, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalMCParam_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalMCParam_funcmem_bld);
}

//------Delayed data member builder for class HcalMCParam -------------------
void __HcalMCParam_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalMCParam, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("mParam1"), OffsetOf(__shadow__::__HcalMCParam, mParam1), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalMCParam -------------------
void __HcalMCParam_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_3978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("param1"), method_3979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("signalShape"), method_3980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("syncPhase"), method_3981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("binOfMaximum"), method_3982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("timePhase"), method_3983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("timeSmearing"), method_3984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("packingScheme"), method_3985, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalMCParam> -------------------------------
static  void operator_2710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalMCParam>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalMCParam>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalMCParam>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalMCParam>*)arg[0]);
}

static void constructor_2711( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalMCParam>(*(const ::HcalCondObjectContainer<HcalMCParam>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalMCParam>(*(const ::HcalCondObjectContainer<HcalMCParam>*)arg[0]);
}

static void constructor_2712( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalMCParam>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalMCParam>((const ::HcalTopology*)arg[0]);
}

static void destructor_2713(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalMCParam>*)o)->::HcalCondObjectContainer<HcalMCParam>::~HcalCondObjectContainer)();
}
static  void method_2714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalMCParam>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalMCParam>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalMCParam>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalMCParam>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalMCParam>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalMCParam>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalMCParam>*)o)->addValues)(*(const ::HcalMCParam*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalMCParam>*)o)->addValues)(*(const ::HcalMCParam*)arg[0]);
}

static  void method_2717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalMCParam>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalMCParam>*)o)->getAllChannels)();
}

static  void method_2718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalMCParam>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalMCParam>*)o)->myname)();
}

static  void method_2719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalMCParam> > >)((((const ::HcalCondObjectContainer<HcalMCParam>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalMCParam>*)o)->getAllContainers)();
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalMCParam>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalMCParam> -------------------------------
void __HcalCondObjectContainer_HcalMCParam__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalMCParam__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalMCParam__datamem_bld(&__HcalCondObjectContainer_HcalMCParam__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalMCParam__funcmem_bld(&__HcalCondObjectContainer_HcalMCParam__db_funcmem);
void __HcalCondObjectContainer_HcalMCParam__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalMCParam>"), typeid(::HcalCondObjectContainer<HcalMCParam>), sizeof(::HcalCondObjectContainer<HcalMCParam>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalMCParam>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2088, Reflex::Literal("HcalCondObjectContainer<HcalMCParam>::tHcalCont"))
  .AddTypedef(type_1880, Reflex::Literal("HcalCondObjectContainer<HcalMCParam>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9960, type_9961), Reflex::Literal("operator="), operator_2710, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9961), Reflex::Literal("HcalCondObjectContainer"), constructor_2711, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2712, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2713, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalMCParam__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalMCParam__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalMCParam> -------------------
void __HcalCondObjectContainer_HcalMCParam__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1851, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalMCParam_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1851, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalMCParam_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1851, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalMCParam_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1851, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalMCParam_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1851, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalMCParam_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1851, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalMCParam_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1851, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalMCParam_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1851, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalMCParam_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalMCParam> -------------------
void __HcalCondObjectContainer_HcalMCParam__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5515, type_1488, type_2461), Reflex::Literal("getValues"), method_2714, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2715, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_5519), Reflex::Literal("addValues"), method_2716, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2718, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1880c), Reflex::Literal("getAllContainers"), method_2719, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalLongRecoParam -------------------------------
static void destructor_4468(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalLongRecoParam*)o)->::HcalLongRecoParam::~HcalLongRecoParam)();
}
static  void operator_4469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalLongRecoParam*)o)->operator=)(*(const ::HcalLongRecoParam*)arg[0]);
  else   (((::HcalLongRecoParam*)o)->operator=)(*(const ::HcalLongRecoParam*)arg[0]);
}

static void constructor_4470( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLongRecoParam(*(const ::HcalLongRecoParam*)arg[0]);
  else ::new(mem) ::HcalLongRecoParam(*(const ::HcalLongRecoParam*)arg[0]);
}

static void constructor_4471( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLongRecoParam();
  else ::new(mem) ::HcalLongRecoParam();
}

static void constructor_4472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLongRecoParam(*(unsigned long*)arg[0],
      *(::std::vector<unsigned int>*)arg[1],
      *(::std::vector<unsigned int>*)arg[2]);
  else ::new(mem) ::HcalLongRecoParam(*(unsigned long*)arg[0],
      *(::std::vector<unsigned int>*)arg[1],
      *(::std::vector<unsigned int>*)arg[2]);
}

static  void method_4473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalLongRecoParam*)o)->rawId)());
  else   (((const ::HcalLongRecoParam*)o)->rawId)();
}

static  void method_4474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<unsigned int>)((((const ::HcalLongRecoParam*)o)->signalTS)());
  else   (((const ::HcalLongRecoParam*)o)->signalTS)();
}

static  void method_4475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<unsigned int>)((((const ::HcalLongRecoParam*)o)->noiseTS)());
  else   (((const ::HcalLongRecoParam*)o)->noiseTS)();
}

static void method_newdel_1748( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalLongRecoParam >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalLongRecoParam >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalLongRecoParam >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalLongRecoParam >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalLongRecoParam >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalLongRecoParam -------------------------------
void __HcalLongRecoParam_db_datamem(Reflex::Class*);
void __HcalLongRecoParam_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalLongRecoParam_datamem_bld(&__HcalLongRecoParam_db_datamem);
Reflex::GenreflexMemberBuilder __HcalLongRecoParam_funcmem_bld(&__HcalLongRecoParam_db_funcmem);
void __HcalLongRecoParam_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalLongRecoParam"), typeid(::HcalLongRecoParam), sizeof(::HcalLongRecoParam), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalLongRecoParam"), destructor_4468, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5712, type_5714), Reflex::Literal("operator="), operator_4469, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5714), Reflex::Literal("HcalLongRecoParam"), constructor_4470, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalLongRecoParam"), constructor_4471, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1853, type_1853), Reflex::Literal("HcalLongRecoParam"), constructor_4472, 0, "fId;fSignalTS;fNoiseTS", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1748, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalLongRecoParam_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalLongRecoParam_funcmem_bld);
}

//------Delayed data member builder for class HcalLongRecoParam -------------------
void __HcalLongRecoParam_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalLongRecoParam, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1853, Reflex::Literal("mSignalTS"), OffsetOf(__shadow__::__HcalLongRecoParam, mSignalTS), ::Reflex::PRIVATE)
  .AddDataMember(type_1853, Reflex::Literal("mNoiseTS"), OffsetOf(__shadow__::__HcalLongRecoParam, mNoiseTS), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalLongRecoParam -------------------
void __HcalLongRecoParam_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_4473, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1853), Reflex::Literal("signalTS"), method_4474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1853), Reflex::Literal("noiseTS"), method_4475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalLongRecoParam> -------------------------------
static  void operator_2731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalLongRecoParam>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalLongRecoParam>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalLongRecoParam>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalLongRecoParam>*)arg[0]);
}

static void constructor_2732( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalLongRecoParam>(*(const ::HcalCondObjectContainer<HcalLongRecoParam>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalLongRecoParam>(*(const ::HcalCondObjectContainer<HcalLongRecoParam>*)arg[0]);
}

static void constructor_2733( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalLongRecoParam>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalLongRecoParam>((const ::HcalTopology*)arg[0]);
}

static void destructor_2734(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalLongRecoParam>*)o)->::HcalCondObjectContainer<HcalLongRecoParam>::~HcalCondObjectContainer)();
}
static  void method_2735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2737( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalLongRecoParam>*)o)->addValues)(*(const ::HcalLongRecoParam*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalLongRecoParam>*)o)->addValues)(*(const ::HcalLongRecoParam*)arg[0]);
}

static  void method_2738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->getAllChannels)();
}

static  void method_2739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->myname)();
}

static  void method_2740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalLongRecoParam> > >)((((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalLongRecoParam>*)o)->getAllContainers)();
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalLongRecoParam>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalLongRecoParam> -------------------------------
void __HcalCondObjectContainer_HcalLongRecoParam__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalLongRecoParam__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalLongRecoParam__datamem_bld(&__HcalCondObjectContainer_HcalLongRecoParam__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalLongRecoParam__funcmem_bld(&__HcalCondObjectContainer_HcalLongRecoParam__db_funcmem);
void __HcalCondObjectContainer_HcalLongRecoParam__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalLongRecoParam>"), typeid(::HcalCondObjectContainer<HcalLongRecoParam>), sizeof(::HcalCondObjectContainer<HcalLongRecoParam>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalLongRecoParam>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2089, Reflex::Literal("HcalCondObjectContainer<HcalLongRecoParam>::tHcalCont"))
  .AddTypedef(type_1881, Reflex::Literal("HcalCondObjectContainer<HcalLongRecoParam>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9963, type_9964), Reflex::Literal("operator="), operator_2731, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9964), Reflex::Literal("HcalCondObjectContainer"), constructor_2732, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2733, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2734, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalLongRecoParam__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalLongRecoParam__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalLongRecoParam> -------------------
void __HcalCondObjectContainer_HcalLongRecoParam__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1854, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLongRecoParam_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1854, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLongRecoParam_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1854, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLongRecoParam_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1854, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLongRecoParam_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1854, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLongRecoParam_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1854, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLongRecoParam_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1854, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLongRecoParam_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1854, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLongRecoParam_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalLongRecoParam> -------------------
void __HcalCondObjectContainer_HcalLongRecoParam__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5710, type_1488, type_2461), Reflex::Literal("getValues"), method_2735, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2736, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_5714), Reflex::Literal("addValues"), method_2737, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2739, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881c), Reflex::Literal("getAllContainers"), method_2740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalRecoParam -------------------------------
static void destructor_3554(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalRecoParam*)o)->::HcalRecoParam::~HcalRecoParam)();
}
static  void operator_3555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalRecoParam*)o)->operator=)(*(const ::HcalRecoParam*)arg[0]);
  else   (((::HcalRecoParam*)o)->operator=)(*(const ::HcalRecoParam*)arg[0]);
}

static void constructor_3556( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRecoParam(*(const ::HcalRecoParam*)arg[0]);
  else ::new(mem) ::HcalRecoParam(*(const ::HcalRecoParam*)arg[0]);
}

static void constructor_3557( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRecoParam();
  else ::new(mem) ::HcalRecoParam();
}

static void constructor_3558( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRecoParam(*(unsigned long*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2]);
  else ::new(mem) ::HcalRecoParam(*(unsigned long*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2]);
}

static  void method_3559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalRecoParam*)o)->rawId)());
  else   (((const ::HcalRecoParam*)o)->rawId)();
}

static  void method_3560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->param1)());
  else   (((const ::HcalRecoParam*)o)->param1)();
}

static  void method_3561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->param2)());
  else   (((const ::HcalRecoParam*)o)->param2)();
}

static  void method_3562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalRecoParam*)o)->correctForPhaseContainment)());
  else   (((const ::HcalRecoParam*)o)->correctForPhaseContainment)();
}

static  void method_3563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalRecoParam*)o)->correctForLeadingEdge)());
  else   (((const ::HcalRecoParam*)o)->correctForLeadingEdge)();
}

static  void method_3564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalRecoParam*)o)->correctionPhaseNS)());
  else   (((const ::HcalRecoParam*)o)->correctionPhaseNS)();
}

static  void method_3565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->firstSample)());
  else   (((const ::HcalRecoParam*)o)->firstSample)();
}

static  void method_3566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->samplesToAdd)());
  else   (((const ::HcalRecoParam*)o)->samplesToAdd)();
}

static  void method_3567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->pulseShapeID)());
  else   (((const ::HcalRecoParam*)o)->pulseShapeID)();
}

static  void method_3568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalRecoParam*)o)->useLeakCorrection)());
  else   (((const ::HcalRecoParam*)o)->useLeakCorrection)();
}

static  void method_3569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->leakCorrectionID)());
  else   (((const ::HcalRecoParam*)o)->leakCorrectionID)();
}

static  void method_3570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalRecoParam*)o)->correctForTimeslew)());
  else   (((const ::HcalRecoParam*)o)->correctForTimeslew)();
}

static  void method_3571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->timeslewCorrectionID)());
  else   (((const ::HcalRecoParam*)o)->timeslewCorrectionID)();
}

static  void method_3572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalRecoParam*)o)->correctTiming)());
  else   (((const ::HcalRecoParam*)o)->correctTiming)();
}

static  void method_3573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->firstAuxTS)());
  else   (((const ::HcalRecoParam*)o)->firstAuxTS)();
}

static  void method_3574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->specialCaseID)());
  else   (((const ::HcalRecoParam*)o)->specialCaseID)();
}

static  void method_3575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->noiseFlaggingID)());
  else   (((const ::HcalRecoParam*)o)->noiseFlaggingID)();
}

static  void method_3576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->pileupCleaningID)());
  else   (((const ::HcalRecoParam*)o)->pileupCleaningID)();
}

static  void method_3577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalRecoParam*)o)->packingScheme)());
  else   (((const ::HcalRecoParam*)o)->packingScheme)();
}

static void method_newdel_745( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalRecoParam >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalRecoParam >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalRecoParam >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalRecoParam >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalRecoParam >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalRecoParam -------------------------------
void __HcalRecoParam_db_datamem(Reflex::Class*);
void __HcalRecoParam_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalRecoParam_datamem_bld(&__HcalRecoParam_db_datamem);
Reflex::GenreflexMemberBuilder __HcalRecoParam_funcmem_bld(&__HcalRecoParam_db_funcmem);
void __HcalRecoParam_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalRecoParam"), typeid(::HcalRecoParam), sizeof(::HcalRecoParam), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalRecoParam"), destructor_3554, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5582, type_5584), Reflex::Literal("operator="), operator_3555, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5584), Reflex::Literal("HcalRecoParam"), constructor_3556, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalRecoParam"), constructor_3557, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_43, type_43), Reflex::Literal("HcalRecoParam"), constructor_3558, 0, "fId;fParam1;fParam2", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_745, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalRecoParam_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalRecoParam_funcmem_bld);
}

//------Delayed data member builder for class HcalRecoParam -------------------
void __HcalRecoParam_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalRecoParam, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("mParam1"), OffsetOf(__shadow__::__HcalRecoParam, mParam1), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("mParam2"), OffsetOf(__shadow__::__HcalRecoParam, mParam2), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalRecoParam -------------------
void __HcalRecoParam_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_3559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("param1"), method_3560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("param2"), method_3561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("correctForPhaseContainment"), method_3562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("correctForLeadingEdge"), method_3563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("correctionPhaseNS"), method_3564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("firstSample"), method_3565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("samplesToAdd"), method_3566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("pulseShapeID"), method_3567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("useLeakCorrection"), method_3568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("leakCorrectionID"), method_3569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("correctForTimeslew"), method_3570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("timeslewCorrectionID"), method_3571, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("correctTiming"), method_3572, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("firstAuxTS"), method_3573, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("specialCaseID"), method_3574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("noiseFlaggingID"), method_3575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("pileupCleaningID"), method_3576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43), Reflex::Literal("packingScheme"), method_3577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalRecoParam> -------------------------------
static  void operator_2752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalRecoParam>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalRecoParam>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalRecoParam>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalRecoParam>*)arg[0]);
}

static void constructor_2753( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalRecoParam>(*(const ::HcalCondObjectContainer<HcalRecoParam>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalRecoParam>(*(const ::HcalCondObjectContainer<HcalRecoParam>*)arg[0]);
}

static void constructor_2754( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalRecoParam>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalRecoParam>((const ::HcalTopology*)arg[0]);
}

static void destructor_2755(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalRecoParam>*)o)->::HcalCondObjectContainer<HcalRecoParam>::~HcalCondObjectContainer)();
}
static  void method_2756( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2758( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalRecoParam>*)o)->addValues)(*(const ::HcalRecoParam*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalRecoParam>*)o)->addValues)(*(const ::HcalRecoParam*)arg[0]);
}

static  void method_2759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->getAllChannels)();
}

static  void method_2760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->myname)();
}

static  void method_2761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalRecoParam> > >)((((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalRecoParam>*)o)->getAllContainers)();
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalRecoParam>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalRecoParam> -------------------------------
void __HcalCondObjectContainer_HcalRecoParam__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalRecoParam__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalRecoParam__datamem_bld(&__HcalCondObjectContainer_HcalRecoParam__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalRecoParam__funcmem_bld(&__HcalCondObjectContainer_HcalRecoParam__db_funcmem);
void __HcalCondObjectContainer_HcalRecoParam__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalRecoParam>"), typeid(::HcalCondObjectContainer<HcalRecoParam>), sizeof(::HcalCondObjectContainer<HcalRecoParam>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalRecoParam>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2090, Reflex::Literal("HcalCondObjectContainer<HcalRecoParam>::tHcalCont"))
  .AddTypedef(type_1882, Reflex::Literal("HcalCondObjectContainer<HcalRecoParam>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9966, type_9967), Reflex::Literal("operator="), operator_2752, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9967), Reflex::Literal("HcalCondObjectContainer"), constructor_2753, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2754, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2755, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalRecoParam__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalRecoParam__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalRecoParam> -------------------
void __HcalCondObjectContainer_HcalRecoParam__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1852, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRecoParam_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1852, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRecoParam_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1852, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRecoParam_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1852, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRecoParam_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1852, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRecoParam_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1852, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRecoParam_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1852, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRecoParam_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1852, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRecoParam_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalRecoParam> -------------------
void __HcalCondObjectContainer_HcalRecoParam__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5580, type_1488, type_2461), Reflex::Literal("getValues"), method_2756, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2757, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_5584), Reflex::Literal("addValues"), method_2758, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2760, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1882c), Reflex::Literal("getAllContainers"), method_2761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalLutMetadatum -------------------------------
static void destructor_4340(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalLutMetadatum*)o)->::HcalLutMetadatum::~HcalLutMetadatum)();
}
static  void operator_4341( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalLutMetadatum*)o)->operator=)(*(const ::HcalLutMetadatum*)arg[0]);
  else   (((::HcalLutMetadatum*)o)->operator=)(*(const ::HcalLutMetadatum*)arg[0]);
}

static void constructor_4342( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLutMetadatum(*(const ::HcalLutMetadatum*)arg[0]);
  else ::new(mem) ::HcalLutMetadatum(*(const ::HcalLutMetadatum*)arg[0]);
}

static void constructor_4343( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLutMetadatum();
  else ::new(mem) ::HcalLutMetadatum();
}

static void constructor_4344( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLutMetadatum(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(::uint8_t*)arg[2],
      *(::uint8_t*)arg[3]);
  else ::new(mem) ::HcalLutMetadatum(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(::uint8_t*)arg[2],
      *(::uint8_t*)arg[3]);
}

static  void method_4345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalLutMetadatum*)o)->rawId)());
  else   (((const ::HcalLutMetadatum*)o)->rawId)();
}

static  void method_4346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalLutMetadatum*)o)->getRCalib)());
  else   (((const ::HcalLutMetadatum*)o)->getRCalib)();
}

static  void method_4347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint8_t)((((const ::HcalLutMetadatum*)o)->getLutGranularity)());
  else   (((const ::HcalLutMetadatum*)o)->getLutGranularity)();
}

static  void method_4348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint8_t)((((const ::HcalLutMetadatum*)o)->getOutputLutThreshold)());
  else   (((const ::HcalLutMetadatum*)o)->getOutputLutThreshold)();
}

static void method_newdel_1624( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalLutMetadatum >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalLutMetadatum >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalLutMetadatum >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalLutMetadatum >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalLutMetadatum >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalLutMetadatum -------------------------------
void __HcalLutMetadatum_db_datamem(Reflex::Class*);
void __HcalLutMetadatum_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalLutMetadatum_datamem_bld(&__HcalLutMetadatum_db_datamem);
Reflex::GenreflexMemberBuilder __HcalLutMetadatum_funcmem_bld(&__HcalLutMetadatum_db_funcmem);
void __HcalLutMetadatum_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalLutMetadatum"), typeid(::HcalLutMetadatum), sizeof(::HcalLutMetadatum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalLutMetadatum"), destructor_4340, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6036, type_6038), Reflex::Literal("operator="), operator_4341, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6038), Reflex::Literal("HcalLutMetadatum"), constructor_4342, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalLutMetadatum"), constructor_4343, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1181, type_145, type_145), Reflex::Literal("HcalLutMetadatum"), constructor_4344, 0, "fid;rCalib;lutGranularity;outputLutThreshold", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1624, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalLutMetadatum_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalLutMetadatum_funcmem_bld);
}

//------Delayed data member builder for class HcalLutMetadatum -------------------
void __HcalLutMetadatum_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalLutMetadatum, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mRCalib"), OffsetOf(__shadow__::__HcalLutMetadatum, mRCalib), ::Reflex::PRIVATE)
  .AddDataMember(type_145, Reflex::Literal("mLutGranularity"), OffsetOf(__shadow__::__HcalLutMetadatum, mLutGranularity), ::Reflex::PRIVATE)
  .AddDataMember(type_145, Reflex::Literal("mOutputLutThreshold"), OffsetOf(__shadow__::__HcalLutMetadatum, mOutputLutThreshold), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalLutMetadatum -------------------
void __HcalLutMetadatum_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_4345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getRCalib"), method_4346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_145), Reflex::Literal("getLutGranularity"), method_4347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_145), Reflex::Literal("getOutputLutThreshold"), method_4348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalLutMetadatum> -------------------------------
static  void operator_2773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalLutMetadatum>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalLutMetadatum>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalLutMetadatum>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalLutMetadatum>*)arg[0]);
}

static void constructor_2774( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalLutMetadatum>(*(const ::HcalCondObjectContainer<HcalLutMetadatum>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalLutMetadatum>(*(const ::HcalCondObjectContainer<HcalLutMetadatum>*)arg[0]);
}

static void constructor_2775( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalLutMetadatum>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalLutMetadatum>((const ::HcalTopology*)arg[0]);
}

static void destructor_2776(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalLutMetadatum>*)o)->::HcalCondObjectContainer<HcalLutMetadatum>::~HcalCondObjectContainer)();
}
static  void method_2777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalLutMetadatum>*)o)->addValues)(*(const ::HcalLutMetadatum*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalLutMetadatum>*)o)->addValues)(*(const ::HcalLutMetadatum*)arg[0]);
}

static  void method_2780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->getAllChannels)();
}

static  void method_2781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->myname)();
}

static  void method_2782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalLutMetadatum> > >)((((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalLutMetadatum>*)o)->getAllContainers)();
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalLutMetadatum>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalLutMetadatum> -------------------------------
void __HcalCondObjectContainer_HcalLutMetadatum__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalLutMetadatum__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalLutMetadatum__datamem_bld(&__HcalCondObjectContainer_HcalLutMetadatum__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalLutMetadatum__funcmem_bld(&__HcalCondObjectContainer_HcalLutMetadatum__db_funcmem);
void __HcalCondObjectContainer_HcalLutMetadatum__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalLutMetadatum>"), typeid(::HcalCondObjectContainer<HcalLutMetadatum>), sizeof(::HcalCondObjectContainer<HcalLutMetadatum>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalLutMetadatum>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2091, Reflex::Literal("HcalCondObjectContainer<HcalLutMetadatum>::tHcalCont"))
  .AddTypedef(type_1887, Reflex::Literal("HcalCondObjectContainer<HcalLutMetadatum>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9969, type_9970), Reflex::Literal("operator="), operator_2773, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9970), Reflex::Literal("HcalCondObjectContainer"), constructor_2774, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2775, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2776, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalLutMetadatum__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalLutMetadatum__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalLutMetadatum> -------------------
void __HcalCondObjectContainer_HcalLutMetadatum__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1859, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLutMetadatum_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1859, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLutMetadatum_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1859, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLutMetadatum_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1859, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLutMetadatum_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1859, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLutMetadatum_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1859, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLutMetadatum_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1859, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLutMetadatum_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1859, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLutMetadatum_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalLutMetadatum> -------------------
void __HcalCondObjectContainer_HcalLutMetadatum__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6034, type_1488, type_2461), Reflex::Literal("getValues"), method_2777, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2778, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6038), Reflex::Literal("addValues"), method_2779, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2781, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1887c), Reflex::Literal("getAllContainers"), method_2782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalValidationCorr> -------------------------------
static  void operator_2794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalValidationCorr>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalValidationCorr>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalValidationCorr>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalValidationCorr>*)arg[0]);
}

static void constructor_2795( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalValidationCorr>(*(const ::HcalCondObjectContainer<HcalValidationCorr>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalValidationCorr>(*(const ::HcalCondObjectContainer<HcalValidationCorr>*)arg[0]);
}

static void constructor_2796( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalValidationCorr>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalValidationCorr>((const ::HcalTopology*)arg[0]);
}

static void destructor_2797(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalValidationCorr>*)o)->::HcalCondObjectContainer<HcalValidationCorr>::~HcalCondObjectContainer)();
}
static  void method_2798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalValidationCorr>*)o)->addValues)(*(const ::HcalValidationCorr*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalValidationCorr>*)o)->addValues)(*(const ::HcalValidationCorr*)arg[0]);
}

static  void method_2801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->getAllChannels)();
}

static  void method_2802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->myname)();
}

static  void method_2803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalValidationCorr> > >)((((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalValidationCorr>*)o)->getAllContainers)();
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalValidationCorr>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalValidationCorr> -------------------------------
void __HcalCondObjectContainer_HcalValidationCorr__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalValidationCorr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalValidationCorr__datamem_bld(&__HcalCondObjectContainer_HcalValidationCorr__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalValidationCorr__funcmem_bld(&__HcalCondObjectContainer_HcalValidationCorr__db_funcmem);
void __HcalCondObjectContainer_HcalValidationCorr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalValidationCorr>"), typeid(::HcalCondObjectContainer<HcalValidationCorr>), sizeof(::HcalCondObjectContainer<HcalValidationCorr>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalValidationCorr>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2092, Reflex::Literal("HcalCondObjectContainer<HcalValidationCorr>::tHcalCont"))
  .AddTypedef(type_1888, Reflex::Literal("HcalCondObjectContainer<HcalValidationCorr>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9972, type_9973), Reflex::Literal("operator="), operator_2794, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9973), Reflex::Literal("HcalCondObjectContainer"), constructor_2795, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2796, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2797, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalValidationCorr__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalValidationCorr__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalValidationCorr> -------------------
void __HcalCondObjectContainer_HcalValidationCorr__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1860, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalValidationCorr_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1860, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalValidationCorr_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1860, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalValidationCorr_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1860, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalValidationCorr_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1860, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalValidationCorr_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1860, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalValidationCorr_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1860, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalValidationCorr_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1860, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalValidationCorr_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalValidationCorr> -------------------
void __HcalCondObjectContainer_HcalValidationCorr__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6099, type_1488, type_2461), Reflex::Literal("getValues"), method_2798, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2799, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6103), Reflex::Literal("addValues"), method_2800, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2802, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1888c), Reflex::Literal("getAllContainers"), method_2803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalPFCorr -------------------------------
static void destructor_4305(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalPFCorr*)o)->::HcalPFCorr::~HcalPFCorr)();
}
static  void operator_4306( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalPFCorr*)o)->operator=)(*(const ::HcalPFCorr*)arg[0]);
  else   (((::HcalPFCorr*)o)->operator=)(*(const ::HcalPFCorr*)arg[0]);
}

static void constructor_4307( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPFCorr(*(const ::HcalPFCorr*)arg[0]);
  else ::new(mem) ::HcalPFCorr(*(const ::HcalPFCorr*)arg[0]);
}

static void constructor_4308( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPFCorr();
  else ::new(mem) ::HcalPFCorr();
}

static void constructor_4309( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPFCorr(*(unsigned long*)arg[0],
      *(float*)arg[1]);
  else ::new(mem) ::HcalPFCorr(*(unsigned long*)arg[0],
      *(float*)arg[1]);
}

static  void method_4310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalPFCorr*)o)->rawId)());
  else   (((const ::HcalPFCorr*)o)->rawId)();
}

static  void method_4311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalPFCorr*)o)->getValue)());
  else   (((const ::HcalPFCorr*)o)->getValue)();
}

static void method_newdel_1530( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalPFCorr >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalPFCorr >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalPFCorr >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalPFCorr >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalPFCorr >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalPFCorr -------------------------------
void __HcalPFCorr_db_datamem(Reflex::Class*);
void __HcalPFCorr_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalPFCorr_datamem_bld(&__HcalPFCorr_db_datamem);
Reflex::GenreflexMemberBuilder __HcalPFCorr_funcmem_bld(&__HcalPFCorr_db_funcmem);
void __HcalPFCorr_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalPFCorr"), typeid(::HcalPFCorr), sizeof(::HcalPFCorr), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalPFCorr"), destructor_4305, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6296, type_6298), Reflex::Literal("operator="), operator_4306, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6298), Reflex::Literal("HcalPFCorr"), constructor_4307, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalPFCorr"), constructor_4308, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1181), Reflex::Literal("HcalPFCorr"), constructor_4309, 0, "fid;value", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1530, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalPFCorr_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalPFCorr_funcmem_bld);
}

//------Delayed data member builder for class HcalPFCorr -------------------
void __HcalPFCorr_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalPFCorr, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue"), OffsetOf(__shadow__::__HcalPFCorr, mValue), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalPFCorr -------------------
void __HcalPFCorr_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_4310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getValue"), method_4311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalPFCorr> -------------------------------
static  void operator_2815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalPFCorr>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalPFCorr>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalPFCorr>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalPFCorr>*)arg[0]);
}

static void constructor_2816( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalPFCorr>(*(const ::HcalCondObjectContainer<HcalPFCorr>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalPFCorr>(*(const ::HcalCondObjectContainer<HcalPFCorr>*)arg[0]);
}

static void constructor_2817( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalPFCorr>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalPFCorr>((const ::HcalTopology*)arg[0]);
}

static void destructor_2818(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalPFCorr>*)o)->::HcalCondObjectContainer<HcalPFCorr>::~HcalCondObjectContainer)();
}
static  void method_2819( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalPFCorr>*)o)->addValues)(*(const ::HcalPFCorr*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalPFCorr>*)o)->addValues)(*(const ::HcalPFCorr*)arg[0]);
}

static  void method_2822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->getAllChannels)();
}

static  void method_2823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->myname)();
}

static  void method_2824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalPFCorr> > >)((((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalPFCorr>*)o)->getAllContainers)();
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalPFCorr>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalPFCorr> -------------------------------
void __HcalCondObjectContainer_HcalPFCorr__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalPFCorr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalPFCorr__datamem_bld(&__HcalCondObjectContainer_HcalPFCorr__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalPFCorr__funcmem_bld(&__HcalCondObjectContainer_HcalPFCorr__db_funcmem);
void __HcalCondObjectContainer_HcalPFCorr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalPFCorr>"), typeid(::HcalCondObjectContainer<HcalPFCorr>), sizeof(::HcalCondObjectContainer<HcalPFCorr>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalPFCorr>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2093, Reflex::Literal("HcalCondObjectContainer<HcalPFCorr>::tHcalCont"))
  .AddTypedef(type_1889, Reflex::Literal("HcalCondObjectContainer<HcalPFCorr>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9975, type_9976), Reflex::Literal("operator="), operator_2815, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9976), Reflex::Literal("HcalCondObjectContainer"), constructor_2816, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2817, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2818, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalPFCorr__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalPFCorr__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalPFCorr> -------------------
void __HcalCondObjectContainer_HcalPFCorr__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1863, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPFCorr_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1863, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPFCorr_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1863, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPFCorr_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1863, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPFCorr_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1863, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPFCorr_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1863, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPFCorr_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1863, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPFCorr_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1863, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPFCorr_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalPFCorr> -------------------
void __HcalCondObjectContainer_HcalPFCorr__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6294, type_1488, type_2461), Reflex::Literal("getValues"), method_2819, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2820, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6298), Reflex::Literal("addValues"), method_2821, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2823, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1889c), Reflex::Literal("getAllContainers"), method_2824, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalLUTCorr -------------------------------
static void destructor_4296(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalLUTCorr*)o)->::HcalLUTCorr::~HcalLUTCorr)();
}
static  void operator_4297( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalLUTCorr*)o)->operator=)(*(const ::HcalLUTCorr*)arg[0]);
  else   (((::HcalLUTCorr*)o)->operator=)(*(const ::HcalLUTCorr*)arg[0]);
}

static void constructor_4298( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLUTCorr(*(const ::HcalLUTCorr*)arg[0]);
  else ::new(mem) ::HcalLUTCorr(*(const ::HcalLUTCorr*)arg[0]);
}

static void constructor_4299( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLUTCorr();
  else ::new(mem) ::HcalLUTCorr();
}

static void constructor_4300( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLUTCorr(*(unsigned long*)arg[0],
      *(float*)arg[1]);
  else ::new(mem) ::HcalLUTCorr(*(unsigned long*)arg[0],
      *(float*)arg[1]);
}

static  void method_4301( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalLUTCorr*)o)->rawId)());
  else   (((const ::HcalLUTCorr*)o)->rawId)();
}

static  void method_4302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalLUTCorr*)o)->getValue)());
  else   (((const ::HcalLUTCorr*)o)->getValue)();
}

static void method_newdel_1511( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalLUTCorr >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalLUTCorr >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalLUTCorr >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalLUTCorr >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalLUTCorr >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalLUTCorr -------------------------------
void __HcalLUTCorr_db_datamem(Reflex::Class*);
void __HcalLUTCorr_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalLUTCorr_datamem_bld(&__HcalLUTCorr_db_datamem);
Reflex::GenreflexMemberBuilder __HcalLUTCorr_funcmem_bld(&__HcalLUTCorr_db_funcmem);
void __HcalLUTCorr_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalLUTCorr"), typeid(::HcalLUTCorr), sizeof(::HcalLUTCorr), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalLUTCorr"), destructor_4296, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6361, type_6363), Reflex::Literal("operator="), operator_4297, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6363), Reflex::Literal("HcalLUTCorr"), constructor_4298, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalLUTCorr"), constructor_4299, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1181), Reflex::Literal("HcalLUTCorr"), constructor_4300, 0, "fid;value", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1511, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalLUTCorr_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalLUTCorr_funcmem_bld);
}

//------Delayed data member builder for class HcalLUTCorr -------------------
void __HcalLUTCorr_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalLUTCorr, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue"), OffsetOf(__shadow__::__HcalLUTCorr, mValue), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalLUTCorr -------------------
void __HcalLUTCorr_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_4301, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getValue"), method_4302, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalLUTCorr> -------------------------------
static  void operator_2836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalLUTCorr>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalLUTCorr>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalLUTCorr>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalLUTCorr>*)arg[0]);
}

static void constructor_2837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalLUTCorr>(*(const ::HcalCondObjectContainer<HcalLUTCorr>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalLUTCorr>(*(const ::HcalCondObjectContainer<HcalLUTCorr>*)arg[0]);
}

static void constructor_2838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalLUTCorr>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalLUTCorr>((const ::HcalTopology*)arg[0]);
}

static void destructor_2839(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalLUTCorr>*)o)->::HcalCondObjectContainer<HcalLUTCorr>::~HcalCondObjectContainer)();
}
static  void method_2840( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2841( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2842( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalLUTCorr>*)o)->addValues)(*(const ::HcalLUTCorr*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalLUTCorr>*)o)->addValues)(*(const ::HcalLUTCorr*)arg[0]);
}

static  void method_2843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->getAllChannels)();
}

static  void method_2844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->myname)();
}

static  void method_2845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalLUTCorr> > >)((((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalLUTCorr>*)o)->getAllContainers)();
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalLUTCorr>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalLUTCorr> -------------------------------
void __HcalCondObjectContainer_HcalLUTCorr__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalLUTCorr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalLUTCorr__datamem_bld(&__HcalCondObjectContainer_HcalLUTCorr__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalLUTCorr__funcmem_bld(&__HcalCondObjectContainer_HcalLUTCorr__db_funcmem);
void __HcalCondObjectContainer_HcalLUTCorr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalLUTCorr>"), typeid(::HcalCondObjectContainer<HcalLUTCorr>), sizeof(::HcalCondObjectContainer<HcalLUTCorr>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalLUTCorr>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2094, Reflex::Literal("HcalCondObjectContainer<HcalLUTCorr>::tHcalCont"))
  .AddTypedef(type_1890, Reflex::Literal("HcalCondObjectContainer<HcalLUTCorr>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9978, type_9979), Reflex::Literal("operator="), operator_2836, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9979), Reflex::Literal("HcalCondObjectContainer"), constructor_2837, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2838, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2839, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalLUTCorr__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalLUTCorr__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalLUTCorr> -------------------
void __HcalCondObjectContainer_HcalLUTCorr__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1864, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLUTCorr_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1864, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLUTCorr_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1864, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLUTCorr_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1864, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLUTCorr_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1864, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLUTCorr_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1864, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLUTCorr_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1864, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLUTCorr_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1864, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalLUTCorr_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalLUTCorr> -------------------
void __HcalCondObjectContainer_HcalLUTCorr__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6359, type_1488, type_2461), Reflex::Literal("getValues"), method_2840, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2841, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6363), Reflex::Literal("addValues"), method_2842, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2844, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1890c), Reflex::Literal("getAllContainers"), method_2845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalTimeCorr> -------------------------------
static  void operator_2857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalTimeCorr>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalTimeCorr>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalTimeCorr>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalTimeCorr>*)arg[0]);
}

static void constructor_2858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalTimeCorr>(*(const ::HcalCondObjectContainer<HcalTimeCorr>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalTimeCorr>(*(const ::HcalCondObjectContainer<HcalTimeCorr>*)arg[0]);
}

static void constructor_2859( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalTimeCorr>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalTimeCorr>((const ::HcalTopology*)arg[0]);
}

static void destructor_2860(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalTimeCorr>*)o)->::HcalCondObjectContainer<HcalTimeCorr>::~HcalCondObjectContainer)();
}
static  void method_2861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalTimeCorr>*)o)->addValues)(*(const ::HcalTimeCorr*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalTimeCorr>*)o)->addValues)(*(const ::HcalTimeCorr*)arg[0]);
}

static  void method_2864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->getAllChannels)();
}

static  void method_2865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->myname)();
}

static  void method_2866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalTimeCorr> > >)((((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalTimeCorr>*)o)->getAllContainers)();
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalTimeCorr>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalTimeCorr> -------------------------------
void __HcalCondObjectContainer_HcalTimeCorr__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalTimeCorr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalTimeCorr__datamem_bld(&__HcalCondObjectContainer_HcalTimeCorr__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalTimeCorr__funcmem_bld(&__HcalCondObjectContainer_HcalTimeCorr__db_funcmem);
void __HcalCondObjectContainer_HcalTimeCorr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalTimeCorr>"), typeid(::HcalCondObjectContainer<HcalTimeCorr>), sizeof(::HcalCondObjectContainer<HcalTimeCorr>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalTimeCorr>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2095, Reflex::Literal("HcalCondObjectContainer<HcalTimeCorr>::tHcalCont"))
  .AddTypedef(type_1891, Reflex::Literal("HcalCondObjectContainer<HcalTimeCorr>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9981, type_9982), Reflex::Literal("operator="), operator_2857, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9982), Reflex::Literal("HcalCondObjectContainer"), constructor_2858, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2859, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2860, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalTimeCorr__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalTimeCorr__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalTimeCorr> -------------------
void __HcalCondObjectContainer_HcalTimeCorr__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1861, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimeCorr_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1861, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimeCorr_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1861, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimeCorr_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1861, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimeCorr_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1861, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimeCorr_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1861, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimeCorr_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1861, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimeCorr_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1861, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalTimeCorr_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalTimeCorr> -------------------
void __HcalCondObjectContainer_HcalTimeCorr__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6164, type_1488, type_2461), Reflex::Literal("getValues"), method_2861, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2862, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6168), Reflex::Literal("addValues"), method_2863, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2865, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1891c), Reflex::Literal("getAllContainers"), method_2866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalL1TriggerObject -------------------------------
static void destructor_3324(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalL1TriggerObject*)o)->::HcalL1TriggerObject::~HcalL1TriggerObject)();
}
static  void operator_3325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalL1TriggerObject*)o)->operator=)(*(const ::HcalL1TriggerObject*)arg[0]);
  else   (((::HcalL1TriggerObject*)o)->operator=)(*(const ::HcalL1TriggerObject*)arg[0]);
}

static void constructor_3326( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalL1TriggerObject(*(const ::HcalL1TriggerObject*)arg[0]);
  else ::new(mem) ::HcalL1TriggerObject(*(const ::HcalL1TriggerObject*)arg[0]);
}

static void constructor_3327( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalL1TriggerObject();
  else ::new(mem) ::HcalL1TriggerObject();
}

static void constructor_3328( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalL1TriggerObject(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2]);
  else ::new(mem) ::HcalL1TriggerObject(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalL1TriggerObject(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(unsigned long*)arg[3]);
  else ::new(mem) ::HcalL1TriggerObject(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(unsigned long*)arg[3]);
  }
}

static  void method_3329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalL1TriggerObject*)o)->rawId)());
  else   (((const ::HcalL1TriggerObject*)o)->rawId)();
}

static  void method_3330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalL1TriggerObject*)o)->getPedestal)());
  else   (((const ::HcalL1TriggerObject*)o)->getPedestal)();
}

static  void method_3331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalL1TriggerObject*)o)->getRespGain)());
  else   (((const ::HcalL1TriggerObject*)o)->getRespGain)();
}

static  void method_3332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalL1TriggerObject*)o)->getFlag)());
  else   (((const ::HcalL1TriggerObject*)o)->getFlag)();
}

static void method_newdel_491( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalL1TriggerObject >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalL1TriggerObject >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalL1TriggerObject >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalL1TriggerObject >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalL1TriggerObject >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalL1TriggerObject -------------------------------
void __HcalL1TriggerObject_db_datamem(Reflex::Class*);
void __HcalL1TriggerObject_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalL1TriggerObject_datamem_bld(&__HcalL1TriggerObject_db_datamem);
Reflex::GenreflexMemberBuilder __HcalL1TriggerObject_funcmem_bld(&__HcalL1TriggerObject_db_funcmem);
void __HcalL1TriggerObject_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalL1TriggerObject"), typeid(::HcalL1TriggerObject), sizeof(::HcalL1TriggerObject), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalL1TriggerObject"), destructor_3324, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6231, type_6233), Reflex::Literal("operator="), operator_3325, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6233), Reflex::Literal("HcalL1TriggerObject"), constructor_3326, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalL1TriggerObject"), constructor_3327, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1181, type_1181, type_18), Reflex::Literal("HcalL1TriggerObject"), constructor_3328, 0, "fId;fAvrgPed;fRespCorrGain;fFlag=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_491, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalL1TriggerObject_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalL1TriggerObject_funcmem_bld);
}

//------Delayed data member builder for class HcalL1TriggerObject -------------------
void __HcalL1TriggerObject_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalL1TriggerObject, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mAvrgPed"), OffsetOf(__shadow__::__HcalL1TriggerObject, mAvrgPed), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mRespCorrGain"), OffsetOf(__shadow__::__HcalL1TriggerObject, mRespCorrGain), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("mFlag"), OffsetOf(__shadow__::__HcalL1TriggerObject, mFlag), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalL1TriggerObject -------------------
void __HcalL1TriggerObject_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_3329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getPedestal"), method_3330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getRespGain"), method_3331, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("getFlag"), method_3332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalL1TriggerObject> -------------------------------
static  void operator_2878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalL1TriggerObject>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalL1TriggerObject>*)arg[0]);
}

static void constructor_2879( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalL1TriggerObject>(*(const ::HcalCondObjectContainer<HcalL1TriggerObject>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalL1TriggerObject>(*(const ::HcalCondObjectContainer<HcalL1TriggerObject>*)arg[0]);
}

static void constructor_2880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalL1TriggerObject>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalL1TriggerObject>((const ::HcalTopology*)arg[0]);
}

static void destructor_2881(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->::HcalCondObjectContainer<HcalL1TriggerObject>::~HcalCondObjectContainer)();
}
static  void method_2882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->addValues)(*(const ::HcalL1TriggerObject*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->addValues)(*(const ::HcalL1TriggerObject*)arg[0]);
}

static  void method_2885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->getAllChannels)();
}

static  void method_2886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->myname)();
}

static  void method_2887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalL1TriggerObject> > >)((((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalL1TriggerObject>*)o)->getAllContainers)();
}

static void method_x29( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalL1TriggerObject>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalL1TriggerObject> -------------------------------
void __HcalCondObjectContainer_HcalL1TriggerObject__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalL1TriggerObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalL1TriggerObject__datamem_bld(&__HcalCondObjectContainer_HcalL1TriggerObject__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalL1TriggerObject__funcmem_bld(&__HcalCondObjectContainer_HcalL1TriggerObject__db_funcmem);
void __HcalCondObjectContainer_HcalL1TriggerObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalL1TriggerObject>"), typeid(::HcalCondObjectContainer<HcalL1TriggerObject>), sizeof(::HcalCondObjectContainer<HcalL1TriggerObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalL1TriggerObject>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2096, Reflex::Literal("HcalCondObjectContainer<HcalL1TriggerObject>::tHcalCont"))
  .AddTypedef(type_1892, Reflex::Literal("HcalCondObjectContainer<HcalL1TriggerObject>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9984, type_9985), Reflex::Literal("operator="), operator_2878, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9985), Reflex::Literal("HcalCondObjectContainer"), constructor_2879, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2880, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2881, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalL1TriggerObject__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalL1TriggerObject__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalL1TriggerObject> -------------------
void __HcalCondObjectContainer_HcalL1TriggerObject__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1862, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalL1TriggerObject_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1862, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalL1TriggerObject_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1862, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalL1TriggerObject_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1862, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalL1TriggerObject_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1862, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalL1TriggerObject_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1862, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalL1TriggerObject_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1862, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalL1TriggerObject_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1862, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalL1TriggerObject_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalL1TriggerObject> -------------------
void __HcalCondObjectContainer_HcalL1TriggerObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6229, type_1488, type_2461), Reflex::Literal("getValues"), method_2882, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2883, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6233), Reflex::Literal("addValues"), method_2884, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2886, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1892c), Reflex::Literal("getAllContainers"), method_2887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalRespCorr -------------------------------
static void destructor_3114(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalRespCorr*)o)->::HcalRespCorr::~HcalRespCorr)();
}
static  void operator_3115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalRespCorr*)o)->operator=)(*(const ::HcalRespCorr*)arg[0]);
  else   (((::HcalRespCorr*)o)->operator=)(*(const ::HcalRespCorr*)arg[0]);
}

static void constructor_3116( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRespCorr(*(const ::HcalRespCorr*)arg[0]);
  else ::new(mem) ::HcalRespCorr(*(const ::HcalRespCorr*)arg[0]);
}

static void constructor_3117( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRespCorr();
  else ::new(mem) ::HcalRespCorr();
}

static void constructor_3118( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRespCorr(*(unsigned long*)arg[0],
      *(float*)arg[1]);
  else ::new(mem) ::HcalRespCorr(*(unsigned long*)arg[0],
      *(float*)arg[1]);
}

static  void method_3119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalRespCorr*)o)->rawId)());
  else   (((const ::HcalRespCorr*)o)->rawId)();
}

static  void method_3120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalRespCorr*)o)->getValue)());
  else   (((const ::HcalRespCorr*)o)->getValue)();
}

static void method_newdel_231( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalRespCorr >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalRespCorr >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalRespCorr >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalRespCorr >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalRespCorr >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalRespCorr -------------------------------
void __HcalRespCorr_db_datamem(Reflex::Class*);
void __HcalRespCorr_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalRespCorr_datamem_bld(&__HcalRespCorr_db_datamem);
Reflex::GenreflexMemberBuilder __HcalRespCorr_funcmem_bld(&__HcalRespCorr_db_funcmem);
void __HcalRespCorr_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalRespCorr"), typeid(::HcalRespCorr), sizeof(::HcalRespCorr), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalRespCorr"), destructor_3114, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6426, type_6428), Reflex::Literal("operator="), operator_3115, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6428), Reflex::Literal("HcalRespCorr"), constructor_3116, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalRespCorr"), constructor_3117, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1181), Reflex::Literal("HcalRespCorr"), constructor_3118, 0, "fid;value", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_231, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalRespCorr_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalRespCorr_funcmem_bld);
}

//------Delayed data member builder for class HcalRespCorr -------------------
void __HcalRespCorr_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalRespCorr, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue"), OffsetOf(__shadow__::__HcalRespCorr, mValue), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalRespCorr -------------------
void __HcalRespCorr_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_3119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getValue"), method_3120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalRespCorr> -------------------------------
static  void operator_2899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalRespCorr>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalRespCorr>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalRespCorr>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalRespCorr>*)arg[0]);
}

static void constructor_2900( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalRespCorr>(*(const ::HcalCondObjectContainer<HcalRespCorr>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalRespCorr>(*(const ::HcalCondObjectContainer<HcalRespCorr>*)arg[0]);
}

static void constructor_2901( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalRespCorr>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalRespCorr>((const ::HcalTopology*)arg[0]);
}

static void destructor_2902(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalRespCorr>*)o)->::HcalCondObjectContainer<HcalRespCorr>::~HcalCondObjectContainer)();
}
static  void method_2903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalRespCorr>*)o)->addValues)(*(const ::HcalRespCorr*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalRespCorr>*)o)->addValues)(*(const ::HcalRespCorr*)arg[0]);
}

static  void method_2906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->getAllChannels)();
}

static  void method_2907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->myname)();
}

static  void method_2908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalRespCorr> > >)((((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalRespCorr>*)o)->getAllContainers)();
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalRespCorr>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalRespCorr> -------------------------------
void __HcalCondObjectContainer_HcalRespCorr__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalRespCorr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalRespCorr__datamem_bld(&__HcalCondObjectContainer_HcalRespCorr__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalRespCorr__funcmem_bld(&__HcalCondObjectContainer_HcalRespCorr__db_funcmem);
void __HcalCondObjectContainer_HcalRespCorr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalRespCorr>"), typeid(::HcalCondObjectContainer<HcalRespCorr>), sizeof(::HcalCondObjectContainer<HcalRespCorr>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalRespCorr>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2097, Reflex::Literal("HcalCondObjectContainer<HcalRespCorr>::tHcalCont"))
  .AddTypedef(type_1893, Reflex::Literal("HcalCondObjectContainer<HcalRespCorr>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9987, type_9988), Reflex::Literal("operator="), operator_2899, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9988), Reflex::Literal("HcalCondObjectContainer"), constructor_2900, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2901, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2902, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalRespCorr__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalRespCorr__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalRespCorr> -------------------
void __HcalCondObjectContainer_HcalRespCorr__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1865, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRespCorr_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1865, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRespCorr_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1865, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRespCorr_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1865, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRespCorr_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1865, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRespCorr_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1865, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRespCorr_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1865, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRespCorr_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1865, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalRespCorr_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalRespCorr> -------------------
void __HcalCondObjectContainer_HcalRespCorr__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6424, type_1488, type_2461), Reflex::Literal("getValues"), method_2903, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2904, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6428), Reflex::Literal("addValues"), method_2905, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2907, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1893c), Reflex::Literal("getAllContainers"), method_2908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalZSThreshold -------------------------------
static void destructor_3385(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalZSThreshold*)o)->::HcalZSThreshold::~HcalZSThreshold)();
}
static  void operator_3386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalZSThreshold*)o)->operator=)(*(const ::HcalZSThreshold*)arg[0]);
  else   (((::HcalZSThreshold*)o)->operator=)(*(const ::HcalZSThreshold*)arg[0]);
}

static void constructor_3387( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZSThreshold(*(const ::HcalZSThreshold*)arg[0]);
  else ::new(mem) ::HcalZSThreshold(*(const ::HcalZSThreshold*)arg[0]);
}

static void constructor_3388( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZSThreshold();
  else ::new(mem) ::HcalZSThreshold();
}

static void constructor_3389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZSThreshold(*(unsigned long*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::HcalZSThreshold(*(unsigned long*)arg[0],
      *(int*)arg[1]);
}

static  void method_3390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalZSThreshold*)o)->rawId)());
  else   (((const ::HcalZSThreshold*)o)->rawId)();
}

static  void method_3391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalZSThreshold*)o)->getValue)());
  else   (((const ::HcalZSThreshold*)o)->getValue)();
}

static void method_newdel_530( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalZSThreshold >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalZSThreshold >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalZSThreshold >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalZSThreshold >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalZSThreshold >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalZSThreshold -------------------------------
void __HcalZSThreshold_db_datamem(Reflex::Class*);
void __HcalZSThreshold_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalZSThreshold_datamem_bld(&__HcalZSThreshold_db_datamem);
Reflex::GenreflexMemberBuilder __HcalZSThreshold_funcmem_bld(&__HcalZSThreshold_db_funcmem);
void __HcalZSThreshold_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalZSThreshold"), typeid(::HcalZSThreshold), sizeof(::HcalZSThreshold), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalZSThreshold"), destructor_3385, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6491, type_6493), Reflex::Literal("operator="), operator_3386, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6493), Reflex::Literal("HcalZSThreshold"), constructor_3387, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalZSThreshold"), constructor_3388, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_101), Reflex::Literal("HcalZSThreshold"), constructor_3389, 0, "fid;level", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_530, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalZSThreshold_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalZSThreshold_funcmem_bld);
}

//------Delayed data member builder for class HcalZSThreshold -------------------
void __HcalZSThreshold_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalZSThreshold, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("mLevel"), OffsetOf(__shadow__::__HcalZSThreshold, mLevel), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalZSThreshold -------------------
void __HcalZSThreshold_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_3390, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("getValue"), method_3391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalZSThreshold> -------------------------------
static  void operator_2920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalZSThreshold>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalZSThreshold>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalZSThreshold>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalZSThreshold>*)arg[0]);
}

static void constructor_2921( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalZSThreshold>(*(const ::HcalCondObjectContainer<HcalZSThreshold>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalZSThreshold>(*(const ::HcalCondObjectContainer<HcalZSThreshold>*)arg[0]);
}

static void constructor_2922( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalZSThreshold>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalZSThreshold>((const ::HcalTopology*)arg[0]);
}

static void destructor_2923(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalZSThreshold>*)o)->::HcalCondObjectContainer<HcalZSThreshold>::~HcalCondObjectContainer)();
}
static  void method_2924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalZSThreshold>*)o)->addValues)(*(const ::HcalZSThreshold*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalZSThreshold>*)o)->addValues)(*(const ::HcalZSThreshold*)arg[0]);
}

static  void method_2927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->getAllChannels)();
}

static  void method_2928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->myname)();
}

static  void method_2929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalZSThreshold> > >)((((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalZSThreshold>*)o)->getAllContainers)();
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalZSThreshold>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalZSThreshold> -------------------------------
void __HcalCondObjectContainer_HcalZSThreshold__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalZSThreshold__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalZSThreshold__datamem_bld(&__HcalCondObjectContainer_HcalZSThreshold__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalZSThreshold__funcmem_bld(&__HcalCondObjectContainer_HcalZSThreshold__db_funcmem);
void __HcalCondObjectContainer_HcalZSThreshold__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalZSThreshold>"), typeid(::HcalCondObjectContainer<HcalZSThreshold>), sizeof(::HcalCondObjectContainer<HcalZSThreshold>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalZSThreshold>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2098, Reflex::Literal("HcalCondObjectContainer<HcalZSThreshold>::tHcalCont"))
  .AddTypedef(type_1894, Reflex::Literal("HcalCondObjectContainer<HcalZSThreshold>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9990, type_9991), Reflex::Literal("operator="), operator_2920, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9991), Reflex::Literal("HcalCondObjectContainer"), constructor_2921, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2922, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2923, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalZSThreshold__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalZSThreshold__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalZSThreshold> -------------------
void __HcalCondObjectContainer_HcalZSThreshold__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1866, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalZSThreshold_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1866, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalZSThreshold_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1866, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalZSThreshold_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1866, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalZSThreshold_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1866, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalZSThreshold_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1866, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalZSThreshold_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1866, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalZSThreshold_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1866, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalZSThreshold_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalZSThreshold> -------------------
void __HcalCondObjectContainer_HcalZSThreshold__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6489, type_1488, type_2461), Reflex::Literal("getValues"), method_2924, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2925, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6493), Reflex::Literal("addValues"), method_2926, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2928, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1894c), Reflex::Literal("getAllContainers"), method_2929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalChannelStatus -------------------------------
static void destructor_4198(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalChannelStatus*)o)->::HcalChannelStatus::~HcalChannelStatus)();
}
static  void operator_4199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalChannelStatus*)o)->operator=)(*(const ::HcalChannelStatus*)arg[0]);
  else   (((::HcalChannelStatus*)o)->operator=)(*(const ::HcalChannelStatus*)arg[0]);
}

static void constructor_4200( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalChannelStatus(*(const ::HcalChannelStatus*)arg[0]);
  else ::new(mem) ::HcalChannelStatus(*(const ::HcalChannelStatus*)arg[0]);
}

static void constructor_4201( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalChannelStatus();
  else ::new(mem) ::HcalChannelStatus();
}

static void constructor_4202( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalChannelStatus(*(unsigned long*)arg[0],
      *(::uint32_t*)arg[1]);
  else ::new(mem) ::HcalChannelStatus(*(unsigned long*)arg[0],
      *(::uint32_t*)arg[1]);
}

static  void method_4203( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalChannelStatus*)o)->setValue)(*(::uint32_t*)arg[0]);
}

static  void method_4204( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalChannelStatus*)o)->setBit)(*(unsigned int*)arg[0]);
}

static  void method_4205( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalChannelStatus*)o)->unsetBit)(*(unsigned int*)arg[0]);
}

static  void method_4206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalChannelStatus*)o)->isBitSet)(*(unsigned int*)arg[0]));
  else   (((const ::HcalChannelStatus*)o)->isBitSet)(*(unsigned int*)arg[0]);
}

static  void method_4207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalChannelStatus*)o)->rawId)());
  else   (((const ::HcalChannelStatus*)o)->rawId)();
}

static  void method_4208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalChannelStatus*)o)->getValue)());
  else   (((const ::HcalChannelStatus*)o)->getValue)();
}

static void method_newdel_1391( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalChannelStatus >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalChannelStatus >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalChannelStatus >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalChannelStatus >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalChannelStatus >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalChannelStatus -------------------------------
void __HcalChannelStatus_db_datamem(Reflex::Class*);
void __HcalChannelStatus_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalChannelStatus_datamem_bld(&__HcalChannelStatus_db_datamem);
Reflex::GenreflexMemberBuilder __HcalChannelStatus_funcmem_bld(&__HcalChannelStatus_db_funcmem);
void __HcalChannelStatus_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalChannelStatus"), typeid(::HcalChannelStatus), sizeof(::HcalChannelStatus), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("HcalChannelStatus::StatusBit"), Reflex::Literal("HcalCellOff=0;HcalCellMask=1;HcalCellDead=5;HcalCellHot=6;HcalCellStabErr=7;HcalCellTimErr=8;HcalCellExcludeFromHBHENoiseSummary=9;HcalCellExcludeFromHBHENoiseSummaryR45=10;HcalBadLaserSignal=11;HcalCellTrigMask=15;HcalCellCaloTowerMask=18;HcalCellCaloTowerProb=19"), &typeid(HcalChannelStatus::StatusBit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalChannelStatus"), destructor_4198, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6556, type_6558), Reflex::Literal("operator="), operator_4199, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6558), Reflex::Literal("HcalChannelStatus"), constructor_4200, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalChannelStatus"), constructor_4201, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_370), Reflex::Literal("HcalChannelStatus"), constructor_4202, 0, "fid;status", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1391, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalChannelStatus_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalChannelStatus_funcmem_bld);
}

//------Delayed data member builder for class HcalChannelStatus -------------------
void __HcalChannelStatus_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalChannelStatus, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("mStatus"), OffsetOf(__shadow__::__HcalChannelStatus, mStatus), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalChannelStatus -------------------
void __HcalChannelStatus_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_370), Reflex::Literal("setValue"), method_4203, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_43), Reflex::Literal("setBit"), method_4204, 0, "bitnumber", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_43), Reflex::Literal("unsetBit"), method_4205, 0, "bitnumber", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_43), Reflex::Literal("isBitSet"), method_4206, 0, "bitnumber", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_4207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("getValue"), method_4208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalChannelStatus> -------------------------------
static  void operator_2941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalChannelStatus>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalChannelStatus>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalChannelStatus>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalChannelStatus>*)arg[0]);
}

static void constructor_2942( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalChannelStatus>(*(const ::HcalCondObjectContainer<HcalChannelStatus>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalChannelStatus>(*(const ::HcalCondObjectContainer<HcalChannelStatus>*)arg[0]);
}

static void constructor_2943( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalChannelStatus>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalChannelStatus>((const ::HcalTopology*)arg[0]);
}

static void destructor_2944(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalChannelStatus>*)o)->::HcalCondObjectContainer<HcalChannelStatus>::~HcalCondObjectContainer)();
}
static  void method_2945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalChannelStatus>*)o)->addValues)(*(const ::HcalChannelStatus*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalChannelStatus>*)o)->addValues)(*(const ::HcalChannelStatus*)arg[0]);
}

static  void method_2948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->getAllChannels)();
}

static  void method_2949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->myname)();
}

static  void method_2950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalChannelStatus> > >)((((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalChannelStatus>*)o)->getAllContainers)();
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalChannelStatus>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalChannelStatus> -------------------------------
void __HcalCondObjectContainer_HcalChannelStatus__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalChannelStatus__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalChannelStatus__datamem_bld(&__HcalCondObjectContainer_HcalChannelStatus__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalChannelStatus__funcmem_bld(&__HcalCondObjectContainer_HcalChannelStatus__db_funcmem);
void __HcalCondObjectContainer_HcalChannelStatus__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalChannelStatus>"), typeid(::HcalCondObjectContainer<HcalChannelStatus>), sizeof(::HcalCondObjectContainer<HcalChannelStatus>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalChannelStatus>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2099, Reflex::Literal("HcalCondObjectContainer<HcalChannelStatus>::tHcalCont"))
  .AddTypedef(type_1899, Reflex::Literal("HcalCondObjectContainer<HcalChannelStatus>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9993, type_9994), Reflex::Literal("operator="), operator_2941, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9994), Reflex::Literal("HcalCondObjectContainer"), constructor_2942, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2943, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2944, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalChannelStatus__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalChannelStatus__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalChannelStatus> -------------------
void __HcalCondObjectContainer_HcalChannelStatus__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1867, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalChannelStatus_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1867, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalChannelStatus_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1867, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalChannelStatus_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1867, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalChannelStatus_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1867, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalChannelStatus_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1867, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalChannelStatus_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1867, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalChannelStatus_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1867, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalChannelStatus_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalChannelStatus> -------------------
void __HcalCondObjectContainer_HcalChannelStatus__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6554, type_1488, type_2461), Reflex::Literal("getValues"), method_2945, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2946, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6558), Reflex::Literal("addValues"), method_2947, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2949, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1899c), Reflex::Literal("getAllContainers"), method_2950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCalibrationQIECoder -------------------------------
static void destructor_4096(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCalibrationQIECoder*)o)->::HcalCalibrationQIECoder::~HcalCalibrationQIECoder)();
}
static  void operator_4097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCalibrationQIECoder*)o)->operator=)(*(const ::HcalCalibrationQIECoder*)arg[0]);
  else   (((::HcalCalibrationQIECoder*)o)->operator=)(*(const ::HcalCalibrationQIECoder*)arg[0]);
}

static void constructor_4098( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibrationQIECoder(*(const ::HcalCalibrationQIECoder*)arg[0]);
  else ::new(mem) ::HcalCalibrationQIECoder(*(const ::HcalCalibrationQIECoder*)arg[0]);
}

static void constructor_4099( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibrationQIECoder();
  else ::new(mem) ::HcalCalibrationQIECoder();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibrationQIECoder(*(unsigned long*)arg[0]);
  else ::new(mem) ::HcalCalibrationQIECoder(*(unsigned long*)arg[0]);
  }
}

static  void method_4100( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalCalibrationQIECoder*)o)->charge)(*(const unsigned int*)arg[0]));
  else   (((const ::HcalCalibrationQIECoder*)o)->charge)(*(const unsigned int*)arg[0]);
}

static  void method_4101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::HcalCalibrationQIECoder*)o)->adc)(*(const float*)arg[0]));
  else   (((const ::HcalCalibrationQIECoder*)o)->adc)(*(const float*)arg[0]);
}

static  void method_4102( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalCalibrationQIECoder*)o)->minCharge)(*(unsigned int*)arg[0]));
  else   (((const ::HcalCalibrationQIECoder*)o)->minCharge)(*(unsigned int*)arg[0]);
}

static  void method_4103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCalibrationQIECoder*)o)->minCharges)());
  else   (((const ::HcalCalibrationQIECoder*)o)->minCharges)();
}

static  void method_4104( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalCalibrationQIECoder*)o)->setMinCharge)(*(unsigned int*)arg[0],
    *(float*)arg[1]);
}

static  void method_4105( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalCalibrationQIECoder*)o)->setMinCharges)((const float*)arg[0]);
}

static  void method_4106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalCalibrationQIECoder*)o)->rawId)());
  else   (((const ::HcalCalibrationQIECoder*)o)->rawId)();
}

static void constructor_x36( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibrationQIECoder();
  else ::new(mem) ::HcalCalibrationQIECoder();
}

static void method_newdel_1252( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalCalibrationQIECoder >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalCalibrationQIECoder >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalCalibrationQIECoder >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalCalibrationQIECoder >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalCalibrationQIECoder >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalCalibrationQIECoder -------------------------------
void __HcalCalibrationQIECoder_db_datamem(Reflex::Class*);
void __HcalCalibrationQIECoder_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCalibrationQIECoder_datamem_bld(&__HcalCalibrationQIECoder_db_datamem);
Reflex::GenreflexMemberBuilder __HcalCalibrationQIECoder_funcmem_bld(&__HcalCalibrationQIECoder_db_funcmem);
void __HcalCalibrationQIECoder_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCalibrationQIECoder"), typeid(::HcalCalibrationQIECoder), sizeof(::HcalCalibrationQIECoder), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCalibrationQIECoder"), destructor_4096, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6751, type_6753), Reflex::Literal("operator="), operator_4097, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6753), Reflex::Literal("HcalCalibrationQIECoder"), constructor_4098, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18), Reflex::Literal("HcalCalibrationQIECoder"), constructor_4099, 0, "fId=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalCalibrationQIECoder"), constructor_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1252, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCalibrationQIECoder_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCalibrationQIECoder_funcmem_bld);
}

//------Delayed data member builder for class HcalCalibrationQIECoder -------------------
void __HcalCalibrationQIECoder_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin0"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin0), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin1"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin1), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin2"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin2), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin3"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin3), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin4"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin4), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin5"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin5), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin6"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin6), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin7"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin7), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin8"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin8), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin9"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin9), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin10"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin10), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin11"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin11), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin12"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin12), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin13"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin13), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin14"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin14), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin15"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin15), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin16"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin16), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin17"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin17), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin18"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin18), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin19"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin19), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin20"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin20), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin21"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin21), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin22"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin22), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin23"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin23), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin24"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin24), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin25"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin25), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin26"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin26), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin27"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin27), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin28"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin28), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin29"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin29), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin30"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin30), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("bin31"), OffsetOf(__shadow__::__HcalCalibrationQIECoder, bin31), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalCalibrationQIECoder -------------------
void __HcalCalibrationQIECoder_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_43c), Reflex::Literal("charge"), method_4100, 0, "fAdc", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_43, type_1181c), Reflex::Literal("adc"), method_4101, 0, "fCharge", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_43), Reflex::Literal("minCharge"), method_4102, 0, "fBin", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7462), Reflex::Literal("minCharges"), method_4103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_43, type_1181), Reflex::Literal("setMinCharge"), method_4104, 0, "fBin;fValue", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_7462), Reflex::Literal("setMinCharges"), method_4105, 0, "fValue", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_4106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalCalibrationQIECoder> -------------------------------
static  void operator_2962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)arg[0]);
}

static void constructor_2963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalCalibrationQIECoder>(*(const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalCalibrationQIECoder>(*(const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)arg[0]);
}

static void constructor_2964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalCalibrationQIECoder>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalCalibrationQIECoder>((const ::HcalTopology*)arg[0]);
}

static void destructor_2965(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->::HcalCondObjectContainer<HcalCalibrationQIECoder>::~HcalCondObjectContainer)();
}
static  void method_2966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2968( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->addValues)(*(const ::HcalCalibrationQIECoder*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->addValues)(*(const ::HcalCalibrationQIECoder*)arg[0]);
}

static  void method_2969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->getAllChannels)();
}

static  void method_2970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->myname)();
}

static  void method_2971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalCalibrationQIECoder> > >)((((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalCalibrationQIECoder>*)o)->getAllContainers)();
}

static void method_x38( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalCalibrationQIECoder>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalCalibrationQIECoder> -------------------------------
void __HcalCondObjectContainer_HcalCalibrationQIECoder__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalCalibrationQIECoder__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalCalibrationQIECoder__datamem_bld(&__HcalCondObjectContainer_HcalCalibrationQIECoder__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalCalibrationQIECoder__funcmem_bld(&__HcalCondObjectContainer_HcalCalibrationQIECoder__db_funcmem);
void __HcalCondObjectContainer_HcalCalibrationQIECoder__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalCalibrationQIECoder>"), typeid(::HcalCondObjectContainer<HcalCalibrationQIECoder>), sizeof(::HcalCondObjectContainer<HcalCalibrationQIECoder>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalCalibrationQIECoder>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2100, Reflex::Literal("HcalCondObjectContainer<HcalCalibrationQIECoder>::tHcalCont"))
  .AddTypedef(type_1900, Reflex::Literal("HcalCondObjectContainer<HcalCalibrationQIECoder>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9996, type_9997), Reflex::Literal("operator="), operator_2962, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9997), Reflex::Literal("HcalCondObjectContainer"), constructor_2963, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2964, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2965, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x38, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalCalibrationQIECoder__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalCalibrationQIECoder__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalCalibrationQIECoder> -------------------
void __HcalCondObjectContainer_HcalCalibrationQIECoder__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1870, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalCalibrationQIECoder_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1870, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalCalibrationQIECoder_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1870, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalCalibrationQIECoder_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1870, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalCalibrationQIECoder_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1870, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalCalibrationQIECoder_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1870, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalCalibrationQIECoder_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1870, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalCalibrationQIECoder_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1870, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalCalibrationQIECoder_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalCalibrationQIECoder> -------------------
void __HcalCondObjectContainer_HcalCalibrationQIECoder__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6749, type_1488, type_2461), Reflex::Literal("getValues"), method_2966, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2967, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6753), Reflex::Literal("addValues"), method_2968, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2970, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1900c), Reflex::Literal("getAllContainers"), method_2971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalQIECoder> -------------------------------
static  void operator_2983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalQIECoder>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalQIECoder>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalQIECoder>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalQIECoder>*)arg[0]);
}

static void constructor_2984( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalQIECoder>(*(const ::HcalCondObjectContainer<HcalQIECoder>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalQIECoder>(*(const ::HcalCondObjectContainer<HcalQIECoder>*)arg[0]);
}

static void constructor_2985( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalQIECoder>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalQIECoder>((const ::HcalTopology*)arg[0]);
}

static void destructor_2986(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalQIECoder>*)o)->::HcalCondObjectContainer<HcalQIECoder>::~HcalCondObjectContainer)();
}
static  void method_2987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_2988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_2989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalQIECoder>*)o)->addValues)(*(const ::HcalQIECoder*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalQIECoder>*)o)->addValues)(*(const ::HcalQIECoder*)arg[0]);
}

static  void method_2990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->getAllChannels)();
}

static  void method_2991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->myname)();
}

static  void method_2992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalQIECoder> > >)((((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalQIECoder>*)o)->getAllContainers)();
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalQIECoder>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalQIECoder> -------------------------------
void __HcalCondObjectContainer_HcalQIECoder__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalQIECoder__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalQIECoder__datamem_bld(&__HcalCondObjectContainer_HcalQIECoder__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalQIECoder__funcmem_bld(&__HcalCondObjectContainer_HcalQIECoder__db_funcmem);
void __HcalCondObjectContainer_HcalQIECoder__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalQIECoder>"), typeid(::HcalCondObjectContainer<HcalQIECoder>), sizeof(::HcalCondObjectContainer<HcalQIECoder>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalQIECoder>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2101, Reflex::Literal("HcalCondObjectContainer<HcalQIECoder>::tHcalCont"))
  .AddTypedef(type_1901, Reflex::Literal("HcalCondObjectContainer<HcalQIECoder>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9999, type_10000), Reflex::Literal("operator="), operator_2983, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10000), Reflex::Literal("HcalCondObjectContainer"), constructor_2984, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_2985, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_2986, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalQIECoder__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalQIECoder__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalQIECoder> -------------------
void __HcalCondObjectContainer_HcalQIECoder__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1871, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalQIECoder_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1871, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalQIECoder_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1871, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalQIECoder_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1871, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalQIECoder_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1871, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalQIECoder_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1871, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalQIECoder_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1871, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalQIECoder_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1871, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalQIECoder_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalQIECoder> -------------------
void __HcalCondObjectContainer_HcalQIECoder__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6814, type_1488, type_2461), Reflex::Literal("getValues"), method_2987, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_2988, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6818), Reflex::Literal("addValues"), method_2989, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_2990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_2991, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1901c), Reflex::Literal("getAllContainers"), method_2992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalGainWidth> -------------------------------
static  void operator_3004( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalGainWidth>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalGainWidth>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalGainWidth>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalGainWidth>*)arg[0]);
}

static void constructor_3005( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalGainWidth>(*(const ::HcalCondObjectContainer<HcalGainWidth>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalGainWidth>(*(const ::HcalCondObjectContainer<HcalGainWidth>*)arg[0]);
}

static void constructor_3006( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalGainWidth>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalGainWidth>((const ::HcalTopology*)arg[0]);
}

static void destructor_3007(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalGainWidth>*)o)->::HcalCondObjectContainer<HcalGainWidth>::~HcalCondObjectContainer)();
}
static  void method_3008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_3009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_3010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalGainWidth>*)o)->addValues)(*(const ::HcalGainWidth*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalGainWidth>*)o)->addValues)(*(const ::HcalGainWidth*)arg[0]);
}

static  void method_3011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->getAllChannels)();
}

static  void method_3012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->myname)();
}

static  void method_3013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalGainWidth> > >)((((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalGainWidth>*)o)->getAllContainers)();
}

static void method_x40( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalGainWidth>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalGainWidth> -------------------------------
void __HcalCondObjectContainer_HcalGainWidth__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalGainWidth__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalGainWidth__datamem_bld(&__HcalCondObjectContainer_HcalGainWidth__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalGainWidth__funcmem_bld(&__HcalCondObjectContainer_HcalGainWidth__db_funcmem);
void __HcalCondObjectContainer_HcalGainWidth__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalGainWidth>"), typeid(::HcalCondObjectContainer<HcalGainWidth>), sizeof(::HcalCondObjectContainer<HcalGainWidth>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalGainWidth>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2102, Reflex::Literal("HcalCondObjectContainer<HcalGainWidth>::tHcalCont"))
  .AddTypedef(type_1903, Reflex::Literal("HcalCondObjectContainer<HcalGainWidth>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10002, type_10003), Reflex::Literal("operator="), operator_3004, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10003), Reflex::Literal("HcalCondObjectContainer"), constructor_3005, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_3006, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_3007, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalGainWidth__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalGainWidth__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalGainWidth> -------------------
void __HcalCondObjectContainer_HcalGainWidth__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1872, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGainWidth_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1872, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGainWidth_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1872, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGainWidth_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1872, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGainWidth_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1872, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGainWidth_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1872, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGainWidth_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1872, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGainWidth_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1872, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGainWidth_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalGainWidth> -------------------
void __HcalCondObjectContainer_HcalGainWidth__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6879, type_1488, type_2461), Reflex::Literal("getValues"), method_3008, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_3009, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6883), Reflex::Literal("addValues"), method_3010, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_3011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_3012, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1903c), Reflex::Literal("getAllContainers"), method_3013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalGain -------------------------------
static void destructor_4186(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalGain*)o)->::HcalGain::~HcalGain)();
}
static  void operator_4187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalGain*)o)->operator=)(*(const ::HcalGain*)arg[0]);
  else   (((::HcalGain*)o)->operator=)(*(const ::HcalGain*)arg[0]);
}

static void constructor_4188( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGain(*(const ::HcalGain*)arg[0]);
  else ::new(mem) ::HcalGain(*(const ::HcalGain*)arg[0]);
}

static  void method_4189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalGain*)o)->getValues)());
  else   (((const ::HcalGain*)o)->getValues)();
}

static  void method_4190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalGain*)o)->getValue)(*(int*)arg[0]));
  else   (((const ::HcalGain*)o)->getValue)(*(int*)arg[0]);
}

static void constructor_4191( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGain();
  else ::new(mem) ::HcalGain();
}

static void constructor_4192( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGain(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
  else ::new(mem) ::HcalGain(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
}

static  void method_4193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalGain*)o)->rawId)());
  else   (((const ::HcalGain*)o)->rawId)();
}

static void method_newdel_1357( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalGain >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalGain >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalGain >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalGain >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalGain >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalGain -------------------------------
void __HcalGain_db_datamem(Reflex::Class*);
void __HcalGain_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalGain_datamem_bld(&__HcalGain_db_datamem);
Reflex::GenreflexMemberBuilder __HcalGain_funcmem_bld(&__HcalGain_db_funcmem);
void __HcalGain_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalGain"), typeid(::HcalGain), sizeof(::HcalGain), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalGain"), destructor_4186, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6946, type_6948), Reflex::Literal("operator="), operator_4187, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6948), Reflex::Literal("HcalGain"), constructor_4188, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalGain"), constructor_4191, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1181, type_1181, type_1181, type_1181), Reflex::Literal("HcalGain"), constructor_4192, 0, "fId;fCap0;fCap1;fCap2;fCap3", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1357, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalGain_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalGain_funcmem_bld);
}

//------Delayed data member builder for class HcalGain -------------------
void __HcalGain_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalGain, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue0"), OffsetOf(__shadow__::__HcalGain, mValue0), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue1"), OffsetOf(__shadow__::__HcalGain, mValue1), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue2"), OffsetOf(__shadow__::__HcalGain, mValue2), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue3"), OffsetOf(__shadow__::__HcalGain, mValue3), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalGain -------------------
void __HcalGain_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7462), Reflex::Literal("getValues"), method_4189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_101), Reflex::Literal("getValue"), method_4190, 0, "fCapId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_4193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalGain> -------------------------------
static  void operator_3025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalGain>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalGain>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalGain>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalGain>*)arg[0]);
}

static void constructor_3026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalGain>(*(const ::HcalCondObjectContainer<HcalGain>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalGain>(*(const ::HcalCondObjectContainer<HcalGain>*)arg[0]);
}

static void constructor_3027( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalGain>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalGain>((const ::HcalTopology*)arg[0]);
}

static void destructor_3028(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalGain>*)o)->::HcalCondObjectContainer<HcalGain>::~HcalCondObjectContainer)();
}
static  void method_3029( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalGain>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalGain>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalGain>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalGain>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_3030( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalGain>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalGain>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_3031( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalGain>*)o)->addValues)(*(const ::HcalGain*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalGain>*)o)->addValues)(*(const ::HcalGain*)arg[0]);
}

static  void method_3032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalGain>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalGain>*)o)->getAllChannels)();
}

static  void method_3033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalGain>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalGain>*)o)->myname)();
}

static  void method_3034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalGain> > >)((((const ::HcalCondObjectContainer<HcalGain>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalGain>*)o)->getAllContainers)();
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalGain>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalGain> -------------------------------
void __HcalCondObjectContainer_HcalGain__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalGain__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalGain__datamem_bld(&__HcalCondObjectContainer_HcalGain__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalGain__funcmem_bld(&__HcalCondObjectContainer_HcalGain__db_funcmem);
void __HcalCondObjectContainer_HcalGain__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalGain>"), typeid(::HcalCondObjectContainer<HcalGain>), sizeof(::HcalCondObjectContainer<HcalGain>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalGain>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2103, Reflex::Literal("HcalCondObjectContainer<HcalGain>::tHcalCont"))
  .AddTypedef(type_1905, Reflex::Literal("HcalCondObjectContainer<HcalGain>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10005, type_10006), Reflex::Literal("operator="), operator_3025, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10006), Reflex::Literal("HcalCondObjectContainer"), constructor_3026, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_3027, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_3028, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalGain__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalGain__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalGain> -------------------
void __HcalCondObjectContainer_HcalGain__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1873, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGain_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1873, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGain_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1873, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGain_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1873, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGain_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1873, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGain_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1873, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGain_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1873, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGain_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1873, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalGain_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalGain> -------------------
void __HcalCondObjectContainer_HcalGain__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6944, type_1488, type_2461), Reflex::Literal("getValues"), method_3029, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_3030, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6948), Reflex::Literal("addValues"), method_3031, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_3032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_3033, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1905c), Reflex::Literal("getAllContainers"), method_3034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalPedestalWidth -------------------------------
static void destructor_3468(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalPedestalWidth*)o)->::HcalPedestalWidth::~HcalPedestalWidth)();
}
static  void operator_3469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalPedestalWidth*)o)->operator=)(*(const ::HcalPedestalWidth*)arg[0]);
  else   (((::HcalPedestalWidth*)o)->operator=)(*(const ::HcalPedestalWidth*)arg[0]);
}

static void constructor_3470( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestalWidth(*(const ::HcalPedestalWidth*)arg[0]);
  else ::new(mem) ::HcalPedestalWidth(*(const ::HcalPedestalWidth*)arg[0]);
}

static  void method_3471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalPedestalWidth*)o)->getValues)());
  else   (((const ::HcalPedestalWidth*)o)->getValues)();
}

static  void method_3472( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalPedestalWidth*)o)->getWidth)(*(int*)arg[0]));
  else   (((const ::HcalPedestalWidth*)o)->getWidth)(*(int*)arg[0]);
}

static  void method_3473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalPedestalWidth*)o)->getSigma)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::HcalPedestalWidth*)o)->getSigma)(*(int*)arg[0],
    *(int*)arg[1]);
}

static void constructor_3474( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestalWidth();
  else ::new(mem) ::HcalPedestalWidth();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestalWidth(*(int*)arg[0]);
  else ::new(mem) ::HcalPedestalWidth(*(int*)arg[0]);
  }
}

static  void method_3475( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalPedestalWidth*)o)->setSigma)(*(int*)arg[0],
    *(int*)arg[1],
    *(float*)arg[2]);
}

static  void method_3476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalPedestalWidth*)o)->rawId)());
  else   (((const ::HcalPedestalWidth*)o)->rawId)();
}

static void constructor_x43( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestalWidth();
  else ::new(mem) ::HcalPedestalWidth();
}

static void method_newdel_716( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalPedestalWidth >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalPedestalWidth >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalPedestalWidth >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalPedestalWidth >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalPedestalWidth >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalPedestalWidth -------------------------------
void __HcalPedestalWidth_db_datamem(Reflex::Class*);
void __HcalPedestalWidth_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalPedestalWidth_datamem_bld(&__HcalPedestalWidth_db_datamem);
Reflex::GenreflexMemberBuilder __HcalPedestalWidth_funcmem_bld(&__HcalPedestalWidth_db_funcmem);
void __HcalPedestalWidth_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalPedestalWidth"), typeid(::HcalPedestalWidth), sizeof(::HcalPedestalWidth), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalPedestalWidth"), destructor_3468, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7011, type_7013), Reflex::Literal("operator="), operator_3469, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7013), Reflex::Literal("HcalPedestalWidth"), constructor_3470, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_101), Reflex::Literal("HcalPedestalWidth"), constructor_3474, 0, "fId=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalPedestalWidth"), constructor_x43, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_716, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalPedestalWidth_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalPedestalWidth_funcmem_bld);
}

//------Delayed data member builder for class HcalPedestalWidth -------------------
void __HcalPedestalWidth_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalPedestalWidth, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma00"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma00), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma01"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma01), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma02"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma02), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma03"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma03), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma10"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma10), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma11"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma11), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma12"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma12), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma13"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma13), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma20"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma20), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma21"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma21), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma22"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma22), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma23"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma23), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma30"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma30), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma31"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma31), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma32"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma32), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mSigma33"), OffsetOf(__shadow__::__HcalPedestalWidth, mSigma33), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalPedestalWidth -------------------
void __HcalPedestalWidth_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7462), Reflex::Literal("getValues"), method_3471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_101), Reflex::Literal("getWidth"), method_3472, 0, "fCapId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_101, type_101), Reflex::Literal("getSigma"), method_3473, 0, "fCapId1;fCapId2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_101, type_101, type_1181), Reflex::Literal("setSigma"), method_3475, 0, "fCapId1;fCapId2;fSigma", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_3476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalPedestalWidth> -------------------------------
static  void operator_3046( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalPedestalWidth>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalPedestalWidth>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalPedestalWidth>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalPedestalWidth>*)arg[0]);
}

static void constructor_3047( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalPedestalWidth>(*(const ::HcalCondObjectContainer<HcalPedestalWidth>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalPedestalWidth>(*(const ::HcalCondObjectContainer<HcalPedestalWidth>*)arg[0]);
}

static void constructor_3048( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalPedestalWidth>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalPedestalWidth>((const ::HcalTopology*)arg[0]);
}

static void destructor_3049(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalPedestalWidth>*)o)->::HcalCondObjectContainer<HcalPedestalWidth>::~HcalCondObjectContainer)();
}
static  void method_3050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_3051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_3052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalPedestalWidth>*)o)->addValues)(*(const ::HcalPedestalWidth*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalPedestalWidth>*)o)->addValues)(*(const ::HcalPedestalWidth*)arg[0]);
}

static  void method_3053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->getAllChannels)();
}

static  void method_3054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->myname)();
}

static  void method_3055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalPedestalWidth> > >)((((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalPedestalWidth>*)o)->getAllContainers)();
}

static void method_x45( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalPedestalWidth>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalPedestalWidth> -------------------------------
void __HcalCondObjectContainer_HcalPedestalWidth__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalPedestalWidth__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalPedestalWidth__datamem_bld(&__HcalCondObjectContainer_HcalPedestalWidth__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalPedestalWidth__funcmem_bld(&__HcalCondObjectContainer_HcalPedestalWidth__db_funcmem);
void __HcalCondObjectContainer_HcalPedestalWidth__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalPedestalWidth>"), typeid(::HcalCondObjectContainer<HcalPedestalWidth>), sizeof(::HcalCondObjectContainer<HcalPedestalWidth>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalPedestalWidth>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2104, Reflex::Literal("HcalCondObjectContainer<HcalPedestalWidth>::tHcalCont"))
  .AddTypedef(type_1906, Reflex::Literal("HcalCondObjectContainer<HcalPedestalWidth>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10008, type_10009), Reflex::Literal("operator="), operator_3046, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10009), Reflex::Literal("HcalCondObjectContainer"), constructor_3047, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_3048, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_3049, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x45, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalPedestalWidth__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalPedestalWidth__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalPedestalWidth> -------------------
void __HcalCondObjectContainer_HcalPedestalWidth__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1874, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestalWidth_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1874, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestalWidth_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1874, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestalWidth_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1874, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestalWidth_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1874, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestalWidth_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1874, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestalWidth_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1874, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestalWidth_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1874, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestalWidth_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalPedestalWidth> -------------------
void __HcalCondObjectContainer_HcalPedestalWidth__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7009, type_1488, type_2461), Reflex::Literal("getValues"), method_3050, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_3051, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_7013), Reflex::Literal("addValues"), method_3052, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_3053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_3054, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1906c), Reflex::Literal("getAllContainers"), method_3055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalPedestal -------------------------------
static void destructor_4038(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalPedestal*)o)->::HcalPedestal::~HcalPedestal)();
}
static  void operator_4039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalPedestal*)o)->operator=)(*(const ::HcalPedestal*)arg[0]);
  else   (((::HcalPedestal*)o)->operator=)(*(const ::HcalPedestal*)arg[0]);
}

static void constructor_4040( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestal(*(const ::HcalPedestal*)arg[0]);
  else ::new(mem) ::HcalPedestal(*(const ::HcalPedestal*)arg[0]);
}

static  void method_4041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalPedestal*)o)->getValues)());
  else   (((const ::HcalPedestal*)o)->getValues)();
}

static  void method_4042( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalPedestal*)o)->getValue)(*(int*)arg[0]));
  else   (((const ::HcalPedestal*)o)->getValue)(*(int*)arg[0]);
}

static  void method_4043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalPedestal*)o)->getWidths)());
  else   (((const ::HcalPedestal*)o)->getWidths)();
}

static  void method_4044( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalPedestal*)o)->getWidth)(*(int*)arg[0]));
  else   (((const ::HcalPedestal*)o)->getWidth)(*(int*)arg[0]);
}

static void constructor_4045( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestal();
  else ::new(mem) ::HcalPedestal();
}

static void constructor_4046( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestal(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
  else ::new(mem) ::HcalPedestal(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestal(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4],
      *(float*)arg[5]);
  else ::new(mem) ::HcalPedestal(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4],
      *(float*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestal(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4],
      *(float*)arg[5],
      *(float*)arg[6]);
  else ::new(mem) ::HcalPedestal(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4],
      *(float*)arg[5],
      *(float*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestal(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4],
      *(float*)arg[5],
      *(float*)arg[6],
      *(float*)arg[7]);
  else ::new(mem) ::HcalPedestal(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4],
      *(float*)arg[5],
      *(float*)arg[6],
      *(float*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestal(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4],
      *(float*)arg[5],
      *(float*)arg[6],
      *(float*)arg[7],
      *(float*)arg[8]);
  else ::new(mem) ::HcalPedestal(*(unsigned long*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4],
      *(float*)arg[5],
      *(float*)arg[6],
      *(float*)arg[7],
      *(float*)arg[8]);
  }
}

static  void method_4047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalPedestal*)o)->rawId)());
  else   (((const ::HcalPedestal*)o)->rawId)();
}

static void method_newdel_1230( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalPedestal >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalPedestal >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalPedestal >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalPedestal >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalPedestal >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalPedestal -------------------------------
void __HcalPedestal_db_datamem(Reflex::Class*);
void __HcalPedestal_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalPedestal_datamem_bld(&__HcalPedestal_db_datamem);
Reflex::GenreflexMemberBuilder __HcalPedestal_funcmem_bld(&__HcalPedestal_db_funcmem);
void __HcalPedestal_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalPedestal"), typeid(::HcalPedestal), sizeof(::HcalPedestal), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalPedestal"), destructor_4038, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7076, type_7078), Reflex::Literal("operator="), operator_4039, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7078), Reflex::Literal("HcalPedestal"), constructor_4040, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalPedestal"), constructor_4045, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18, type_1181, type_1181, type_1181, type_1181, type_1181, type_1181, type_1181, type_1181), Reflex::Literal("HcalPedestal"), constructor_4046, 0, "fId;fCap0;fCap1;fCap2;fCap3;wCap0=0;wCap1=0;wCap2=0;wCap3=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1230, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalPedestal_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalPedestal_funcmem_bld);
}

//------Delayed data member builder for class HcalPedestal -------------------
void __HcalPedestal_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalPedestal, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue0"), OffsetOf(__shadow__::__HcalPedestal, mValue0), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue1"), OffsetOf(__shadow__::__HcalPedestal, mValue1), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue2"), OffsetOf(__shadow__::__HcalPedestal, mValue2), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue3"), OffsetOf(__shadow__::__HcalPedestal, mValue3), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mWidth0"), OffsetOf(__shadow__::__HcalPedestal, mWidth0), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mWidth1"), OffsetOf(__shadow__::__HcalPedestal, mWidth1), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mWidth2"), OffsetOf(__shadow__::__HcalPedestal, mWidth2), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mWidth3"), OffsetOf(__shadow__::__HcalPedestal, mWidth3), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalPedestal -------------------
void __HcalPedestal_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7462), Reflex::Literal("getValues"), method_4041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_101), Reflex::Literal("getValue"), method_4042, 0, "fCapId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7462), Reflex::Literal("getWidths"), method_4043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_101), Reflex::Literal("getWidth"), method_4044, 0, "fCapId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_4047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainer<HcalPedestal> -------------------------------
static  void operator_3067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainer<HcalPedestal>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalPedestal>*)arg[0]);
  else   (((::HcalCondObjectContainer<HcalPedestal>*)o)->operator=)(*(const ::HcalCondObjectContainer<HcalPedestal>*)arg[0]);
}

static void constructor_3068( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalPedestal>(*(const ::HcalCondObjectContainer<HcalPedestal>*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalPedestal>(*(const ::HcalCondObjectContainer<HcalPedestal>*)arg[0]);
}

static void constructor_3069( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainer<HcalPedestal>((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainer<HcalPedestal>((const ::HcalTopology*)arg[0]);
}

static void destructor_3070(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainer<HcalPedestal>*)o)->::HcalCondObjectContainer<HcalPedestal>::~HcalCondObjectContainer)();
}
static  void method_3071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalPedestal>*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCondObjectContainer<HcalPedestal>*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainer<HcalPedestal>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCondObjectContainer<HcalPedestal>*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_3072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCondObjectContainer<HcalPedestal>*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCondObjectContainer<HcalPedestal>*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_3073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCondObjectContainer<HcalPedestal>*)o)->addValues)(*(const ::HcalPedestal*)arg[0]));
  else   (((::HcalCondObjectContainer<HcalPedestal>*)o)->addValues)(*(const ::HcalPedestal*)arg[0]);
}

static  void method_3074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCondObjectContainer<HcalPedestal>*)o)->getAllChannels)());
  else   (((const ::HcalCondObjectContainer<HcalPedestal>*)o)->getAllChannels)();
}

static  void method_3075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::HcalCondObjectContainer<HcalPedestal>*)o)->myname)());
  else   (((const ::HcalCondObjectContainer<HcalPedestal>*)o)->myname)();
}

static  void method_3076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,std::vector<HcalPedestal> > >)((((const ::HcalCondObjectContainer<HcalPedestal>*)o)->getAllContainers)());
  else   (((const ::HcalCondObjectContainer<HcalPedestal>*)o)->getAllContainers)();
}

static void method_x47( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalPedestal>,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCondObjectContainer<HcalPedestal> -------------------------------
void __HcalCondObjectContainer_HcalPedestal__db_datamem(Reflex::Class*);
void __HcalCondObjectContainer_HcalPedestal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalPedestal__datamem_bld(&__HcalCondObjectContainer_HcalPedestal__db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainer_HcalPedestal__funcmem_bld(&__HcalCondObjectContainer_HcalPedestal__db_funcmem);
void __HcalCondObjectContainer_HcalPedestal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainer<HcalPedestal>"), typeid(::HcalCondObjectContainer<HcalPedestal>), sizeof(::HcalCondObjectContainer<HcalPedestal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCondObjectContainer<HcalPedestal>, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2105, Reflex::Literal("HcalCondObjectContainer<HcalPedestal>::tHcalCont"))
  .AddTypedef(type_1907, Reflex::Literal("HcalCondObjectContainer<HcalPedestal>::tAllContWithNames"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10011, type_10012), Reflex::Literal("operator="), operator_3067, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10012), Reflex::Literal("HcalCondObjectContainer"), constructor_3068, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCondObjectContainer"), constructor_3069, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainer"), destructor_3070, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x47, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainer_HcalPedestal__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainer_HcalPedestal__funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainer<HcalPedestal> -------------------
void __HcalCondObjectContainer_HcalPedestal__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1875, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestal_, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1875, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestal_, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1875, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestal_, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1875, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestal_, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1875, Reflex::Literal("HTcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestal_, HTcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1875, Reflex::Literal("ZDCcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestal_, ZDCcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1875, Reflex::Literal("CALIBcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestal_, CALIBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1875, Reflex::Literal("CASTORcontainer"), OffsetOf(__shadow__::__HcalCondObjectContainer_HcalPedestal_, CASTORcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCondObjectContainer<HcalPedestal> -------------------
void __HcalCondObjectContainer_HcalPedestal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7074, type_1488, type_2461), Reflex::Literal("getValues"), method_3071, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_3072, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_7078), Reflex::Literal("addValues"), method_3073, 0, "myItem", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_3074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("myname"), method_3075, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1907c), Reflex::Literal("getAllContainers"), method_3076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalDcsMap -------------------------------
static  void operator_3089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalDcsMap*)o)->operator=)(*(const ::HcalDcsMap*)arg[0]);
  else   (((::HcalDcsMap*)o)->operator=)(*(const ::HcalDcsMap*)arg[0]);
}

static void constructor_3090( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsMap(*(const ::HcalDcsMap*)arg[0]);
  else ::new(mem) ::HcalDcsMap(*(const ::HcalDcsMap*)arg[0]);
}

static void constructor_3091( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsMap();
  else ::new(mem) ::HcalDcsMap();
}

static void destructor_3092(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalDcsMap*)o)->::HcalDcsMap::~HcalDcsMap)();
}
static  void method_3093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<HcalDetId>)((((const ::HcalDcsMap*)o)->lookup)(*(::HcalDcsDetId*)arg[0]));
  else   (((const ::HcalDcsMap*)o)->lookup)(*(::HcalDcsDetId*)arg[0]);
}

static  void method_3094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<HcalDcsDetId>)((((const ::HcalDcsMap*)o)->lookup)(*(::HcalDetId*)arg[0],
    *(::HcalDcsDetId::DcsType*)arg[1]));
  else   (((const ::HcalDcsMap*)o)->lookup)(*(::HcalDetId*)arg[0],
    *(::HcalDcsDetId::DcsType*)arg[1]);
}

static  void method_3095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalDcsMap*)o)->mapGeomId2DcsId)(*(::HcalDetId*)arg[0],
    *(::HcalDcsDetId*)arg[1]));
  else   (((::HcalDcsMap*)o)->mapGeomId2DcsId)(*(::HcalDetId*)arg[0],
    *(::HcalDcsDetId*)arg[1]);
}

static  void method_3096( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::HcalDcsMap*)o)->sortById)();
}

static  void method_3097( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::HcalDcsMap*)o)->sortByDcsId)();
}

static  void method_3098( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HcalDcsMap*)o)->sort)();
}

static  void method_3099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HcalDcsMap::const_iterator)((((const ::HcalDcsMap*)o)->beginById)());
  else   (((const ::HcalDcsMap*)o)->beginById)();
}

static  void method_3100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HcalDcsMap::const_iterator)((((const ::HcalDcsMap*)o)->beginByDcsId)());
  else   (((const ::HcalDcsMap*)o)->beginByDcsId)();
}

static  void method_3101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HcalDcsMap::const_iterator)((((const ::HcalDcsMap*)o)->endById)());
  else   (((const ::HcalDcsMap*)o)->endById)();
}

static  void method_3102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HcalDcsMap::const_iterator)((((const ::HcalDcsMap*)o)->endByDcsId)());
  else   (((const ::HcalDcsMap*)o)->endByDcsId)();
}

static void method_newdel_219( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalDcsMap >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalDcsMap >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalDcsMap >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalDcsMap >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalDcsMap >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalDcsMap -------------------------------
void __HcalDcsMap_db_datamem(Reflex::Class*);
void __HcalDcsMap_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalDcsMap_datamem_bld(&__HcalDcsMap_db_datamem);
Reflex::GenreflexMemberBuilder __HcalDcsMap_funcmem_bld(&__HcalDcsMap_db_funcmem);
void __HcalDcsMap_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalDcsMap"), typeid(::HcalDcsMap), sizeof(::HcalDcsMap), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10033, type_10034), Reflex::Literal("operator="), operator_3089, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10034), Reflex::Literal("HcalDcsMap"), constructor_3090, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalDcsMap"), constructor_3091, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalDcsMap"), destructor_3092, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_219, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalDcsMap_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalDcsMap_funcmem_bld);
}

//------Delayed data member builder for class HcalDcsMap -------------------
void __HcalDcsMap_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1855, Reflex::Literal("mItems"), OffsetOf(__shadow__::__HcalDcsMap, mItems), ::Reflex::PROTECTED)
  .AddDataMember(type_1883, Reflex::Literal("mItemsById"), OffsetOf(__shadow__::__HcalDcsMap, mItemsById), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2461, Reflex::Literal("sortedById"), OffsetOf(__shadow__::__HcalDcsMap, sortedById), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1883, Reflex::Literal("mItemsByDcsId"), OffsetOf(__shadow__::__HcalDcsMap, mItemsByDcsId), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2461, Reflex::Literal("sortedByDcsId"), OffsetOf(__shadow__::__HcalDcsMap, sortedByDcsId), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class HcalDcsMap -------------------
void __HcalDcsMap_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1886c, type_360), Reflex::Literal("lookup"), method_3093, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1885c, type_1256, type_3243), Reflex::Literal("lookup"), method_3094, 0, "fId;type", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_1256, type_360), Reflex::Literal("mapGeomId2DcsId"), method_3095, 0, "fId;fDcsId", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("sortById"), method_3096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("sortByDcsId"), method_3097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("sort"), method_3098, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3082), Reflex::Literal("beginById"), method_3099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3082), Reflex::Literal("beginByDcsId"), method_3100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3082), Reflex::Literal("endById"), method_3101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3082), Reflex::Literal("endByDcsId"), method_3102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalPedestalWidths -------------------------------
static  void operator_3144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalPedestalWidths*)o)->operator=)(*(const ::HcalPedestalWidths*)arg[0]);
  else   (((::HcalPedestalWidths*)o)->operator=)(*(const ::HcalPedestalWidths*)arg[0]);
}

static void constructor_3145( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestalWidths(*(const ::HcalPedestalWidths*)arg[0]);
  else ::new(mem) ::HcalPedestalWidths(*(const ::HcalPedestalWidths*)arg[0]);
}

static void constructor_3146( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestalWidths();
  else ::new(mem) ::HcalPedestalWidths();
}

static void constructor_3147( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestalWidths((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalPedestalWidths((const ::HcalTopology*)arg[0]);
}

static void constructor_3148( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestalWidths((const ::HcalTopology*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::HcalPedestalWidths((const ::HcalTopology*)arg[0],
      *(bool*)arg[1]);
}

static  void method_3149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalPedestalWidths*)o)->isADC)());
  else   (((const ::HcalPedestalWidths*)o)->isADC)();
}

static  void method_3150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalPedestalWidths*)o)->setUnitADC)(*(bool*)arg[0]);
}

static  void method_3151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::HcalPedestalWidths*)o)->myname)());
  else   (((::HcalPedestalWidths*)o)->myname)();
}

static void destructor_3152(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalPedestalWidths*)o)->::HcalPedestalWidths::~HcalPedestalWidths)();
}
static void method_newdel_278( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalPedestalWidths >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalPedestalWidths >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalPedestalWidths >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalPedestalWidths >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalPedestalWidths >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalPedestalWidth>")), ::Reflex::BaseOffset< ::HcalPedestalWidths,::HcalCondObjectContainer<HcalPedestalWidth> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalPedestalWidths,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalPedestalWidths -------------------------------
void __HcalPedestalWidths_db_datamem(Reflex::Class*);
void __HcalPedestalWidths_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalPedestalWidths_datamem_bld(&__HcalPedestalWidths_db_datamem);
Reflex::GenreflexMemberBuilder __HcalPedestalWidths_funcmem_bld(&__HcalPedestalWidths_db_funcmem);
void __HcalPedestalWidths_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalPedestalWidths"), typeid(::HcalPedestalWidths), sizeof(::HcalPedestalWidths), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_191, ::Reflex::BaseOffset< ::HcalPedestalWidths, ::HcalCondObjectContainer<HcalPedestalWidth> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10044, type_10045), Reflex::Literal("operator="), operator_3144, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10045), Reflex::Literal("HcalPedestalWidths"), constructor_3145, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalPedestalWidths"), constructor_3146, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalPedestalWidths"), constructor_3147, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860, type_2461), Reflex::Literal("HcalPedestalWidths"), constructor_3148, 0, "topo;isADC", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalPedestalWidths"), destructor_3152, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_278, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalPedestalWidths_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalPedestalWidths_funcmem_bld);
}

//------Delayed data member builder for class HcalPedestalWidths -------------------
void __HcalPedestalWidths_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2461, Reflex::Literal("unitIsADC"), OffsetOf(__shadow__::__HcalPedestalWidths, unitIsADC), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalPedestalWidths -------------------
void __HcalPedestalWidths_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("isADC"), method_3149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2461), Reflex::Literal("setUnitADC"), method_3150, 0, "isADC", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934c), Reflex::Literal("myname"), method_3151, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class HcalL1TriggerObjects -------------------------------
static  void operator_3163( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalL1TriggerObjects*)o)->operator=)(*(const ::HcalL1TriggerObjects*)arg[0]);
  else   (((::HcalL1TriggerObjects*)o)->operator=)(*(const ::HcalL1TriggerObjects*)arg[0]);
}

static void constructor_3164( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalL1TriggerObjects(*(const ::HcalL1TriggerObjects*)arg[0]);
  else ::new(mem) ::HcalL1TriggerObjects(*(const ::HcalL1TriggerObjects*)arg[0]);
}

static void constructor_3165( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalL1TriggerObjects();
  else ::new(mem) ::HcalL1TriggerObjects();
}

static void constructor_3166( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalL1TriggerObjects((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalL1TriggerObjects((const ::HcalTopology*)arg[0]);
}

static  void method_3167( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalL1TriggerObjects*)o)->setTagString)(*(::std::string*)arg[0]);
}

static  void method_3168( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalL1TriggerObjects*)o)->setAlgoString)(*(::std::string*)arg[0]);
}

static  void method_3169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalL1TriggerObjects*)o)->getTagString)());
  else   (((const ::HcalL1TriggerObjects*)o)->getTagString)();
}

static  void method_3170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalL1TriggerObjects*)o)->getAlgoString)());
  else   (((const ::HcalL1TriggerObjects*)o)->getAlgoString)();
}

static  void method_3171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalL1TriggerObjects*)o)->myname)());
  else   (((const ::HcalL1TriggerObjects*)o)->myname)();
}

static void destructor_3172(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalL1TriggerObjects*)o)->::HcalL1TriggerObjects::~HcalL1TriggerObjects)();
}
static void method_newdel_300( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalL1TriggerObjects >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalL1TriggerObjects >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalL1TriggerObjects >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalL1TriggerObjects >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalL1TriggerObjects >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalL1TriggerObject>")), ::Reflex::BaseOffset< ::HcalL1TriggerObjects,::HcalCondObjectContainer<HcalL1TriggerObject> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalL1TriggerObjects,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalL1TriggerObjects -------------------------------
void __HcalL1TriggerObjects_db_datamem(Reflex::Class*);
void __HcalL1TriggerObjects_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalL1TriggerObjects_datamem_bld(&__HcalL1TriggerObjects_db_datamem);
Reflex::GenreflexMemberBuilder __HcalL1TriggerObjects_funcmem_bld(&__HcalL1TriggerObjects_db_funcmem);
void __HcalL1TriggerObjects_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalL1TriggerObjects"), typeid(::HcalL1TriggerObjects), sizeof(::HcalL1TriggerObjects), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_183, ::Reflex::BaseOffset< ::HcalL1TriggerObjects, ::HcalCondObjectContainer<HcalL1TriggerObject> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10063, type_10064), Reflex::Literal("operator="), operator_3163, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10064), Reflex::Literal("HcalL1TriggerObjects"), constructor_3164, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalL1TriggerObjects"), constructor_3165, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalL1TriggerObjects"), constructor_3166, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalL1TriggerObjects"), destructor_3172, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_300, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalL1TriggerObjects_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalL1TriggerObjects_funcmem_bld);
}

//------Delayed data member builder for class HcalL1TriggerObjects -------------------
void __HcalL1TriggerObjects_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10062, Reflex::Literal("mTag"), OffsetOf(__shadow__::__HcalL1TriggerObjects, mTag), ::Reflex::PRIVATE)
  .AddDataMember(type_10062, Reflex::Literal("mAlgo"), OffsetOf(__shadow__::__HcalL1TriggerObjects, mAlgo), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalL1TriggerObjects -------------------
void __HcalL1TriggerObjects_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_1934), Reflex::Literal("setTagString"), method_3167, 0, "fTag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_1934), Reflex::Literal("setAlgoString"), method_3168, 0, "fAlgo", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("getTagString"), method_3169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("getAlgoString"), method_3170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_3171, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalRecoParams -------------------------------
static  void operator_3196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalRecoParams*)o)->operator=)(*(const ::HcalRecoParams*)arg[0]);
  else   (((::HcalRecoParams*)o)->operator=)(*(const ::HcalRecoParams*)arg[0]);
}

static void constructor_3197( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRecoParams(*(const ::HcalRecoParams*)arg[0]);
  else ::new(mem) ::HcalRecoParams(*(const ::HcalRecoParams*)arg[0]);
}

static void constructor_3198( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRecoParams();
  else ::new(mem) ::HcalRecoParams();
}

static void constructor_3199( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRecoParams((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalRecoParams((const ::HcalTopology*)arg[0]);
}

static  void method_3200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalRecoParams*)o)->myname)());
  else   (((const ::HcalRecoParams*)o)->myname)();
}

static void destructor_3201(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalRecoParams*)o)->::HcalRecoParams::~HcalRecoParams)();
}
static void method_newdel_309( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalRecoParams >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalRecoParams >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalRecoParams >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalRecoParams >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalRecoParams >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x54( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalRecoParam>")), ::Reflex::BaseOffset< ::HcalRecoParams,::HcalCondObjectContainer<HcalRecoParam> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalRecoParams,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalRecoParams -------------------------------
void __HcalRecoParams_db_datamem(Reflex::Class*);
void __HcalRecoParams_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalRecoParams_datamem_bld(&__HcalRecoParams_db_datamem);
Reflex::GenreflexMemberBuilder __HcalRecoParams_funcmem_bld(&__HcalRecoParams_db_funcmem);
void __HcalRecoParams_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalRecoParams"), typeid(::HcalRecoParams), sizeof(::HcalRecoParams), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("class_version"), "0")
  .AddBase(type_177, ::Reflex::BaseOffset< ::HcalRecoParams, ::HcalCondObjectContainer<HcalRecoParam> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10070, type_10071), Reflex::Literal("operator="), operator_3196, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10071), Reflex::Literal("HcalRecoParams"), constructor_3197, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalRecoParams"), constructor_3198, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalRecoParams"), constructor_3199, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalRecoParams"), destructor_3201, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_309, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x54, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalRecoParams_funcmem_bld);
}

//------Delayed data member builder for class HcalRecoParams -------------------
void __HcalRecoParams_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalRecoParams -------------------
void __HcalRecoParams_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_3200, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalCovarianceMatrix -------------------------------
static void destructor_3226(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCovarianceMatrix*)o)->::HcalCovarianceMatrix::~HcalCovarianceMatrix)();
}
static  void operator_3227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCovarianceMatrix*)o)->operator=)(*(const ::HcalCovarianceMatrix*)arg[0]);
  else   (((::HcalCovarianceMatrix*)o)->operator=)(*(const ::HcalCovarianceMatrix*)arg[0]);
}

static void constructor_3228( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCovarianceMatrix(*(const ::HcalCovarianceMatrix*)arg[0]);
  else ::new(mem) ::HcalCovarianceMatrix(*(const ::HcalCovarianceMatrix*)arg[0]);
}

static void constructor_3229( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCovarianceMatrix();
  else ::new(mem) ::HcalCovarianceMatrix();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCovarianceMatrix(*(int*)arg[0]);
  else ::new(mem) ::HcalCovarianceMatrix(*(int*)arg[0]);
  }
}

static  void method_3230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalCovarianceMatrix*)o)->getValue)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]));
  else   (((const ::HcalCovarianceMatrix*)o)->getValue)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_3231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalCovarianceMatrix*)o)->setValue)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(float*)arg[3]);
}

static  void method_3232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalCovarianceMatrix*)o)->rawId)());
  else   (((const ::HcalCovarianceMatrix*)o)->rawId)();
}

static void constructor_x55( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCovarianceMatrix();
  else ::new(mem) ::HcalCovarianceMatrix();
}

static void method_newdel_333( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalCovarianceMatrix >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalCovarianceMatrix >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalCovarianceMatrix >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalCovarianceMatrix >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalCovarianceMatrix >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalCovarianceMatrix -------------------------------
void __HcalCovarianceMatrix_db_datamem(Reflex::Class*);
void __HcalCovarianceMatrix_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCovarianceMatrix_datamem_bld(&__HcalCovarianceMatrix_db_datamem);
Reflex::GenreflexMemberBuilder __HcalCovarianceMatrix_funcmem_bld(&__HcalCovarianceMatrix_db_funcmem);
void __HcalCovarianceMatrix_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCovarianceMatrix"), typeid(::HcalCovarianceMatrix), sizeof(::HcalCovarianceMatrix), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCovarianceMatrix"), destructor_3226, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5906, type_5908), Reflex::Literal("operator="), operator_3227, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5908), Reflex::Literal("HcalCovarianceMatrix"), constructor_3228, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_101), Reflex::Literal("HcalCovarianceMatrix"), constructor_3229, 0, "fId=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalCovarianceMatrix"), constructor_x55, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_333, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCovarianceMatrix_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCovarianceMatrix_funcmem_bld);
}

//------Delayed data member builder for class HcalCovarianceMatrix -------------------
void __HcalCovarianceMatrix_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalCovarianceMatrix, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_10076, Reflex::Literal("covariancematrix"), OffsetOf(__shadow__::__HcalCovarianceMatrix, covariancematrix), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalCovarianceMatrix -------------------
void __HcalCovarianceMatrix_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_101, type_101, type_101), Reflex::Literal("getValue"), method_3230, 0, "capid;i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_101, type_101, type_101, type_1181), Reflex::Literal("setValue"), method_3231, 0, "capid;i;j;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_3232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCholeskyMatrices -------------------------------
static  void operator_3347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCholeskyMatrices*)o)->operator=)(*(const ::HcalCholeskyMatrices*)arg[0]);
  else   (((::HcalCholeskyMatrices*)o)->operator=)(*(const ::HcalCholeskyMatrices*)arg[0]);
}

static void constructor_3348( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCholeskyMatrices(*(const ::HcalCholeskyMatrices*)arg[0]);
  else ::new(mem) ::HcalCholeskyMatrices(*(const ::HcalCholeskyMatrices*)arg[0]);
}

static void constructor_3349( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCholeskyMatrices();
  else ::new(mem) ::HcalCholeskyMatrices();
}

static void constructor_3350( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCholeskyMatrices((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCholeskyMatrices((const ::HcalTopology*)arg[0]);
}

static void destructor_3351(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCholeskyMatrices*)o)->::HcalCholeskyMatrices::~HcalCholeskyMatrices)();
}
static  void method_3352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalCholeskyMatrices*)o)->myname)());
  else   (((const ::HcalCholeskyMatrices*)o)->myname)();
}

static  void method_3353( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCholeskyMatrices*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCholeskyMatrices*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCholeskyMatrices*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCholeskyMatrices*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_3354( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCholeskyMatrices*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCholeskyMatrices*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_3355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCholeskyMatrices*)o)->addValues)(*(const ::HcalCholeskyMatrix*)arg[0]));
  else   (((::HcalCholeskyMatrices*)o)->addValues)(*(const ::HcalCholeskyMatrix*)arg[0]);
}

static  void method_3356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCholeskyMatrices*)o)->getAllChannels)());
  else   (((const ::HcalCholeskyMatrices*)o)->getAllChannels)();
}

static void method_newdel_506( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalCholeskyMatrices >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalCholeskyMatrices >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalCholeskyMatrices >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalCholeskyMatrices >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalCholeskyMatrices >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x58( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCholeskyMatrices,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCholeskyMatrices -------------------------------
void __HcalCholeskyMatrices_db_datamem(Reflex::Class*);
void __HcalCholeskyMatrices_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCholeskyMatrices_datamem_bld(&__HcalCholeskyMatrices_db_datamem);
Reflex::GenreflexMemberBuilder __HcalCholeskyMatrices_funcmem_bld(&__HcalCholeskyMatrices_db_funcmem);
void __HcalCholeskyMatrices_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCholeskyMatrices"), typeid(::HcalCholeskyMatrices), sizeof(::HcalCholeskyMatrices), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCholeskyMatrices, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10129, type_10130), Reflex::Literal("operator="), operator_3347, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10130), Reflex::Literal("HcalCholeskyMatrices"), constructor_3348, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalCholeskyMatrices"), constructor_3349, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCholeskyMatrices"), constructor_3350, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCholeskyMatrices"), destructor_3351, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_506, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x58, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCholeskyMatrices_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCholeskyMatrices_funcmem_bld);
}

//------Delayed data member builder for class HcalCholeskyMatrices -------------------
void __HcalCholeskyMatrices_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1858, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCholeskyMatrices, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1858, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCholeskyMatrices, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1858, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCholeskyMatrices, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1858, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCholeskyMatrices, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCholeskyMatrices -------------------
void __HcalCholeskyMatrices_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_3352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5969, type_1488, type_2461), Reflex::Literal("getValues"), method_3353, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_3354, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_5973), Reflex::Literal("addValues"), method_3355, 0, "myHcalCholeskyMatrix", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_3356, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCondObjectContainerBase -------------------------------
static void destructor_3371(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCondObjectContainerBase*)o)->::HcalCondObjectContainerBase::~HcalCondObjectContainerBase)();
}
static  void operator_3372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCondObjectContainerBase*)o)->operator=)(*(const ::HcalCondObjectContainerBase*)arg[0]);
  else   (((::HcalCondObjectContainerBase*)o)->operator=)(*(const ::HcalCondObjectContainerBase*)arg[0]);
}

static void constructor_3373( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCondObjectContainerBase(*(const ::HcalCondObjectContainerBase*)arg[0]);
  else ::new(mem) ::HcalCondObjectContainerBase(*(const ::HcalCondObjectContainerBase*)arg[0]);
}

static  void method_3374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCondObjectContainerBase*)o)->topo)());
  else   (((const ::HcalCondObjectContainerBase*)o)->topo)();
}

static  void method_3375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCondObjectContainerBase*)o)->getCreatorPackedIndexVersion)());
  else   (((const ::HcalCondObjectContainerBase*)o)->getCreatorPackedIndexVersion)();
}

static  void method_3376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::HcalCondObjectContainerBase*)o)->setTopo)((const ::HcalTopology*)arg[0]);
}

static  void method_3377( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalCondObjectContainerBase*)o)->setTopo)((const ::HcalTopology*)arg[0]);
}

//------Dictionary for class HcalCondObjectContainerBase -------------------------------
void __HcalCondObjectContainerBase_db_datamem(Reflex::Class*);
void __HcalCondObjectContainerBase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainerBase_datamem_bld(&__HcalCondObjectContainerBase_db_datamem);
Reflex::GenreflexMemberBuilder __HcalCondObjectContainerBase_funcmem_bld(&__HcalCondObjectContainerBase_db_funcmem);
void __HcalCondObjectContainerBase_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCondObjectContainerBase"), typeid(::HcalCondObjectContainerBase), sizeof(::HcalCondObjectContainerBase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCondObjectContainerBase"), destructor_3371, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10140, type_10141), Reflex::Literal("operator="), operator_3372, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10141), Reflex::Literal("HcalCondObjectContainerBase"), constructor_3373, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddOnDemandDataMemberBuilder(&__HcalCondObjectContainerBase_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCondObjectContainerBase_funcmem_bld);
}

//------Delayed data member builder for class HcalCondObjectContainerBase -------------------
void __HcalCondObjectContainerBase_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_101, Reflex::Literal("packedIndexVersion_"), OffsetOf(__shadow__::__HcalCondObjectContainerBase, packedIndexVersion_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_9860, Reflex::Literal("topo_"), OffsetOf(__shadow__::__HcalCondObjectContainerBase, topo_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class HcalCondObjectContainerBase -------------------
void __HcalCondObjectContainerBase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9860), Reflex::Literal("topo"), method_3374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("getCreatorPackedIndexVersion"), method_3375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_9860), Reflex::Literal("setTopo"), method_3376, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_9860), Reflex::Literal("setTopo"), method_3377, 0, "topo", ::Reflex::PUBLIC);
}
//------Stub functions for class HcalDcsValues -------------------------------
static  void operator_3428( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalDcsValues*)o)->operator=)(*(const ::HcalDcsValues*)arg[0]);
  else   (((::HcalDcsValues*)o)->operator=)(*(const ::HcalDcsValues*)arg[0]);
}

static void constructor_3429( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsValues(*(const ::HcalDcsValues*)arg[0]);
  else ::new(mem) ::HcalDcsValues(*(const ::HcalDcsValues*)arg[0]);
}

static void constructor_3430( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsValues();
  else ::new(mem) ::HcalDcsValues();
}

static void destructor_3431(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalDcsValues*)o)->::HcalDcsValues::~HcalDcsValues)();
}
static  void method_3432( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalDcsValues*)o)->addValue)(*(const ::HcalDcsValue*)arg[0]));
  else   (((::HcalDcsValues*)o)->addValue)(*(const ::HcalDcsValue*)arg[0]);
}

static  void method_3433( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HcalDcsValues*)o)->sortAll)();
}

static  void method_3434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalDcsValues*)o)->exists)(*(const ::HcalDcsDetId*)arg[0]));
  else   (((::HcalDcsValues*)o)->exists)(*(const ::HcalDcsDetId*)arg[0]);
}

static  void method_3435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<HcalDcsValue>)((((::HcalDcsValues*)o)->getValues)(*(const ::HcalDcsDetId*)arg[0]));
  else   (((::HcalDcsValues*)o)->getValues)(*(const ::HcalDcsDetId*)arg[0]);
}

static  void method_3436( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HcalDcsValues*)o)->getAllSubdetValues)(*(::HcalDcsValues::DcsSubDet*)arg[0]);
  else   (((const ::HcalDcsValues*)o)->getAllSubdetValues)(*(::HcalDcsValues::DcsSubDet*)arg[0]);
}

static  void method_3437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalDcsValues*)o)->myname)());
  else   (((const ::HcalDcsValues*)o)->myname)();
}

static  void method_3438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((::HcalDcsValues*)o)->DcsValuesOK)(*(::HcalDcsValues::DcsSubDet*)arg[0]));
    else     (((::HcalDcsValues*)o)->DcsValuesOK)(*(::HcalDcsValues::DcsSubDet*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((::HcalDcsValues*)o)->DcsValuesOK)(*(::HcalDcsValues::DcsSubDet*)arg[0],
      *(int*)arg[1]));
    else     (((::HcalDcsValues*)o)->DcsValuesOK)(*(::HcalDcsValues::DcsSubDet*)arg[0],
      *(int*)arg[1]);
  }
}

static void method_newdel_656( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalDcsValues >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalDcsValues >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalDcsValues >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalDcsValues >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalDcsValues >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalDcsValues -------------------------------
void __HcalDcsValues_db_datamem(Reflex::Class*);
void __HcalDcsValues_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalDcsValues_datamem_bld(&__HcalDcsValues_db_datamem);
Reflex::GenreflexMemberBuilder __HcalDcsValues_funcmem_bld(&__HcalDcsValues_db_funcmem);
void __HcalDcsValues_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalDcsValues"), typeid(::HcalDcsValues), sizeof(::HcalDcsValues), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddTypedef(type_1856, Reflex::Literal("HcalDcsValues::DcsSet"))
  .AddEnum(Reflex::Literal("HcalDcsValues::DcsSubDet"), Reflex::Literal("HcalHB=1;HcalHE=2;HcalHO0=3;HcalHO12=4;HcalHF=5"), &typeid(HcalDcsValues::DcsSubDet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10160, type_10161), Reflex::Literal("operator="), operator_3428, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10161), Reflex::Literal("HcalDcsValues"), constructor_3429, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalDcsValues"), constructor_3430, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalDcsValues"), destructor_3431, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_656, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalDcsValues_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalDcsValues_funcmem_bld);
}

//------Delayed data member builder for class HcalDcsValues -------------------
void __HcalDcsValues_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1856, Reflex::Literal("mHBValues"), OffsetOf(__shadow__::__HcalDcsValues, mHBValues), ::Reflex::PRIVATE)
  .AddDataMember(type_2461, Reflex::Literal("mHBsorted"), OffsetOf(__shadow__::__HcalDcsValues, mHBsorted), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1856, Reflex::Literal("mHEValues"), OffsetOf(__shadow__::__HcalDcsValues, mHEValues), ::Reflex::PRIVATE)
  .AddDataMember(type_2461, Reflex::Literal("mHEsorted"), OffsetOf(__shadow__::__HcalDcsValues, mHEsorted), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1856, Reflex::Literal("mHO0Values"), OffsetOf(__shadow__::__HcalDcsValues, mHO0Values), ::Reflex::PRIVATE)
  .AddDataMember(type_2461, Reflex::Literal("mHO0sorted"), OffsetOf(__shadow__::__HcalDcsValues, mHO0sorted), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1856, Reflex::Literal("mHO12Values"), OffsetOf(__shadow__::__HcalDcsValues, mHO12Values), ::Reflex::PRIVATE)
  .AddDataMember(type_2461, Reflex::Literal("mHO12sorted"), OffsetOf(__shadow__::__HcalDcsValues, mHO12sorted), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1856, Reflex::Literal("mHFValues"), OffsetOf(__shadow__::__HcalDcsValues, mHFValues), ::Reflex::PRIVATE)
  .AddDataMember(type_2461, Reflex::Literal("mHFsorted"), OffsetOf(__shadow__::__HcalDcsValues, mHFsorted), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class HcalDcsValues -------------------
void __HcalDcsValues_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_5843), Reflex::Literal("addValue"), method_3432, 0, "newVal", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("sortAll"), method_3433, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_4324), Reflex::Literal("exists"), method_3434, 0, "fid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1856, type_4324), Reflex::Literal("getValues"), method_3435, 0, "fid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10162, type_3427), Reflex::Literal("getAllSubdetValues"), method_3436, 0, "subd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_3437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_3427, type_101), Reflex::Literal("DcsValuesOK"), method_3438, 0, "subd;LS=-0x00000000000000001", ::Reflex::PUBLIC);
}
//------Stub functions for class HcalZSThresholds -------------------------------
static  void operator_3578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalZSThresholds*)o)->operator=)(*(const ::HcalZSThresholds*)arg[0]);
  else   (((::HcalZSThresholds*)o)->operator=)(*(const ::HcalZSThresholds*)arg[0]);
}

static void constructor_3579( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZSThresholds(*(const ::HcalZSThresholds*)arg[0]);
  else ::new(mem) ::HcalZSThresholds(*(const ::HcalZSThresholds*)arg[0]);
}

static void constructor_3580( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZSThresholds();
  else ::new(mem) ::HcalZSThresholds();
}

static void constructor_3581( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZSThresholds((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalZSThresholds((const ::HcalTopology*)arg[0]);
}

static  void method_3582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalZSThresholds*)o)->myname)());
  else   (((const ::HcalZSThresholds*)o)->myname)();
}

static void destructor_3583(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalZSThresholds*)o)->::HcalZSThresholds::~HcalZSThresholds)();
}
static void method_newdel_753( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalZSThresholds >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalZSThresholds >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalZSThresholds >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalZSThresholds >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalZSThresholds >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x61( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalZSThreshold>")), ::Reflex::BaseOffset< ::HcalZSThresholds,::HcalCondObjectContainer<HcalZSThreshold> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalZSThresholds,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalZSThresholds -------------------------------
void __HcalZSThresholds_db_datamem(Reflex::Class*);
void __HcalZSThresholds_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalZSThresholds_datamem_bld(&__HcalZSThresholds_db_datamem);
Reflex::GenreflexMemberBuilder __HcalZSThresholds_funcmem_bld(&__HcalZSThresholds_db_funcmem);
void __HcalZSThresholds_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalZSThresholds"), typeid(::HcalZSThresholds), sizeof(::HcalZSThresholds), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_185, ::Reflex::BaseOffset< ::HcalZSThresholds, ::HcalCondObjectContainer<HcalZSThreshold> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10174, type_10175), Reflex::Literal("operator="), operator_3578, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10175), Reflex::Literal("HcalZSThresholds"), constructor_3579, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalZSThresholds"), constructor_3580, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalZSThresholds"), constructor_3581, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalZSThresholds"), destructor_3583, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_753, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x61, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalZSThresholds_funcmem_bld);
}

//------Delayed data member builder for class HcalZSThresholds -------------------
void __HcalZSThresholds_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalZSThresholds -------------------
void __HcalZSThresholds_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_3582, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalGains -------------------------------
static  void operator_3595( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalGains*)o)->operator=)(*(const ::HcalGains*)arg[0]);
  else   (((::HcalGains*)o)->operator=)(*(const ::HcalGains*)arg[0]);
}

static void constructor_3596( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGains(*(const ::HcalGains*)arg[0]);
  else ::new(mem) ::HcalGains(*(const ::HcalGains*)arg[0]);
}

static void constructor_3597( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGains();
  else ::new(mem) ::HcalGains();
}

static void constructor_3598( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGains((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalGains((const ::HcalTopology*)arg[0]);
}

static  void method_3599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalGains*)o)->myname)());
  else   (((const ::HcalGains*)o)->myname)();
}

static void destructor_3600(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalGains*)o)->::HcalGains::~HcalGains)();
}
static void method_newdel_804( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalGains >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalGains >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalGains >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalGains >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalGains >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x63( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalGain>")), ::Reflex::BaseOffset< ::HcalGains,::HcalCondObjectContainer<HcalGain> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalGains,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalGains -------------------------------
void __HcalGains_db_datamem(Reflex::Class*);
void __HcalGains_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalGains_datamem_bld(&__HcalGains_db_datamem);
Reflex::GenreflexMemberBuilder __HcalGains_funcmem_bld(&__HcalGains_db_funcmem);
void __HcalGains_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalGains"), typeid(::HcalGains), sizeof(::HcalGains), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_190, ::Reflex::BaseOffset< ::HcalGains, ::HcalCondObjectContainer<HcalGain> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10179, type_10180), Reflex::Literal("operator="), operator_3595, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10180), Reflex::Literal("HcalGains"), constructor_3596, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalGains"), constructor_3597, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalGains"), constructor_3598, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalGains"), destructor_3600, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_804, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x63, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalGains_funcmem_bld);
}

//------Delayed data member builder for class HcalGains -------------------
void __HcalGains_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalGains -------------------
void __HcalGains_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_3599, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalChannelQuality -------------------------------
static  void operator_3690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalChannelQuality*)o)->operator=)(*(const ::HcalChannelQuality*)arg[0]);
  else   (((::HcalChannelQuality*)o)->operator=)(*(const ::HcalChannelQuality*)arg[0]);
}

static void constructor_3691( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalChannelQuality(*(const ::HcalChannelQuality*)arg[0]);
  else ::new(mem) ::HcalChannelQuality(*(const ::HcalChannelQuality*)arg[0]);
}

static void constructor_3692( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalChannelQuality();
  else ::new(mem) ::HcalChannelQuality();
}

static void constructor_3693( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalChannelQuality((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalChannelQuality((const ::HcalTopology*)arg[0]);
}

static  void method_3694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalChannelQuality*)o)->myname)());
  else   (((const ::HcalChannelQuality*)o)->myname)();
}

static void destructor_3695(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalChannelQuality*)o)->::HcalChannelQuality::~HcalChannelQuality)();
}
static void method_newdel_868( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalChannelQuality >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalChannelQuality >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalChannelQuality >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalChannelQuality >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalChannelQuality >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x65( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalChannelStatus>")), ::Reflex::BaseOffset< ::HcalChannelQuality,::HcalCondObjectContainer<HcalChannelStatus> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalChannelQuality,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalChannelQuality -------------------------------
void __HcalChannelQuality_db_datamem(Reflex::Class*);
void __HcalChannelQuality_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalChannelQuality_datamem_bld(&__HcalChannelQuality_db_datamem);
Reflex::GenreflexMemberBuilder __HcalChannelQuality_funcmem_bld(&__HcalChannelQuality_db_funcmem);
void __HcalChannelQuality_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalChannelQuality"), typeid(::HcalChannelQuality), sizeof(::HcalChannelQuality), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_186, ::Reflex::BaseOffset< ::HcalChannelQuality, ::HcalCondObjectContainer<HcalChannelStatus> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10219, type_10220), Reflex::Literal("operator="), operator_3690, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10220), Reflex::Literal("HcalChannelQuality"), constructor_3691, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalChannelQuality"), constructor_3692, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalChannelQuality"), constructor_3693, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalChannelQuality"), destructor_3695, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_868, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x65, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalChannelQuality_funcmem_bld);
}

//------Delayed data member builder for class HcalChannelQuality -------------------
void __HcalChannelQuality_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalChannelQuality -------------------
void __HcalChannelQuality_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_3694, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalPFCorrs -------------------------------
static  void operator_3709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalPFCorrs*)o)->operator=)(*(const ::HcalPFCorrs*)arg[0]);
  else   (((::HcalPFCorrs*)o)->operator=)(*(const ::HcalPFCorrs*)arg[0]);
}

static void constructor_3710( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPFCorrs(*(const ::HcalPFCorrs*)arg[0]);
  else ::new(mem) ::HcalPFCorrs(*(const ::HcalPFCorrs*)arg[0]);
}

static void constructor_3711( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPFCorrs();
  else ::new(mem) ::HcalPFCorrs();
}

static void constructor_3712( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPFCorrs((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalPFCorrs((const ::HcalTopology*)arg[0]);
}

static  void method_3713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalPFCorrs*)o)->myname)());
  else   (((const ::HcalPFCorrs*)o)->myname)();
}

static void destructor_3714(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalPFCorrs*)o)->::HcalPFCorrs::~HcalPFCorrs)();
}
static void method_newdel_900( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalPFCorrs >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalPFCorrs >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalPFCorrs >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalPFCorrs >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalPFCorrs >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x67( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalPFCorr>")), ::Reflex::BaseOffset< ::HcalPFCorrs,::HcalCondObjectContainer<HcalPFCorr> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalPFCorrs,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalPFCorrs -------------------------------
void __HcalPFCorrs_db_datamem(Reflex::Class*);
void __HcalPFCorrs_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalPFCorrs_datamem_bld(&__HcalPFCorrs_db_datamem);
Reflex::GenreflexMemberBuilder __HcalPFCorrs_funcmem_bld(&__HcalPFCorrs_db_funcmem);
void __HcalPFCorrs_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalPFCorrs"), typeid(::HcalPFCorrs), sizeof(::HcalPFCorrs), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_180, ::Reflex::BaseOffset< ::HcalPFCorrs, ::HcalCondObjectContainer<HcalPFCorr> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10242, type_10243), Reflex::Literal("operator="), operator_3709, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10243), Reflex::Literal("HcalPFCorrs"), constructor_3710, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalPFCorrs"), constructor_3711, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalPFCorrs"), constructor_3712, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalPFCorrs"), destructor_3714, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_900, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x67, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalPFCorrs_funcmem_bld);
}

//------Delayed data member builder for class HcalPFCorrs -------------------
void __HcalPFCorrs_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalPFCorrs -------------------
void __HcalPFCorrs_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_3713, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalFlagHFDigiTimeParams -------------------------------
static  void operator_3988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalFlagHFDigiTimeParams*)o)->operator=)(*(const ::HcalFlagHFDigiTimeParams*)arg[0]);
  else   (((::HcalFlagHFDigiTimeParams*)o)->operator=)(*(const ::HcalFlagHFDigiTimeParams*)arg[0]);
}

static void constructor_3989( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalFlagHFDigiTimeParams(*(const ::HcalFlagHFDigiTimeParams*)arg[0]);
  else ::new(mem) ::HcalFlagHFDigiTimeParams(*(const ::HcalFlagHFDigiTimeParams*)arg[0]);
}

static void constructor_3990( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalFlagHFDigiTimeParams();
  else ::new(mem) ::HcalFlagHFDigiTimeParams();
}

static void constructor_3991( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalFlagHFDigiTimeParams((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalFlagHFDigiTimeParams((const ::HcalTopology*)arg[0]);
}

static  void method_3992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalFlagHFDigiTimeParams*)o)->myname)());
  else   (((const ::HcalFlagHFDigiTimeParams*)o)->myname)();
}

static void destructor_3993(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalFlagHFDigiTimeParams*)o)->::HcalFlagHFDigiTimeParams::~HcalFlagHFDigiTimeParams)();
}
static void method_newdel_1120( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalFlagHFDigiTimeParams >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalFlagHFDigiTimeParams >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalFlagHFDigiTimeParams >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalFlagHFDigiTimeParams >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalFlagHFDigiTimeParams >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x69( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalFlagHFDigiTimeParam>")), ::Reflex::BaseOffset< ::HcalFlagHFDigiTimeParams,::HcalCondObjectContainer<HcalFlagHFDigiTimeParam> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalFlagHFDigiTimeParams,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalFlagHFDigiTimeParams -------------------------------
void __HcalFlagHFDigiTimeParams_db_datamem(Reflex::Class*);
void __HcalFlagHFDigiTimeParams_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalFlagHFDigiTimeParams_datamem_bld(&__HcalFlagHFDigiTimeParams_db_datamem);
Reflex::GenreflexMemberBuilder __HcalFlagHFDigiTimeParams_funcmem_bld(&__HcalFlagHFDigiTimeParams_db_funcmem);
void __HcalFlagHFDigiTimeParams_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalFlagHFDigiTimeParams"), typeid(::HcalFlagHFDigiTimeParams), sizeof(::HcalFlagHFDigiTimeParams), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("class_version"), "0")
  .AddBase(type_174, ::Reflex::BaseOffset< ::HcalFlagHFDigiTimeParams, ::HcalCondObjectContainer<HcalFlagHFDigiTimeParam> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11877, type_11878), Reflex::Literal("operator="), operator_3988, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11878), Reflex::Literal("HcalFlagHFDigiTimeParams"), constructor_3989, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalFlagHFDigiTimeParams"), constructor_3990, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalFlagHFDigiTimeParams"), constructor_3991, 0, "ht", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalFlagHFDigiTimeParams"), destructor_3993, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x69, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalFlagHFDigiTimeParams_funcmem_bld);
}

//------Delayed data member builder for class HcalFlagHFDigiTimeParams -------------------
void __HcalFlagHFDigiTimeParams_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalFlagHFDigiTimeParams -------------------
void __HcalFlagHFDigiTimeParams_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_3992, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalLUTCorrs -------------------------------
static  void operator_4011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalLUTCorrs*)o)->operator=)(*(const ::HcalLUTCorrs*)arg[0]);
  else   (((::HcalLUTCorrs*)o)->operator=)(*(const ::HcalLUTCorrs*)arg[0]);
}

static void constructor_4012( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLUTCorrs(*(const ::HcalLUTCorrs*)arg[0]);
  else ::new(mem) ::HcalLUTCorrs(*(const ::HcalLUTCorrs*)arg[0]);
}

static void constructor_4013( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLUTCorrs();
  else ::new(mem) ::HcalLUTCorrs();
}

static void constructor_4014( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLUTCorrs((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalLUTCorrs((const ::HcalTopology*)arg[0]);
}

static  void method_4015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalLUTCorrs*)o)->myname)());
  else   (((const ::HcalLUTCorrs*)o)->myname)();
}

static void destructor_4016(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalLUTCorrs*)o)->::HcalLUTCorrs::~HcalLUTCorrs)();
}
static void method_newdel_1162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalLUTCorrs >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalLUTCorrs >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalLUTCorrs >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalLUTCorrs >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalLUTCorrs >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x71( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalLUTCorr>")), ::Reflex::BaseOffset< ::HcalLUTCorrs,::HcalCondObjectContainer<HcalLUTCorr> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalLUTCorrs,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalLUTCorrs -------------------------------
void __HcalLUTCorrs_db_datamem(Reflex::Class*);
void __HcalLUTCorrs_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalLUTCorrs_datamem_bld(&__HcalLUTCorrs_db_datamem);
Reflex::GenreflexMemberBuilder __HcalLUTCorrs_funcmem_bld(&__HcalLUTCorrs_db_funcmem);
void __HcalLUTCorrs_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalLUTCorrs"), typeid(::HcalLUTCorrs), sizeof(::HcalLUTCorrs), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_181, ::Reflex::BaseOffset< ::HcalLUTCorrs, ::HcalCondObjectContainer<HcalLUTCorr> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11879, type_11880), Reflex::Literal("operator="), operator_4011, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11880), Reflex::Literal("HcalLUTCorrs"), constructor_4012, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalLUTCorrs"), constructor_4013, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalLUTCorrs"), constructor_4014, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalLUTCorrs"), destructor_4016, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x71, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalLUTCorrs_funcmem_bld);
}

//------Delayed data member builder for class HcalLUTCorrs -------------------
void __HcalLUTCorrs_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalLUTCorrs -------------------
void __HcalLUTCorrs_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_4015, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalValidationCorrs -------------------------------
static  void operator_4017( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalValidationCorrs*)o)->operator=)(*(const ::HcalValidationCorrs*)arg[0]);
  else   (((::HcalValidationCorrs*)o)->operator=)(*(const ::HcalValidationCorrs*)arg[0]);
}

static void constructor_4018( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalValidationCorrs(*(const ::HcalValidationCorrs*)arg[0]);
  else ::new(mem) ::HcalValidationCorrs(*(const ::HcalValidationCorrs*)arg[0]);
}

static void constructor_4019( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalValidationCorrs();
  else ::new(mem) ::HcalValidationCorrs();
}

static void constructor_4020( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalValidationCorrs((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalValidationCorrs((const ::HcalTopology*)arg[0]);
}

static  void method_4021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalValidationCorrs*)o)->myname)());
  else   (((const ::HcalValidationCorrs*)o)->myname)();
}

static void destructor_4022(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalValidationCorrs*)o)->::HcalValidationCorrs::~HcalValidationCorrs)();
}
static void method_newdel_1187( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalValidationCorrs >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalValidationCorrs >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalValidationCorrs >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalValidationCorrs >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalValidationCorrs >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x73( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalValidationCorr>")), ::Reflex::BaseOffset< ::HcalValidationCorrs,::HcalCondObjectContainer<HcalValidationCorr> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalValidationCorrs,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalValidationCorrs -------------------------------
void __HcalValidationCorrs_db_datamem(Reflex::Class*);
void __HcalValidationCorrs_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalValidationCorrs_datamem_bld(&__HcalValidationCorrs_db_datamem);
Reflex::GenreflexMemberBuilder __HcalValidationCorrs_funcmem_bld(&__HcalValidationCorrs_db_funcmem);
void __HcalValidationCorrs_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalValidationCorrs"), typeid(::HcalValidationCorrs), sizeof(::HcalValidationCorrs), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_179, ::Reflex::BaseOffset< ::HcalValidationCorrs, ::HcalCondObjectContainer<HcalValidationCorr> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11881, type_11882), Reflex::Literal("operator="), operator_4017, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11882), Reflex::Literal("HcalValidationCorrs"), constructor_4018, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalValidationCorrs"), constructor_4019, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalValidationCorrs"), constructor_4020, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalValidationCorrs"), destructor_4022, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1187, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x73, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalValidationCorrs_funcmem_bld);
}

//------Delayed data member builder for class HcalValidationCorrs -------------------
void __HcalValidationCorrs_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalValidationCorrs -------------------
void __HcalValidationCorrs_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_4021, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalGainWidths -------------------------------
static  void operator_4130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalGainWidths*)o)->operator=)(*(const ::HcalGainWidths*)arg[0]);
  else   (((::HcalGainWidths*)o)->operator=)(*(const ::HcalGainWidths*)arg[0]);
}

static void constructor_4131( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGainWidths(*(const ::HcalGainWidths*)arg[0]);
  else ::new(mem) ::HcalGainWidths(*(const ::HcalGainWidths*)arg[0]);
}

static void constructor_4132( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGainWidths();
  else ::new(mem) ::HcalGainWidths();
}

static void constructor_4133( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalGainWidths((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalGainWidths((const ::HcalTopology*)arg[0]);
}

static  void method_4134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalGainWidths*)o)->myname)());
  else   (((const ::HcalGainWidths*)o)->myname)();
}

static void destructor_4135(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalGainWidths*)o)->::HcalGainWidths::~HcalGainWidths)();
}
static void method_newdel_1297( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalGainWidths >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalGainWidths >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalGainWidths >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalGainWidths >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalGainWidths >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x75( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalGainWidth>")), ::Reflex::BaseOffset< ::HcalGainWidths,::HcalCondObjectContainer<HcalGainWidth> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalGainWidths,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalGainWidths -------------------------------
void __HcalGainWidths_db_datamem(Reflex::Class*);
void __HcalGainWidths_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalGainWidths_datamem_bld(&__HcalGainWidths_db_datamem);
Reflex::GenreflexMemberBuilder __HcalGainWidths_funcmem_bld(&__HcalGainWidths_db_funcmem);
void __HcalGainWidths_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalGainWidths"), typeid(::HcalGainWidths), sizeof(::HcalGainWidths), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_189, ::Reflex::BaseOffset< ::HcalGainWidths, ::HcalCondObjectContainer<HcalGainWidth> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11950, type_11951), Reflex::Literal("operator="), operator_4130, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11951), Reflex::Literal("HcalGainWidths"), constructor_4131, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalGainWidths"), constructor_4132, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalGainWidths"), constructor_4133, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalGainWidths"), destructor_4135, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1297, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x75, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalGainWidths_funcmem_bld);
}

//------Delayed data member builder for class HcalGainWidths -------------------
void __HcalGainWidths_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalGainWidths -------------------
void __HcalGainWidths_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_4134, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalCalibrationQIEData -------------------------------
static  void operator_4136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCalibrationQIEData*)o)->operator=)(*(const ::HcalCalibrationQIEData*)arg[0]);
  else   (((::HcalCalibrationQIEData*)o)->operator=)(*(const ::HcalCalibrationQIEData*)arg[0]);
}

static void constructor_4137( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibrationQIEData(*(const ::HcalCalibrationQIEData*)arg[0]);
  else ::new(mem) ::HcalCalibrationQIEData(*(const ::HcalCalibrationQIEData*)arg[0]);
}

static void constructor_4138( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibrationQIEData((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCalibrationQIEData((const ::HcalTopology*)arg[0]);
}

static  void method_4139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCalibrationQIEData*)o)->getCoder)(*(::DetId*)arg[0]));
  else   (((const ::HcalCalibrationQIEData*)o)->getCoder)(*(::DetId*)arg[0]);
}

static  void method_4140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCalibrationQIEData*)o)->sorted)());
  else   (((const ::HcalCalibrationQIEData*)o)->sorted)();
}

static  void method_4141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCalibrationQIEData*)o)->addCoder)(*(const ::HcalCalibrationQIECoder*)arg[0]));
  else   (((::HcalCalibrationQIEData*)o)->addCoder)(*(const ::HcalCalibrationQIECoder*)arg[0]);
}

static  void method_4142( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HcalCalibrationQIEData*)o)->sort)();
}

static void destructor_4143(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCalibrationQIEData*)o)->::HcalCalibrationQIEData::~HcalCalibrationQIEData)();
}
static void method_x76( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalCalibrationQIECoder>")), ::Reflex::BaseOffset< ::HcalCalibrationQIEData,::HcalCondObjectContainer<HcalCalibrationQIECoder> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCalibrationQIEData,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCalibrationQIEData -------------------------------
void __HcalCalibrationQIEData_db_datamem(Reflex::Class*);
void __HcalCalibrationQIEData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCalibrationQIEData_datamem_bld(&__HcalCalibrationQIEData_db_datamem);
Reflex::GenreflexMemberBuilder __HcalCalibrationQIEData_funcmem_bld(&__HcalCalibrationQIEData_db_funcmem);
void __HcalCalibrationQIEData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCalibrationQIEData"), typeid(::HcalCalibrationQIEData), sizeof(::HcalCalibrationQIEData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_187, ::Reflex::BaseOffset< ::HcalCalibrationQIEData, ::HcalCondObjectContainer<HcalCalibrationQIECoder> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11952, type_11953), Reflex::Literal("operator="), operator_4136, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11953), Reflex::Literal("HcalCalibrationQIEData"), constructor_4137, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCalibrationQIEData"), constructor_4138, 0, "ht", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCalibrationQIEData"), destructor_4143, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x76, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalCalibrationQIEData_funcmem_bld);
}

//------Delayed data member builder for class HcalCalibrationQIEData -------------------
void __HcalCalibrationQIEData_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalCalibrationQIEData -------------------
void __HcalCalibrationQIEData_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6749, type_1488), Reflex::Literal("getCoder"), method_4139, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("sorted"), method_4140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6753), Reflex::Literal("addCoder"), method_4141, 0, "fCoder", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("sort"), method_4142, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class HcalPedestals -------------------------------
static  void operator_4145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalPedestals*)o)->operator=)(*(const ::HcalPedestals*)arg[0]);
  else   (((::HcalPedestals*)o)->operator=)(*(const ::HcalPedestals*)arg[0]);
}

static void constructor_4146( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestals(*(const ::HcalPedestals*)arg[0]);
  else ::new(mem) ::HcalPedestals(*(const ::HcalPedestals*)arg[0]);
}

static void constructor_4147( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestals();
  else ::new(mem) ::HcalPedestals();
}

static void constructor_4148( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestals((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalPedestals((const ::HcalTopology*)arg[0]);
}

static void constructor_4149( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalPedestals((const ::HcalTopology*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::HcalPedestals((const ::HcalTopology*)arg[0],
      *(bool*)arg[1]);
}

static  void method_4150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalPedestals*)o)->isADC)());
  else   (((const ::HcalPedestals*)o)->isADC)();
}

static  void method_4151( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalPedestals*)o)->setUnitADC)(*(bool*)arg[0]);
}

static  void method_4152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalPedestals*)o)->myname)());
  else   (((const ::HcalPedestals*)o)->myname)();
}

static void destructor_4153(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalPedestals*)o)->::HcalPedestals::~HcalPedestals)();
}
static void method_newdel_1306( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalPedestals >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalPedestals >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalPedestals >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalPedestals >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalPedestals >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x78( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalPedestal>")), ::Reflex::BaseOffset< ::HcalPedestals,::HcalCondObjectContainer<HcalPedestal> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalPedestals,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalPedestals -------------------------------
void __HcalPedestals_db_datamem(Reflex::Class*);
void __HcalPedestals_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalPedestals_datamem_bld(&__HcalPedestals_db_datamem);
Reflex::GenreflexMemberBuilder __HcalPedestals_funcmem_bld(&__HcalPedestals_db_funcmem);
void __HcalPedestals_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalPedestals"), typeid(::HcalPedestals), sizeof(::HcalPedestals), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_192, ::Reflex::BaseOffset< ::HcalPedestals, ::HcalCondObjectContainer<HcalPedestal> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11954, type_11955), Reflex::Literal("operator="), operator_4145, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11955), Reflex::Literal("HcalPedestals"), constructor_4146, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalPedestals"), constructor_4147, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalPedestals"), constructor_4148, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860, type_2461), Reflex::Literal("HcalPedestals"), constructor_4149, 0, "topo;isADC", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalPedestals"), destructor_4153, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1306, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x78, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalPedestals_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalPedestals_funcmem_bld);
}

//------Delayed data member builder for class HcalPedestals -------------------
void __HcalPedestals_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2461, Reflex::Literal("unitIsADC"), OffsetOf(__shadow__::__HcalPedestals, unitIsADC), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalPedestals -------------------
void __HcalPedestals_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("isADC"), method_4150, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2461), Reflex::Literal("setUnitADC"), method_4151, 0, "isADC", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_4152, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalTimeCorrs -------------------------------
static  void operator_4175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalTimeCorrs*)o)->operator=)(*(const ::HcalTimeCorrs*)arg[0]);
  else   (((::HcalTimeCorrs*)o)->operator=)(*(const ::HcalTimeCorrs*)arg[0]);
}

static void constructor_4176( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimeCorrs(*(const ::HcalTimeCorrs*)arg[0]);
  else ::new(mem) ::HcalTimeCorrs(*(const ::HcalTimeCorrs*)arg[0]);
}

static void constructor_4177( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimeCorrs();
  else ::new(mem) ::HcalTimeCorrs();
}

static void constructor_4178( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimeCorrs((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalTimeCorrs((const ::HcalTopology*)arg[0]);
}

static  void method_4179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalTimeCorrs*)o)->myname)());
  else   (((const ::HcalTimeCorrs*)o)->myname)();
}

static void destructor_4180(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalTimeCorrs*)o)->::HcalTimeCorrs::~HcalTimeCorrs)();
}
static void method_newdel_1350( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalTimeCorrs >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalTimeCorrs >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalTimeCorrs >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalTimeCorrs >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalTimeCorrs >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x80( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalTimeCorr>")), ::Reflex::BaseOffset< ::HcalTimeCorrs,::HcalCondObjectContainer<HcalTimeCorr> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalTimeCorrs,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalTimeCorrs -------------------------------
void __HcalTimeCorrs_db_datamem(Reflex::Class*);
void __HcalTimeCorrs_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalTimeCorrs_datamem_bld(&__HcalTimeCorrs_db_datamem);
Reflex::GenreflexMemberBuilder __HcalTimeCorrs_funcmem_bld(&__HcalTimeCorrs_db_funcmem);
void __HcalTimeCorrs_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalTimeCorrs"), typeid(::HcalTimeCorrs), sizeof(::HcalTimeCorrs), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_182, ::Reflex::BaseOffset< ::HcalTimeCorrs, ::HcalCondObjectContainer<HcalTimeCorr> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11957, type_11958), Reflex::Literal("operator="), operator_4175, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11958), Reflex::Literal("HcalTimeCorrs"), constructor_4176, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalTimeCorrs"), constructor_4177, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalTimeCorrs"), constructor_4178, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalTimeCorrs"), destructor_4180, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1350, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x80, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalTimeCorrs_funcmem_bld);
}

//------Delayed data member builder for class HcalTimeCorrs -------------------
void __HcalTimeCorrs_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalTimeCorrs -------------------
void __HcalTimeCorrs_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_4179, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalDcsValue -------------------------------
static  void operator_4220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalDcsValue*)o)->operator=)(*(const ::HcalDcsValue*)arg[0]);
  else   (((::HcalDcsValue*)o)->operator=)(*(const ::HcalDcsValue*)arg[0]);
}

static void constructor_4221( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsValue();
  else ::new(mem) ::HcalDcsValue();
}

static void constructor_4222( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsValue(*(::uint32_t*)arg[0],
      *(int*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
  else ::new(mem) ::HcalDcsValue(*(::uint32_t*)arg[0],
      *(int*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
}

static void constructor_4223( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsValue(*(const ::HcalDcsValue*)arg[0]);
  else ::new(mem) ::HcalDcsValue(*(const ::HcalDcsValue*)arg[0]);
}

static void destructor_4224(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalDcsValue*)o)->::HcalDcsValue::~HcalDcsValue)();
}
static  void method_4225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalDcsValue*)o)->DcsId)());
  else   (((const ::HcalDcsValue*)o)->DcsId)();
}

static  void method_4226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDcsValue*)o)->LS)());
  else   (((const ::HcalDcsValue*)o)->LS)();
}

static  void method_4227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalDcsValue*)o)->getValue)());
  else   (((const ::HcalDcsValue*)o)->getValue)();
}

static  void method_4228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalDcsValue*)o)->getUpperLimit)());
  else   (((const ::HcalDcsValue*)o)->getUpperLimit)();
}

static  void method_4229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalDcsValue*)o)->getLowerLimit)());
  else   (((const ::HcalDcsValue*)o)->getLowerLimit)();
}

static  void method_4230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalDcsValue*)o)->isValueGood)());
  else   (((const ::HcalDcsValue*)o)->isValueGood)();
}

static  void method_4231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDcsValue*)o)->getSubdetector)());
  else   (((const ::HcalDcsValue*)o)->getSubdetector)();
}

static  void operator_4232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalDcsValue*)o)->operator<)(*(const ::HcalDcsValue*)arg[0]));
  else   (((const ::HcalDcsValue*)o)->operator<)(*(const ::HcalDcsValue*)arg[0]);
}

static void method_newdel_1419( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalDcsValue >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalDcsValue >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalDcsValue >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalDcsValue >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalDcsValue >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalDcsValue -------------------------------
void __HcalDcsValue_db_datamem(Reflex::Class*);
void __HcalDcsValue_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalDcsValue_datamem_bld(&__HcalDcsValue_db_datamem);
Reflex::GenreflexMemberBuilder __HcalDcsValue_funcmem_bld(&__HcalDcsValue_db_funcmem);
void __HcalDcsValue_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalDcsValue"), typeid(::HcalDcsValue), sizeof(::HcalDcsValue), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5841, type_5843), Reflex::Literal("operator="), operator_4220, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalDcsValue"), constructor_4221, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_370, type_101, type_1181, type_1181, type_1181), Reflex::Literal("HcalDcsValue"), constructor_4222, 0, "fid;ls;val;upper;lower", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5843), Reflex::Literal("HcalDcsValue"), constructor_4223, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalDcsValue"), destructor_4224, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1419, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalDcsValue_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalDcsValue_funcmem_bld);
}

//------Delayed data member builder for class HcalDcsValue -------------------
void __HcalDcsValue_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalDcsValue, mId), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("mLS"), OffsetOf(__shadow__::__HcalDcsValue, mLS), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mValue"), OffsetOf(__shadow__::__HcalDcsValue, mValue), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mUpperLimit"), OffsetOf(__shadow__::__HcalDcsValue, mUpperLimit), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("mLowerLimit"), OffsetOf(__shadow__::__HcalDcsValue, mLowerLimit), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalDcsValue -------------------
void __HcalDcsValue_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("DcsId"), method_4225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("LS"), method_4226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getValue"), method_4227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getUpperLimit"), method_4228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getLowerLimit"), method_4229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("isValueGood"), method_4230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_330), Reflex::Literal("getSubdetector"), method_4231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_5843), Reflex::Literal("operator<"), operator_4232, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class HcalQIEData -------------------------------
static  void operator_4234( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalQIEData*)o)->operator=)(*(const ::HcalQIEData*)arg[0]);
  else   (((::HcalQIEData*)o)->operator=)(*(const ::HcalQIEData*)arg[0]);
}

static void constructor_4235( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalQIEData(*(const ::HcalQIEData*)arg[0]);
  else ::new(mem) ::HcalQIEData(*(const ::HcalQIEData*)arg[0]);
}

static void constructor_4236( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalQIEData();
  else ::new(mem) ::HcalQIEData();
}

static void constructor_4237( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalQIEData((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalQIEData((const ::HcalTopology*)arg[0]);
}

static  void method_4238( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HcalQIEData*)o)->setupShape)();
}

static  void method_4239( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HcalQIEData*)o)->getShape)(*(::DetId*)arg[0]);
  else   (((const ::HcalQIEData*)o)->getShape)(*(::DetId*)arg[0]);
}

static  void method_4240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HcalQIEData*)o)->getShape)((const ::HcalQIECoder*)arg[0]);
  else   (((const ::HcalQIEData*)o)->getShape)((const ::HcalQIECoder*)arg[0]);
}

static  void method_4241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalQIEData*)o)->getCoder)(*(::DetId*)arg[0]));
  else   (((const ::HcalQIEData*)o)->getCoder)(*(::DetId*)arg[0]);
}

static  void method_4242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalQIEData*)o)->sorted)());
  else   (((const ::HcalQIEData*)o)->sorted)();
}

static  void method_4243( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalQIEData*)o)->addCoder)(*(const ::HcalQIECoder*)arg[0]));
  else   (((::HcalQIEData*)o)->addCoder)(*(const ::HcalQIECoder*)arg[0]);
}

static  void method_4244( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HcalQIEData*)o)->sort)();
}

static  void method_4245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalQIEData*)o)->myname)());
  else   (((const ::HcalQIEData*)o)->myname)();
}

static void destructor_4246(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalQIEData*)o)->::HcalQIEData::~HcalQIEData)();
}
static void method_newdel_1432( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalQIEData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalQIEData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalQIEData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalQIEData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalQIEData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x83( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalQIECoder>")), ::Reflex::BaseOffset< ::HcalQIEData,::HcalCondObjectContainer<HcalQIECoder> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalQIEData,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalQIEData -------------------------------
void __HcalQIEData_db_datamem(Reflex::Class*);
void __HcalQIEData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalQIEData_datamem_bld(&__HcalQIEData_db_datamem);
Reflex::GenreflexMemberBuilder __HcalQIEData_funcmem_bld(&__HcalQIEData_db_funcmem);
void __HcalQIEData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalQIEData"), typeid(::HcalQIEData), sizeof(::HcalQIEData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_188, ::Reflex::BaseOffset< ::HcalQIEData, ::HcalCondObjectContainer<HcalQIECoder> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11962, type_11963), Reflex::Literal("operator="), operator_4234, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11963), Reflex::Literal("HcalQIEData"), constructor_4235, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalQIEData"), constructor_4236, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalQIEData"), constructor_4237, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalQIEData"), destructor_4246, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1432, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x83, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalQIEData_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalQIEData_funcmem_bld);
}

//------Delayed data member builder for class HcalQIEData -------------------
void __HcalQIEData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11961, Reflex::Literal("mShape"), OffsetOf(__shadow__::__HcalQIEData, mShape), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class HcalQIEData -------------------
void __HcalQIEData_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("setupShape"), method_4238, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9952, type_1488), Reflex::Literal("getShape"), method_4239, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9952, type_6814), Reflex::Literal("getShape"), method_4240, 0, "coder", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6814, type_1488), Reflex::Literal("getCoder"), method_4241, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("sorted"), method_4242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_6818), Reflex::Literal("addCoder"), method_4243, 0, "fCoder", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("sort"), method_4244, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_4245, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalCovarianceMatrices -------------------------------
static  void operator_4251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCovarianceMatrices*)o)->operator=)(*(const ::HcalCovarianceMatrices*)arg[0]);
  else   (((::HcalCovarianceMatrices*)o)->operator=)(*(const ::HcalCovarianceMatrices*)arg[0]);
}

static void constructor_4252( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCovarianceMatrices(*(const ::HcalCovarianceMatrices*)arg[0]);
  else ::new(mem) ::HcalCovarianceMatrices(*(const ::HcalCovarianceMatrices*)arg[0]);
}

static void constructor_4253( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCovarianceMatrices();
  else ::new(mem) ::HcalCovarianceMatrices();
}

static void constructor_4254( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCovarianceMatrices((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalCovarianceMatrices((const ::HcalTopology*)arg[0]);
}

static void destructor_4255(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCovarianceMatrices*)o)->::HcalCovarianceMatrices::~HcalCovarianceMatrices)();
}
static  void method_4256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalCovarianceMatrices*)o)->myname)());
  else   (((const ::HcalCovarianceMatrices*)o)->myname)();
}

static  void method_4257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCovarianceMatrices*)o)->getValues)(*(::DetId*)arg[0]));
    else     (((const ::HcalCovarianceMatrices*)o)->getValues)(*(::DetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HcalCovarianceMatrices*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::HcalCovarianceMatrices*)o)->getValues)(*(::DetId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_4258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalCovarianceMatrices*)o)->exists)(*(::DetId*)arg[0]));
  else   (((const ::HcalCovarianceMatrices*)o)->exists)(*(::DetId*)arg[0]);
}

static  void method_4259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCovarianceMatrices*)o)->addValues)(*(const ::HcalCovarianceMatrix*)arg[0]));
  else   (((::HcalCovarianceMatrices*)o)->addValues)(*(const ::HcalCovarianceMatrix*)arg[0]);
}

static  void method_4260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<DetId>)((((const ::HcalCovarianceMatrices*)o)->getAllChannels)());
  else   (((const ::HcalCovarianceMatrices*)o)->getAllChannels)();
}

static void method_newdel_1469( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalCovarianceMatrices >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalCovarianceMatrices >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalCovarianceMatrices >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalCovarianceMatrices >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalCovarianceMatrices >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x85( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalCovarianceMatrices,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCovarianceMatrices -------------------------------
void __HcalCovarianceMatrices_db_datamem(Reflex::Class*);
void __HcalCovarianceMatrices_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCovarianceMatrices_datamem_bld(&__HcalCovarianceMatrices_db_datamem);
Reflex::GenreflexMemberBuilder __HcalCovarianceMatrices_funcmem_bld(&__HcalCovarianceMatrices_db_funcmem);
void __HcalCovarianceMatrices_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCovarianceMatrices"), typeid(::HcalCovarianceMatrices), sizeof(::HcalCovarianceMatrices), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_524, ::Reflex::BaseOffset< ::HcalCovarianceMatrices, ::HcalCondObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11964, type_11965), Reflex::Literal("operator="), operator_4251, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11965), Reflex::Literal("HcalCovarianceMatrices"), constructor_4252, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalCovarianceMatrices"), constructor_4253, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalCovarianceMatrices"), constructor_4254, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCovarianceMatrices"), destructor_4255, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1469, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x85, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCovarianceMatrices_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCovarianceMatrices_funcmem_bld);
}

//------Delayed data member builder for class HcalCovarianceMatrices -------------------
void __HcalCovarianceMatrices_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1857, Reflex::Literal("HBcontainer"), OffsetOf(__shadow__::__HcalCovarianceMatrices, HBcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1857, Reflex::Literal("HEcontainer"), OffsetOf(__shadow__::__HcalCovarianceMatrices, HEcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1857, Reflex::Literal("HOcontainer"), OffsetOf(__shadow__::__HcalCovarianceMatrices, HOcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"))
  .AddDataMember(type_1857, Reflex::Literal("HFcontainer"), OffsetOf(__shadow__::__HcalCovarianceMatrices, HFcontainer), ::Reflex::PRIVATE)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class HcalCovarianceMatrices -------------------
void __HcalCovarianceMatrices_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_4256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5904, type_1488, type_2461), Reflex::Literal("getValues"), method_4257, 0, "fId;throwOnFail=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461c, type_1488), Reflex::Literal("exists"), method_4258, 0, "fId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_5908), Reflex::Literal("addValues"), method_4259, 0, "myHcalCovarianceMatrix", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1877), Reflex::Literal("getAllChannels"), method_4260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalLutMetadata -------------------------------
static  void operator_4284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalLutMetadata*)o)->operator=)(*(const ::HcalLutMetadata*)arg[0]);
  else   (((::HcalLutMetadata*)o)->operator=)(*(const ::HcalLutMetadata*)arg[0]);
}

static void constructor_4285( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLutMetadata(*(const ::HcalLutMetadata*)arg[0]);
  else ::new(mem) ::HcalLutMetadata(*(const ::HcalLutMetadata*)arg[0]);
}

static void constructor_4286( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLutMetadata();
  else ::new(mem) ::HcalLutMetadata();
}

static void constructor_4287( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLutMetadata((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalLutMetadata((const ::HcalTopology*)arg[0]);
}

static  void method_4288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalLutMetadata*)o)->myname)());
  else   (((const ::HcalLutMetadata*)o)->myname)();
}

static  void method_4289( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalLutMetadata*)o)->setRctLsb)(*(float*)arg[0]));
  else   (((::HcalLutMetadata*)o)->setRctLsb)(*(float*)arg[0]);
}

static  void method_4290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalLutMetadata*)o)->getRctLsb)());
  else   (((const ::HcalLutMetadata*)o)->getRctLsb)();
}

static  void method_4291( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalLutMetadata*)o)->setNominalGain)(*(float*)arg[0]));
  else   (((::HcalLutMetadata*)o)->setNominalGain)(*(float*)arg[0]);
}

static  void method_4292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalLutMetadata*)o)->getNominalGain)());
  else   (((const ::HcalLutMetadata*)o)->getNominalGain)();
}

static void destructor_4293(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalLutMetadata*)o)->::HcalLutMetadata::~HcalLutMetadata)();
}
static void method_newdel_1491( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalLutMetadata >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalLutMetadata >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalLutMetadata >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalLutMetadata >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalLutMetadata >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x87( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalLutMetadatum>")), ::Reflex::BaseOffset< ::HcalLutMetadata,::HcalCondObjectContainer<HcalLutMetadatum> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalLutMetadata,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalLutMetadata -------------------------------
void __HcalLutMetadata_db_datamem(Reflex::Class*);
void __HcalLutMetadata_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalLutMetadata_datamem_bld(&__HcalLutMetadata_db_datamem);
Reflex::GenreflexMemberBuilder __HcalLutMetadata_funcmem_bld(&__HcalLutMetadata_db_funcmem);
void __HcalLutMetadata_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalLutMetadata"), typeid(::HcalLutMetadata), sizeof(::HcalLutMetadata), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("class_version"), "0")
  .AddBase(type_178, ::Reflex::BaseOffset< ::HcalLutMetadata, ::HcalCondObjectContainer<HcalLutMetadatum> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11972, type_11973), Reflex::Literal("operator="), operator_4284, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11973), Reflex::Literal("HcalLutMetadata"), constructor_4285, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalLutMetadata"), constructor_4286, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalLutMetadata"), constructor_4287, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalLutMetadata"), destructor_4293, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1491, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x87, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalLutMetadata_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalLutMetadata_funcmem_bld);
}

//------Delayed data member builder for class HcalLutMetadata -------------------
void __HcalLutMetadata_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4282, Reflex::Literal("mNonChannelData"), OffsetOf(__shadow__::__HcalLutMetadata, mNonChannelData), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class HcalLutMetadata -------------------
void __HcalLutMetadata_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_4288, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_1181), Reflex::Literal("setRctLsb"), method_4289, 0, "rctlsb", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getRctLsb"), method_4290, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461, type_1181), Reflex::Literal("setNominalGain"), method_4291, 0, "gain", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181), Reflex::Literal("getNominalGain"), method_4292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalRespCorrs -------------------------------
static  void operator_4315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalRespCorrs*)o)->operator=)(*(const ::HcalRespCorrs*)arg[0]);
  else   (((::HcalRespCorrs*)o)->operator=)(*(const ::HcalRespCorrs*)arg[0]);
}

static void constructor_4316( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRespCorrs(*(const ::HcalRespCorrs*)arg[0]);
  else ::new(mem) ::HcalRespCorrs(*(const ::HcalRespCorrs*)arg[0]);
}

static void constructor_4317( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRespCorrs();
  else ::new(mem) ::HcalRespCorrs();
}

static void constructor_4318( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalRespCorrs((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalRespCorrs((const ::HcalTopology*)arg[0]);
}

static  void method_4319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalRespCorrs*)o)->myname)());
  else   (((const ::HcalRespCorrs*)o)->myname)();
}

static void destructor_4320(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalRespCorrs*)o)->::HcalRespCorrs::~HcalRespCorrs)();
}
static void method_newdel_1567( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalRespCorrs >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalRespCorrs >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalRespCorrs >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalRespCorrs >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalRespCorrs >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x89( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalRespCorr>")), ::Reflex::BaseOffset< ::HcalRespCorrs,::HcalCondObjectContainer<HcalRespCorr> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalRespCorrs,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalRespCorrs -------------------------------
void __HcalRespCorrs_db_datamem(Reflex::Class*);
void __HcalRespCorrs_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalRespCorrs_datamem_bld(&__HcalRespCorrs_db_datamem);
Reflex::GenreflexMemberBuilder __HcalRespCorrs_funcmem_bld(&__HcalRespCorrs_db_funcmem);
void __HcalRespCorrs_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalRespCorrs"), typeid(::HcalRespCorrs), sizeof(::HcalRespCorrs), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_184, ::Reflex::BaseOffset< ::HcalRespCorrs, ::HcalCondObjectContainer<HcalRespCorr> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11975, type_11976), Reflex::Literal("operator="), operator_4315, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11976), Reflex::Literal("HcalRespCorrs"), constructor_4316, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalRespCorrs"), constructor_4317, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalRespCorrs"), constructor_4318, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalRespCorrs"), destructor_4320, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1567, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x89, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalRespCorrs_funcmem_bld);
}

//------Delayed data member builder for class HcalRespCorrs -------------------
void __HcalRespCorrs_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalRespCorrs -------------------
void __HcalRespCorrs_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_4319, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class HcalCholeskyMatrix -------------------------------
static void destructor_4442(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCholeskyMatrix*)o)->::HcalCholeskyMatrix::~HcalCholeskyMatrix)();
}
static  void operator_4443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCholeskyMatrix*)o)->operator=)(*(const ::HcalCholeskyMatrix*)arg[0]);
  else   (((::HcalCholeskyMatrix*)o)->operator=)(*(const ::HcalCholeskyMatrix*)arg[0]);
}

static void constructor_4444( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCholeskyMatrix(*(const ::HcalCholeskyMatrix*)arg[0]);
  else ::new(mem) ::HcalCholeskyMatrix(*(const ::HcalCholeskyMatrix*)arg[0]);
}

static void constructor_4445( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCholeskyMatrix();
  else ::new(mem) ::HcalCholeskyMatrix();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCholeskyMatrix(*(int*)arg[0]);
  else ::new(mem) ::HcalCholeskyMatrix(*(int*)arg[0]);
  }
}

static  void method_4446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalCholeskyMatrix*)o)->getValue)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]));
  else   (((const ::HcalCholeskyMatrix*)o)->getValue)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_4447( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalCholeskyMatrix*)o)->setValue)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(float*)arg[3]);
}

static  void method_4448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalCholeskyMatrix*)o)->rawId)());
  else   (((const ::HcalCholeskyMatrix*)o)->rawId)();
}

static void constructor_x90( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCholeskyMatrix();
  else ::new(mem) ::HcalCholeskyMatrix();
}

static void method_newdel_1671( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalCholeskyMatrix >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalCholeskyMatrix >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalCholeskyMatrix >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalCholeskyMatrix >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalCholeskyMatrix >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalCholeskyMatrix -------------------------------
void __HcalCholeskyMatrix_db_datamem(Reflex::Class*);
void __HcalCholeskyMatrix_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCholeskyMatrix_datamem_bld(&__HcalCholeskyMatrix_db_datamem);
Reflex::GenreflexMemberBuilder __HcalCholeskyMatrix_funcmem_bld(&__HcalCholeskyMatrix_db_funcmem);
void __HcalCholeskyMatrix_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCholeskyMatrix"), typeid(::HcalCholeskyMatrix), sizeof(::HcalCholeskyMatrix), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCholeskyMatrix"), destructor_4442, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5971, type_5973), Reflex::Literal("operator="), operator_4443, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5973), Reflex::Literal("HcalCholeskyMatrix"), constructor_4444, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_101), Reflex::Literal("HcalCholeskyMatrix"), constructor_4445, 0, "fId=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalCholeskyMatrix"), constructor_x90, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1671, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalCholeskyMatrix_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalCholeskyMatrix_funcmem_bld);
}

//------Delayed data member builder for class HcalCholeskyMatrix -------------------
void __HcalCholeskyMatrix_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_12362, Reflex::Literal("cmatrix"), OffsetOf(__shadow__::__HcalCholeskyMatrix, cmatrix), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalCholeskyMatrix, mId), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalCholeskyMatrix -------------------
void __HcalCholeskyMatrix_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1181, type_101, type_101, type_101), Reflex::Literal("getValue"), method_4446, 0, "capid;i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_101, type_101, type_101, type_1181), Reflex::Literal("setValue"), method_4447, 0, "capid;i;j;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_370), Reflex::Literal("rawId"), method_4448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalTimingParams -------------------------------
static  void operator_4459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalTimingParams*)o)->operator=)(*(const ::HcalTimingParams*)arg[0]);
  else   (((::HcalTimingParams*)o)->operator=)(*(const ::HcalTimingParams*)arg[0]);
}

static void constructor_4460( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimingParams(*(const ::HcalTimingParams*)arg[0]);
  else ::new(mem) ::HcalTimingParams(*(const ::HcalTimingParams*)arg[0]);
}

static void constructor_4461( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimingParams();
  else ::new(mem) ::HcalTimingParams();
}

static void constructor_4462( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTimingParams((const ::HcalTopology*)arg[0]);
  else ::new(mem) ::HcalTimingParams((const ::HcalTopology*)arg[0]);
}

static  void method_4463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalTimingParams*)o)->myname)());
  else   (((const ::HcalTimingParams*)o)->myname)();
}

static void destructor_4464(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalTimingParams*)o)->::HcalTimingParams::~HcalTimingParams)();
}
static void method_newdel_1729( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalTimingParams >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalTimingParams >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalTimingParams >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalTimingParams >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalTimingParams >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x93( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainer<HcalTimingParam>")), ::Reflex::BaseOffset< ::HcalTimingParams,::HcalCondObjectContainer<HcalTimingParam> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalCondObjectContainerBase")), ::Reflex::BaseOffset< ::HcalTimingParams,::HcalCondObjectContainerBase >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalTimingParams -------------------------------
void __HcalTimingParams_db_datamem(Reflex::Class*);
void __HcalTimingParams_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalTimingParams_datamem_bld(&__HcalTimingParams_db_datamem);
Reflex::GenreflexMemberBuilder __HcalTimingParams_funcmem_bld(&__HcalTimingParams_db_funcmem);
void __HcalTimingParams_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalTimingParams"), typeid(::HcalTimingParams), sizeof(::HcalTimingParams), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("class_version"), "0")
  .AddBase(type_173, ::Reflex::BaseOffset< ::HcalTimingParams, ::HcalCondObjectContainer<HcalTimingParam> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12365, type_12366), Reflex::Literal("operator="), operator_4459, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12366), Reflex::Literal("HcalTimingParams"), constructor_4460, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalTimingParams"), constructor_4461, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9860), Reflex::Literal("HcalTimingParams"), constructor_4462, 0, "topo", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalTimingParams"), destructor_4464, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1729, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x93, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalTimingParams_funcmem_bld);
}

//------Delayed data member builder for class HcalTimingParams -------------------
void __HcalTimingParams_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalTimingParams -------------------
void __HcalTimingParams_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1934), Reflex::Literal("myname"), method_4463, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<HcalTimingParam,std::allocator<HcalTimingParam> > -------------------------------
static void constructor_5398( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimingParam>();
  else ::new(mem) ::std::vector<HcalTimingParam>();
}

static void constructor_5399( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimingParam>(*(const ::std::allocator<HcalTimingParam>*)arg[0]);
  else ::new(mem) ::std::vector<HcalTimingParam>(*(const ::std::allocator<HcalTimingParam>*)arg[0]);
}

static void constructor_5400( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimingParam>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalTimingParam>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimingParam>(*(::std::size_t*)arg[0],
      *(const ::HcalTimingParam*)arg[1]);
  else ::new(mem) ::std::vector<HcalTimingParam>(*(::std::size_t*)arg[0],
      *(const ::HcalTimingParam*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimingParam>(*(::std::size_t*)arg[0],
      *(const ::HcalTimingParam*)arg[1],
      *(const ::std::allocator<HcalTimingParam>*)arg[2]);
  else ::new(mem) ::std::vector<HcalTimingParam>(*(::std::size_t*)arg[0],
      *(const ::HcalTimingParam*)arg[1],
      *(const ::std::allocator<HcalTimingParam>*)arg[2]);
  }
}

static void constructor_5401( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimingParam>(*(const ::std::vector<HcalTimingParam>*)arg[0]);
  else ::new(mem) ::std::vector<HcalTimingParam>(*(const ::std::vector<HcalTimingParam>*)arg[0]);
}

static void destructor_5402(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalTimingParam>*)o)->::std::vector<HcalTimingParam>::~vector)();
}
static  void operator_5403( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalTimingParam>*)o)->operator=)(*(const ::std::vector<HcalTimingParam>*)arg[0]);
  else   (((::std::vector<HcalTimingParam>*)o)->operator=)(*(const ::std::vector<HcalTimingParam>*)arg[0]);
}

static  void method_5404( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalTimingParam>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalTimingParam*)arg[1]);
}

static  void method_5405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >)((((::std::vector<HcalTimingParam>*)o)->begin)());
  else   (((::std::vector<HcalTimingParam>*)o)->begin)();
}

static  void method_5406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalTimingParam*,std::vector<HcalTimingParam> >)((((const ::std::vector<HcalTimingParam>*)o)->begin)());
  else   (((const ::std::vector<HcalTimingParam>*)o)->begin)();
}

static  void method_5407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >)((((::std::vector<HcalTimingParam>*)o)->end)());
  else   (((::std::vector<HcalTimingParam>*)o)->end)();
}

static  void method_5408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalTimingParam*,std::vector<HcalTimingParam> >)((((const ::std::vector<HcalTimingParam>*)o)->end)());
  else   (((const ::std::vector<HcalTimingParam>*)o)->end)();
}

static  void method_5413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalTimingParam>*)o)->size)());
  else   (((const ::std::vector<HcalTimingParam>*)o)->size)();
}

static  void method_5414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalTimingParam>*)o)->max_size)());
  else   (((const ::std::vector<HcalTimingParam>*)o)->max_size)();
}

static  void method_5415( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalTimingParam>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalTimingParam>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalTimingParam*)arg[1]);
  }
}

static  void method_5416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalTimingParam>*)o)->capacity)());
  else   (((const ::std::vector<HcalTimingParam>*)o)->capacity)();
}

static  void method_5417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalTimingParam>*)o)->empty)());
  else   (((const ::std::vector<HcalTimingParam>*)o)->empty)();
}

static  void method_5418( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalTimingParam>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5419( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalTimingParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalTimingParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5420( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalTimingParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalTimingParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5422( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalTimingParam>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalTimingParam>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalTimingParam>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalTimingParam>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalTimingParam>*)o)->front)();
  else   (((::std::vector<HcalTimingParam>*)o)->front)();
}

static  void method_5425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalTimingParam>*)o)->front)();
  else   (((const ::std::vector<HcalTimingParam>*)o)->front)();
}

static  void method_5426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalTimingParam>*)o)->back)();
  else   (((::std::vector<HcalTimingParam>*)o)->back)();
}

static  void method_5427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalTimingParam>*)o)->back)();
  else   (((const ::std::vector<HcalTimingParam>*)o)->back)();
}

static  void method_5428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalTimingParam>*)o)->data)());
  else   (((::std::vector<HcalTimingParam>*)o)->data)();
}

static  void method_5429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalTimingParam>*)o)->data)());
  else   (((const ::std::vector<HcalTimingParam>*)o)->data)();
}

static  void method_5430( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalTimingParam>*)o)->push_back)(*(const ::HcalTimingParam*)arg[0]);
}

static  void method_5431( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalTimingParam>*)o)->pop_back)();
}

static  void method_5432( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >)((((::std::vector<HcalTimingParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >*)arg[0],
    *(const ::HcalTimingParam*)arg[1]));
  else   (((::std::vector<HcalTimingParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >*)arg[0],
    *(const ::HcalTimingParam*)arg[1]);
}

static  void method_5433( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalTimingParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalTimingParam*)arg[2]);
}

static  void method_5434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >)((((::std::vector<HcalTimingParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >*)arg[0]));
  else   (((::std::vector<HcalTimingParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >*)arg[0]);
}

static  void method_5435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >)((((::std::vector<HcalTimingParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >*)arg[1]));
  else   (((::std::vector<HcalTimingParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalTimingParam*,std::vector<HcalTimingParam> >*)arg[1]);
}

static  void method_5436( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalTimingParam>*)o)->swap)(*(::std::vector<HcalTimingParam>*)arg[0]);
}

static  void method_5437( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalTimingParam>*)o)->clear)();
}

static void method_newdel_1849( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalTimingParam> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalTimingParam> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalTimingParam> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalTimingParam> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalTimingParam> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x95( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalTimingParam,std::allocator<HcalTimingParam> >")), ::Reflex::BaseOffset< ::std::vector<HcalTimingParam>,::std::_Vector_base<HcalTimingParam,std::allocator<HcalTimingParam> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x96( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalTimingParam> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalTimingParam> >::Generate();
}

//------Dictionary for class vector<HcalTimingParam,std::allocator<HcalTimingParam> > -------------------------------
void __std__vector_HcalTimingParam__db_datamem(Reflex::Class*);
void __std__vector_HcalTimingParam__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalTimingParam__datamem_bld(&__std__vector_HcalTimingParam__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalTimingParam__funcmem_bld(&__std__vector_HcalTimingParam__db_funcmem);
void __std__vector_HcalTimingParam__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalTimingParam>"), typeid(::std::vector<HcalTimingParam>), sizeof(::std::vector<HcalTimingParam>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1790, ::Reflex::BaseOffset< ::std::vector<HcalTimingParam>, ::std::_Vector_base<HcalTimingParam,std::allocator<HcalTimingParam> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_103, Reflex::Literal("std::vector<HcalTimingParam>::_Alloc_value_type"))
  .AddTypedef(type_1790, Reflex::Literal("std::vector<HcalTimingParam>::_Base"))
  .AddTypedef(type_2137, Reflex::Literal("std::vector<HcalTimingParam>::_Tp_alloc_type"))
  .AddTypedef(type_3885, Reflex::Literal("std::vector<HcalTimingParam>::_Alloc_traits"))
  .AddTypedef(type_103, Reflex::Literal("std::vector<HcalTimingParam>::value_type"))
  .AddTypedef(type_4693, Reflex::Literal("std::vector<HcalTimingParam>::pointer"))
  .AddTypedef(type_5385, Reflex::Literal("std::vector<HcalTimingParam>::const_pointer"))
  .AddTypedef(type_5387, Reflex::Literal("std::vector<HcalTimingParam>::reference"))
  .AddTypedef(type_5389, Reflex::Literal("std::vector<HcalTimingParam>::const_reference"))
  .AddTypedef(type_3791, Reflex::Literal("std::vector<HcalTimingParam>::iterator"))
  .AddTypedef(type_3792, Reflex::Literal("std::vector<HcalTimingParam>::const_iterator"))
  .AddTypedef(type_2266, Reflex::Literal("std::vector<HcalTimingParam>::const_reverse_iterator"))
  .AddTypedef(type_2267, Reflex::Literal("std::vector<HcalTimingParam>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalTimingParam>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalTimingParam>::difference_type"))
  .AddTypedef(type_2137, Reflex::Literal("std::vector<HcalTimingParam>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5398, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12395), Reflex::Literal("vector"), constructor_5399, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_5389, type_12395), Reflex::Literal("vector"), constructor_5400, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12839), Reflex::Literal("vector"), constructor_5401, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5402, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1849, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x95, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x96, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalTimingParam__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalTimingParam,std::allocator<HcalTimingParam> > -------------------
void __std__vector_HcalTimingParam__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalTimingParam,std::allocator<HcalTimingParam> > -------------------
void __std__vector_HcalTimingParam__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12840, type_12839), Reflex::Literal("operator="), operator_5403, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_5389), Reflex::Literal("assign"), method_5404, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3791), Reflex::Literal("begin"), method_5405, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3792), Reflex::Literal("begin"), method_5406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3791), Reflex::Literal("end"), method_5407, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3792), Reflex::Literal("end"), method_5408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_5413, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_5414, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_103), Reflex::Literal("resize"), method_5415, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_5416, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_5417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_5418, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5387, type_2122), Reflex::Literal("operator[]"), operator_5419, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5389, type_2122), Reflex::Literal("operator[]"), operator_5420, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5387, type_2122), Reflex::Literal("at"), method_5422, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5389, type_2122), Reflex::Literal("at"), method_5423, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5387), Reflex::Literal("front"), method_5424, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5389), Reflex::Literal("front"), method_5425, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5387), Reflex::Literal("back"), method_5426, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5389), Reflex::Literal("back"), method_5427, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4693), Reflex::Literal("data"), method_5428, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5385), Reflex::Literal("data"), method_5429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_5389), Reflex::Literal("push_back"), method_5430, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_5431, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3791, type_3791, type_5389), Reflex::Literal("insert"), method_5432, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3791, type_2122, type_5389), Reflex::Literal("insert"), method_5433, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3791, type_3791), Reflex::Literal("erase"), method_5434, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3791, type_3791, type_3791), Reflex::Literal("erase"), method_5435, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12840), Reflex::Literal("swap"), method_5436, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_5437, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalFlagHFDigiTimeParam,std::allocator<HcalFlagHFDigiTimeParam> > -------------------------------
static void constructor_5463( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>();
  else ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>();
}

static void constructor_5464( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>(*(const ::std::allocator<HcalFlagHFDigiTimeParam>*)arg[0]);
  else ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>(*(const ::std::allocator<HcalFlagHFDigiTimeParam>*)arg[0]);
}

static void constructor_5465( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>(*(::std::size_t*)arg[0],
      *(const ::HcalFlagHFDigiTimeParam*)arg[1]);
  else ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>(*(::std::size_t*)arg[0],
      *(const ::HcalFlagHFDigiTimeParam*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>(*(::std::size_t*)arg[0],
      *(const ::HcalFlagHFDigiTimeParam*)arg[1],
      *(const ::std::allocator<HcalFlagHFDigiTimeParam>*)arg[2]);
  else ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>(*(::std::size_t*)arg[0],
      *(const ::HcalFlagHFDigiTimeParam*)arg[1],
      *(const ::std::allocator<HcalFlagHFDigiTimeParam>*)arg[2]);
  }
}

static void constructor_5466( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>(*(const ::std::vector<HcalFlagHFDigiTimeParam>*)arg[0]);
  else ::new(mem) ::std::vector<HcalFlagHFDigiTimeParam>(*(const ::std::vector<HcalFlagHFDigiTimeParam>*)arg[0]);
}

static void destructor_5467(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalFlagHFDigiTimeParam>*)o)->::std::vector<HcalFlagHFDigiTimeParam>::~vector)();
}
static  void operator_5468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalFlagHFDigiTimeParam>*)o)->operator=)(*(const ::std::vector<HcalFlagHFDigiTimeParam>*)arg[0]);
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->operator=)(*(const ::std::vector<HcalFlagHFDigiTimeParam>*)arg[0]);
}

static  void method_5469( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalFlagHFDigiTimeParam*)arg[1]);
}

static  void method_5470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >)((((::std::vector<HcalFlagHFDigiTimeParam>*)o)->begin)());
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->begin)();
}

static  void method_5471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >)((((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->begin)());
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->begin)();
}

static  void method_5472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >)((((::std::vector<HcalFlagHFDigiTimeParam>*)o)->end)());
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->end)();
}

static  void method_5473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >)((((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->end)());
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->end)();
}

static  void method_5478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->size)());
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->size)();
}

static  void method_5479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->max_size)());
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->max_size)();
}

static  void method_5480( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalFlagHFDigiTimeParam*)arg[1]);
  }
}

static  void method_5481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->capacity)());
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->capacity)();
}

static  void method_5482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->empty)());
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->empty)();
}

static  void method_5483( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5484( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalFlagHFDigiTimeParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5485( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalFlagHFDigiTimeParam>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5489( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalFlagHFDigiTimeParam>*)o)->front)();
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->front)();
}

static  void method_5490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->front)();
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->front)();
}

static  void method_5491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalFlagHFDigiTimeParam>*)o)->back)();
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->back)();
}

static  void method_5492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->back)();
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->back)();
}

static  void method_5493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalFlagHFDigiTimeParam>*)o)->data)());
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->data)();
}

static  void method_5494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->data)());
  else   (((const ::std::vector<HcalFlagHFDigiTimeParam>*)o)->data)();
}

static  void method_5495( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->push_back)(*(const ::HcalFlagHFDigiTimeParam*)arg[0]);
}

static  void method_5496( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->pop_back)();
}

static  void method_5497( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >)((((::std::vector<HcalFlagHFDigiTimeParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >*)arg[0],
    *(const ::HcalFlagHFDigiTimeParam*)arg[1]));
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >*)arg[0],
    *(const ::HcalFlagHFDigiTimeParam*)arg[1]);
}

static  void method_5498( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalFlagHFDigiTimeParam*)arg[2]);
}

static  void method_5499( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >)((((::std::vector<HcalFlagHFDigiTimeParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >*)arg[0]));
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >*)arg[0]);
}

static  void method_5500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >)((((::std::vector<HcalFlagHFDigiTimeParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >*)arg[1]));
  else   (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalFlagHFDigiTimeParam*,std::vector<HcalFlagHFDigiTimeParam> >*)arg[1]);
}

static  void method_5501( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->swap)(*(::std::vector<HcalFlagHFDigiTimeParam>*)arg[0]);
}

static  void method_5502( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalFlagHFDigiTimeParam>*)o)->clear)();
}

static void method_newdel_1850( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalFlagHFDigiTimeParam> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalFlagHFDigiTimeParam> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalFlagHFDigiTimeParam> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalFlagHFDigiTimeParam> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalFlagHFDigiTimeParam> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x98( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalFlagHFDigiTimeParam,std::allocator<HcalFlagHFDigiTimeParam> >")), ::Reflex::BaseOffset< ::std::vector<HcalFlagHFDigiTimeParam>,::std::_Vector_base<HcalFlagHFDigiTimeParam,std::allocator<HcalFlagHFDigiTimeParam> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x99( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalFlagHFDigiTimeParam> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalFlagHFDigiTimeParam> >::Generate();
}

//------Dictionary for class vector<HcalFlagHFDigiTimeParam,std::allocator<HcalFlagHFDigiTimeParam> > -------------------------------
void __std__vector_HcalFlagHFDigiTimeParam__db_datamem(Reflex::Class*);
void __std__vector_HcalFlagHFDigiTimeParam__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalFlagHFDigiTimeParam__datamem_bld(&__std__vector_HcalFlagHFDigiTimeParam__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalFlagHFDigiTimeParam__funcmem_bld(&__std__vector_HcalFlagHFDigiTimeParam__db_funcmem);
void __std__vector_HcalFlagHFDigiTimeParam__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>"), typeid(::std::vector<HcalFlagHFDigiTimeParam>), sizeof(::std::vector<HcalFlagHFDigiTimeParam>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1791, ::Reflex::BaseOffset< ::std::vector<HcalFlagHFDigiTimeParam>, ::std::_Vector_base<HcalFlagHFDigiTimeParam,std::allocator<HcalFlagHFDigiTimeParam> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1145, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::_Alloc_value_type"))
  .AddTypedef(type_1791, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::_Base"))
  .AddTypedef(type_2138, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::_Tp_alloc_type"))
  .AddTypedef(type_3886, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::_Alloc_traits"))
  .AddTypedef(type_1145, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::value_type"))
  .AddTypedef(type_4712, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::pointer"))
  .AddTypedef(type_5450, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::const_pointer"))
  .AddTypedef(type_5452, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::reference"))
  .AddTypedef(type_5454, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::const_reference"))
  .AddTypedef(type_3793, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::iterator"))
  .AddTypedef(type_3794, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::const_iterator"))
  .AddTypedef(type_2268, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::const_reverse_iterator"))
  .AddTypedef(type_2269, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::difference_type"))
  .AddTypedef(type_2138, Reflex::Literal("std::vector<HcalFlagHFDigiTimeParam>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5463, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12408), Reflex::Literal("vector"), constructor_5464, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_5454, type_12408), Reflex::Literal("vector"), constructor_5465, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12842), Reflex::Literal("vector"), constructor_5466, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5467, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1850, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x98, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x99, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalFlagHFDigiTimeParam__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalFlagHFDigiTimeParam,std::allocator<HcalFlagHFDigiTimeParam> > -------------------
void __std__vector_HcalFlagHFDigiTimeParam__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalFlagHFDigiTimeParam,std::allocator<HcalFlagHFDigiTimeParam> > -------------------
void __std__vector_HcalFlagHFDigiTimeParam__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12843, type_12842), Reflex::Literal("operator="), operator_5468, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_5454), Reflex::Literal("assign"), method_5469, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3793), Reflex::Literal("begin"), method_5470, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3794), Reflex::Literal("begin"), method_5471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3793), Reflex::Literal("end"), method_5472, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3794), Reflex::Literal("end"), method_5473, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_5478, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_5479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1145), Reflex::Literal("resize"), method_5480, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_5481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_5482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_5483, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5452, type_2122), Reflex::Literal("operator[]"), operator_5484, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5454, type_2122), Reflex::Literal("operator[]"), operator_5485, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5452, type_2122), Reflex::Literal("at"), method_5487, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5454, type_2122), Reflex::Literal("at"), method_5488, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5452), Reflex::Literal("front"), method_5489, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5454), Reflex::Literal("front"), method_5490, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5452), Reflex::Literal("back"), method_5491, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5454), Reflex::Literal("back"), method_5492, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4712), Reflex::Literal("data"), method_5493, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5450), Reflex::Literal("data"), method_5494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_5454), Reflex::Literal("push_back"), method_5495, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_5496, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3793, type_3793, type_5454), Reflex::Literal("insert"), method_5497, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3793, type_2122, type_5454), Reflex::Literal("insert"), method_5498, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3793, type_3793), Reflex::Literal("erase"), method_5499, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3793, type_3793, type_3793), Reflex::Literal("erase"), method_5500, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12843), Reflex::Literal("swap"), method_5501, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_5502, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalMCParam,std::allocator<HcalMCParam> > -------------------------------
static void constructor_5528( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalMCParam>();
  else ::new(mem) ::std::vector<HcalMCParam>();
}

static void constructor_5529( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalMCParam>(*(const ::std::allocator<HcalMCParam>*)arg[0]);
  else ::new(mem) ::std::vector<HcalMCParam>(*(const ::std::allocator<HcalMCParam>*)arg[0]);
}

static void constructor_5530( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalMCParam>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalMCParam>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalMCParam>(*(::std::size_t*)arg[0],
      *(const ::HcalMCParam*)arg[1]);
  else ::new(mem) ::std::vector<HcalMCParam>(*(::std::size_t*)arg[0],
      *(const ::HcalMCParam*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalMCParam>(*(::std::size_t*)arg[0],
      *(const ::HcalMCParam*)arg[1],
      *(const ::std::allocator<HcalMCParam>*)arg[2]);
  else ::new(mem) ::std::vector<HcalMCParam>(*(::std::size_t*)arg[0],
      *(const ::HcalMCParam*)arg[1],
      *(const ::std::allocator<HcalMCParam>*)arg[2]);
  }
}

static void constructor_5531( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalMCParam>(*(const ::std::vector<HcalMCParam>*)arg[0]);
  else ::new(mem) ::std::vector<HcalMCParam>(*(const ::std::vector<HcalMCParam>*)arg[0]);
}

static void destructor_5532(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalMCParam>*)o)->::std::vector<HcalMCParam>::~vector)();
}
static  void operator_5533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalMCParam>*)o)->operator=)(*(const ::std::vector<HcalMCParam>*)arg[0]);
  else   (((::std::vector<HcalMCParam>*)o)->operator=)(*(const ::std::vector<HcalMCParam>*)arg[0]);
}

static  void method_5534( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalMCParam>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalMCParam*)arg[1]);
}

static  void method_5535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >)((((::std::vector<HcalMCParam>*)o)->begin)());
  else   (((::std::vector<HcalMCParam>*)o)->begin)();
}

static  void method_5536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalMCParam*,std::vector<HcalMCParam> >)((((const ::std::vector<HcalMCParam>*)o)->begin)());
  else   (((const ::std::vector<HcalMCParam>*)o)->begin)();
}

static  void method_5537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >)((((::std::vector<HcalMCParam>*)o)->end)());
  else   (((::std::vector<HcalMCParam>*)o)->end)();
}

static  void method_5538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalMCParam*,std::vector<HcalMCParam> >)((((const ::std::vector<HcalMCParam>*)o)->end)());
  else   (((const ::std::vector<HcalMCParam>*)o)->end)();
}

static  void method_5543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalMCParam>*)o)->size)());
  else   (((const ::std::vector<HcalMCParam>*)o)->size)();
}

static  void method_5544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalMCParam>*)o)->max_size)());
  else   (((const ::std::vector<HcalMCParam>*)o)->max_size)();
}

static  void method_5545( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalMCParam>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalMCParam>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalMCParam*)arg[1]);
  }
}

static  void method_5546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalMCParam>*)o)->capacity)());
  else   (((const ::std::vector<HcalMCParam>*)o)->capacity)();
}

static  void method_5547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalMCParam>*)o)->empty)());
  else   (((const ::std::vector<HcalMCParam>*)o)->empty)();
}

static  void method_5548( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalMCParam>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalMCParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalMCParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalMCParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalMCParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalMCParam>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalMCParam>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalMCParam>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalMCParam>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalMCParam>*)o)->front)();
  else   (((::std::vector<HcalMCParam>*)o)->front)();
}

static  void method_5555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalMCParam>*)o)->front)();
  else   (((const ::std::vector<HcalMCParam>*)o)->front)();
}

static  void method_5556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalMCParam>*)o)->back)();
  else   (((::std::vector<HcalMCParam>*)o)->back)();
}

static  void method_5557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalMCParam>*)o)->back)();
  else   (((const ::std::vector<HcalMCParam>*)o)->back)();
}

static  void method_5558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalMCParam>*)o)->data)());
  else   (((::std::vector<HcalMCParam>*)o)->data)();
}

static  void method_5559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalMCParam>*)o)->data)());
  else   (((const ::std::vector<HcalMCParam>*)o)->data)();
}

static  void method_5560( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalMCParam>*)o)->push_back)(*(const ::HcalMCParam*)arg[0]);
}

static  void method_5561( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalMCParam>*)o)->pop_back)();
}

static  void method_5562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >)((((::std::vector<HcalMCParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >*)arg[0],
    *(const ::HcalMCParam*)arg[1]));
  else   (((::std::vector<HcalMCParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >*)arg[0],
    *(const ::HcalMCParam*)arg[1]);
}

static  void method_5563( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalMCParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalMCParam*)arg[2]);
}

static  void method_5564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >)((((::std::vector<HcalMCParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >*)arg[0]));
  else   (((::std::vector<HcalMCParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >*)arg[0]);
}

static  void method_5565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >)((((::std::vector<HcalMCParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >*)arg[1]));
  else   (((::std::vector<HcalMCParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalMCParam*,std::vector<HcalMCParam> >*)arg[1]);
}

static  void method_5566( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalMCParam>*)o)->swap)(*(::std::vector<HcalMCParam>*)arg[0]);
}

static  void method_5567( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalMCParam>*)o)->clear)();
}

static void method_newdel_1851( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalMCParam> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalMCParam> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalMCParam> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalMCParam> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalMCParam> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x101( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalMCParam,std::allocator<HcalMCParam> >")), ::Reflex::BaseOffset< ::std::vector<HcalMCParam>,::std::_Vector_base<HcalMCParam,std::allocator<HcalMCParam> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x102( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalMCParam> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalMCParam> >::Generate();
}

//------Dictionary for class vector<HcalMCParam,std::allocator<HcalMCParam> > -------------------------------
void __std__vector_HcalMCParam__db_datamem(Reflex::Class*);
void __std__vector_HcalMCParam__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalMCParam__datamem_bld(&__std__vector_HcalMCParam__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalMCParam__funcmem_bld(&__std__vector_HcalMCParam__db_funcmem);
void __std__vector_HcalMCParam__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalMCParam>"), typeid(::std::vector<HcalMCParam>), sizeof(::std::vector<HcalMCParam>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1793, ::Reflex::BaseOffset< ::std::vector<HcalMCParam>, ::std::_Vector_base<HcalMCParam,std::allocator<HcalMCParam> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1074, Reflex::Literal("std::vector<HcalMCParam>::_Alloc_value_type"))
  .AddTypedef(type_1793, Reflex::Literal("std::vector<HcalMCParam>::_Base"))
  .AddTypedef(type_2139, Reflex::Literal("std::vector<HcalMCParam>::_Tp_alloc_type"))
  .AddTypedef(type_3888, Reflex::Literal("std::vector<HcalMCParam>::_Alloc_traits"))
  .AddTypedef(type_1074, Reflex::Literal("std::vector<HcalMCParam>::value_type"))
  .AddTypedef(type_4749, Reflex::Literal("std::vector<HcalMCParam>::pointer"))
  .AddTypedef(type_5515, Reflex::Literal("std::vector<HcalMCParam>::const_pointer"))
  .AddTypedef(type_5517, Reflex::Literal("std::vector<HcalMCParam>::reference"))
  .AddTypedef(type_5519, Reflex::Literal("std::vector<HcalMCParam>::const_reference"))
  .AddTypedef(type_3797, Reflex::Literal("std::vector<HcalMCParam>::iterator"))
  .AddTypedef(type_3798, Reflex::Literal("std::vector<HcalMCParam>::const_iterator"))
  .AddTypedef(type_2272, Reflex::Literal("std::vector<HcalMCParam>::const_reverse_iterator"))
  .AddTypedef(type_2273, Reflex::Literal("std::vector<HcalMCParam>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalMCParam>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalMCParam>::difference_type"))
  .AddTypedef(type_2139, Reflex::Literal("std::vector<HcalMCParam>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5528, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12434), Reflex::Literal("vector"), constructor_5529, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_5519, type_12434), Reflex::Literal("vector"), constructor_5530, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12845), Reflex::Literal("vector"), constructor_5531, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5532, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1851, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x101, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x102, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalMCParam__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalMCParam,std::allocator<HcalMCParam> > -------------------
void __std__vector_HcalMCParam__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalMCParam,std::allocator<HcalMCParam> > -------------------
void __std__vector_HcalMCParam__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12846, type_12845), Reflex::Literal("operator="), operator_5533, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_5519), Reflex::Literal("assign"), method_5534, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3797), Reflex::Literal("begin"), method_5535, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3798), Reflex::Literal("begin"), method_5536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3797), Reflex::Literal("end"), method_5537, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3798), Reflex::Literal("end"), method_5538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_5543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_5544, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1074), Reflex::Literal("resize"), method_5545, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_5546, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_5547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_5548, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5517, type_2122), Reflex::Literal("operator[]"), operator_5549, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5519, type_2122), Reflex::Literal("operator[]"), operator_5550, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5517, type_2122), Reflex::Literal("at"), method_5552, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5519, type_2122), Reflex::Literal("at"), method_5553, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5517), Reflex::Literal("front"), method_5554, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5519), Reflex::Literal("front"), method_5555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5517), Reflex::Literal("back"), method_5556, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5519), Reflex::Literal("back"), method_5557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4749), Reflex::Literal("data"), method_5558, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5515), Reflex::Literal("data"), method_5559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_5519), Reflex::Literal("push_back"), method_5560, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_5561, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3797, type_3797, type_5519), Reflex::Literal("insert"), method_5562, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3797, type_2122, type_5519), Reflex::Literal("insert"), method_5563, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3797, type_3797), Reflex::Literal("erase"), method_5564, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3797, type_3797, type_3797), Reflex::Literal("erase"), method_5565, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12846), Reflex::Literal("swap"), method_5566, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_5567, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalRecoParam,std::allocator<HcalRecoParam> > -------------------------------
static void constructor_5593( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRecoParam>();
  else ::new(mem) ::std::vector<HcalRecoParam>();
}

static void constructor_5594( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRecoParam>(*(const ::std::allocator<HcalRecoParam>*)arg[0]);
  else ::new(mem) ::std::vector<HcalRecoParam>(*(const ::std::allocator<HcalRecoParam>*)arg[0]);
}

static void constructor_5595( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRecoParam>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalRecoParam>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRecoParam>(*(::std::size_t*)arg[0],
      *(const ::HcalRecoParam*)arg[1]);
  else ::new(mem) ::std::vector<HcalRecoParam>(*(::std::size_t*)arg[0],
      *(const ::HcalRecoParam*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRecoParam>(*(::std::size_t*)arg[0],
      *(const ::HcalRecoParam*)arg[1],
      *(const ::std::allocator<HcalRecoParam>*)arg[2]);
  else ::new(mem) ::std::vector<HcalRecoParam>(*(::std::size_t*)arg[0],
      *(const ::HcalRecoParam*)arg[1],
      *(const ::std::allocator<HcalRecoParam>*)arg[2]);
  }
}

static void constructor_5596( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRecoParam>(*(const ::std::vector<HcalRecoParam>*)arg[0]);
  else ::new(mem) ::std::vector<HcalRecoParam>(*(const ::std::vector<HcalRecoParam>*)arg[0]);
}

static void destructor_5597(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalRecoParam>*)o)->::std::vector<HcalRecoParam>::~vector)();
}
static  void operator_5598( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalRecoParam>*)o)->operator=)(*(const ::std::vector<HcalRecoParam>*)arg[0]);
  else   (((::std::vector<HcalRecoParam>*)o)->operator=)(*(const ::std::vector<HcalRecoParam>*)arg[0]);
}

static  void method_5599( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalRecoParam>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalRecoParam*)arg[1]);
}

static  void method_5600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >)((((::std::vector<HcalRecoParam>*)o)->begin)());
  else   (((::std::vector<HcalRecoParam>*)o)->begin)();
}

static  void method_5601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalRecoParam*,std::vector<HcalRecoParam> >)((((const ::std::vector<HcalRecoParam>*)o)->begin)());
  else   (((const ::std::vector<HcalRecoParam>*)o)->begin)();
}

static  void method_5602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >)((((::std::vector<HcalRecoParam>*)o)->end)());
  else   (((::std::vector<HcalRecoParam>*)o)->end)();
}

static  void method_5603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalRecoParam*,std::vector<HcalRecoParam> >)((((const ::std::vector<HcalRecoParam>*)o)->end)());
  else   (((const ::std::vector<HcalRecoParam>*)o)->end)();
}

static  void method_5608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalRecoParam>*)o)->size)());
  else   (((const ::std::vector<HcalRecoParam>*)o)->size)();
}

static  void method_5609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalRecoParam>*)o)->max_size)());
  else   (((const ::std::vector<HcalRecoParam>*)o)->max_size)();
}

static  void method_5610( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalRecoParam>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalRecoParam>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalRecoParam*)arg[1]);
  }
}

static  void method_5611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalRecoParam>*)o)->capacity)());
  else   (((const ::std::vector<HcalRecoParam>*)o)->capacity)();
}

static  void method_5612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalRecoParam>*)o)->empty)());
  else   (((const ::std::vector<HcalRecoParam>*)o)->empty)();
}

static  void method_5613( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalRecoParam>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalRecoParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalRecoParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalRecoParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalRecoParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalRecoParam>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalRecoParam>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalRecoParam>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalRecoParam>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalRecoParam>*)o)->front)();
  else   (((::std::vector<HcalRecoParam>*)o)->front)();
}

static  void method_5620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalRecoParam>*)o)->front)();
  else   (((const ::std::vector<HcalRecoParam>*)o)->front)();
}

static  void method_5621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalRecoParam>*)o)->back)();
  else   (((::std::vector<HcalRecoParam>*)o)->back)();
}

static  void method_5622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalRecoParam>*)o)->back)();
  else   (((const ::std::vector<HcalRecoParam>*)o)->back)();
}

static  void method_5623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalRecoParam>*)o)->data)());
  else   (((::std::vector<HcalRecoParam>*)o)->data)();
}

static  void method_5624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalRecoParam>*)o)->data)());
  else   (((const ::std::vector<HcalRecoParam>*)o)->data)();
}

static  void method_5625( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalRecoParam>*)o)->push_back)(*(const ::HcalRecoParam*)arg[0]);
}

static  void method_5626( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalRecoParam>*)o)->pop_back)();
}

static  void method_5627( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >)((((::std::vector<HcalRecoParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >*)arg[0],
    *(const ::HcalRecoParam*)arg[1]));
  else   (((::std::vector<HcalRecoParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >*)arg[0],
    *(const ::HcalRecoParam*)arg[1]);
}

static  void method_5628( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalRecoParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalRecoParam*)arg[2]);
}

static  void method_5629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >)((((::std::vector<HcalRecoParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >*)arg[0]));
  else   (((::std::vector<HcalRecoParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >*)arg[0]);
}

static  void method_5630( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >)((((::std::vector<HcalRecoParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >*)arg[1]));
  else   (((::std::vector<HcalRecoParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalRecoParam*,std::vector<HcalRecoParam> >*)arg[1]);
}

static  void method_5631( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalRecoParam>*)o)->swap)(*(::std::vector<HcalRecoParam>*)arg[0]);
}

static  void method_5632( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalRecoParam>*)o)->clear)();
}

static void method_newdel_1852( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalRecoParam> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalRecoParam> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalRecoParam> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalRecoParam> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalRecoParam> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalRecoParam,std::allocator<HcalRecoParam> >")), ::Reflex::BaseOffset< ::std::vector<HcalRecoParam>,::std::_Vector_base<HcalRecoParam,std::allocator<HcalRecoParam> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x105( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalRecoParam> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalRecoParam> >::Generate();
}

//------Dictionary for class vector<HcalRecoParam,std::allocator<HcalRecoParam> > -------------------------------
void __std__vector_HcalRecoParam__db_datamem(Reflex::Class*);
void __std__vector_HcalRecoParam__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalRecoParam__datamem_bld(&__std__vector_HcalRecoParam__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalRecoParam__funcmem_bld(&__std__vector_HcalRecoParam__db_funcmem);
void __std__vector_HcalRecoParam__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalRecoParam>"), typeid(::std::vector<HcalRecoParam>), sizeof(::std::vector<HcalRecoParam>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1796, ::Reflex::BaseOffset< ::std::vector<HcalRecoParam>, ::std::_Vector_base<HcalRecoParam,std::allocator<HcalRecoParam> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_745, Reflex::Literal("std::vector<HcalRecoParam>::_Alloc_value_type"))
  .AddTypedef(type_1796, Reflex::Literal("std::vector<HcalRecoParam>::_Base"))
  .AddTypedef(type_2140, Reflex::Literal("std::vector<HcalRecoParam>::_Tp_alloc_type"))
  .AddTypedef(type_3891, Reflex::Literal("std::vector<HcalRecoParam>::_Alloc_traits"))
  .AddTypedef(type_745, Reflex::Literal("std::vector<HcalRecoParam>::value_type"))
  .AddTypedef(type_4805, Reflex::Literal("std::vector<HcalRecoParam>::pointer"))
  .AddTypedef(type_5580, Reflex::Literal("std::vector<HcalRecoParam>::const_pointer"))
  .AddTypedef(type_5582, Reflex::Literal("std::vector<HcalRecoParam>::reference"))
  .AddTypedef(type_5584, Reflex::Literal("std::vector<HcalRecoParam>::const_reference"))
  .AddTypedef(type_3803, Reflex::Literal("std::vector<HcalRecoParam>::iterator"))
  .AddTypedef(type_3804, Reflex::Literal("std::vector<HcalRecoParam>::const_iterator"))
  .AddTypedef(type_2278, Reflex::Literal("std::vector<HcalRecoParam>::const_reverse_iterator"))
  .AddTypedef(type_2279, Reflex::Literal("std::vector<HcalRecoParam>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalRecoParam>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalRecoParam>::difference_type"))
  .AddTypedef(type_2140, Reflex::Literal("std::vector<HcalRecoParam>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5593, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12473), Reflex::Literal("vector"), constructor_5594, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_5584, type_12473), Reflex::Literal("vector"), constructor_5595, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12848), Reflex::Literal("vector"), constructor_5596, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5597, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1852, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x105, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalRecoParam__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalRecoParam,std::allocator<HcalRecoParam> > -------------------
void __std__vector_HcalRecoParam__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalRecoParam,std::allocator<HcalRecoParam> > -------------------
void __std__vector_HcalRecoParam__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12849, type_12848), Reflex::Literal("operator="), operator_5598, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_5584), Reflex::Literal("assign"), method_5599, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3803), Reflex::Literal("begin"), method_5600, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3804), Reflex::Literal("begin"), method_5601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3803), Reflex::Literal("end"), method_5602, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3804), Reflex::Literal("end"), method_5603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_5608, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_5609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_745), Reflex::Literal("resize"), method_5610, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_5611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_5612, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_5613, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5582, type_2122), Reflex::Literal("operator[]"), operator_5614, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5584, type_2122), Reflex::Literal("operator[]"), operator_5615, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5582, type_2122), Reflex::Literal("at"), method_5617, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5584, type_2122), Reflex::Literal("at"), method_5618, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5582), Reflex::Literal("front"), method_5619, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5584), Reflex::Literal("front"), method_5620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5582), Reflex::Literal("back"), method_5621, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5584), Reflex::Literal("back"), method_5622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4805), Reflex::Literal("data"), method_5623, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5580), Reflex::Literal("data"), method_5624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_5584), Reflex::Literal("push_back"), method_5625, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_5626, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3803, type_3803, type_5584), Reflex::Literal("insert"), method_5627, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3803, type_2122, type_5584), Reflex::Literal("insert"), method_5628, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3803, type_3803), Reflex::Literal("erase"), method_5629, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3803, type_3803, type_3803), Reflex::Literal("erase"), method_5630, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12849), Reflex::Literal("swap"), method_5631, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_5632, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalLongRecoParam,std::allocator<HcalLongRecoParam> > -------------------------------
static void constructor_5723( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLongRecoParam>();
  else ::new(mem) ::std::vector<HcalLongRecoParam>();
}

static void constructor_5724( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLongRecoParam>(*(const ::std::allocator<HcalLongRecoParam>*)arg[0]);
  else ::new(mem) ::std::vector<HcalLongRecoParam>(*(const ::std::allocator<HcalLongRecoParam>*)arg[0]);
}

static void constructor_5725( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLongRecoParam>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalLongRecoParam>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLongRecoParam>(*(::std::size_t*)arg[0],
      *(const ::HcalLongRecoParam*)arg[1]);
  else ::new(mem) ::std::vector<HcalLongRecoParam>(*(::std::size_t*)arg[0],
      *(const ::HcalLongRecoParam*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLongRecoParam>(*(::std::size_t*)arg[0],
      *(const ::HcalLongRecoParam*)arg[1],
      *(const ::std::allocator<HcalLongRecoParam>*)arg[2]);
  else ::new(mem) ::std::vector<HcalLongRecoParam>(*(::std::size_t*)arg[0],
      *(const ::HcalLongRecoParam*)arg[1],
      *(const ::std::allocator<HcalLongRecoParam>*)arg[2]);
  }
}

static void constructor_5726( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLongRecoParam>(*(const ::std::vector<HcalLongRecoParam>*)arg[0]);
  else ::new(mem) ::std::vector<HcalLongRecoParam>(*(const ::std::vector<HcalLongRecoParam>*)arg[0]);
}

static void destructor_5727(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalLongRecoParam>*)o)->::std::vector<HcalLongRecoParam>::~vector)();
}
static  void operator_5728( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLongRecoParam>*)o)->operator=)(*(const ::std::vector<HcalLongRecoParam>*)arg[0]);
  else   (((::std::vector<HcalLongRecoParam>*)o)->operator=)(*(const ::std::vector<HcalLongRecoParam>*)arg[0]);
}

static  void method_5729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLongRecoParam>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalLongRecoParam*)arg[1]);
}

static  void method_5730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >)((((::std::vector<HcalLongRecoParam>*)o)->begin)());
  else   (((::std::vector<HcalLongRecoParam>*)o)->begin)();
}

static  void method_5731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalLongRecoParam*,std::vector<HcalLongRecoParam> >)((((const ::std::vector<HcalLongRecoParam>*)o)->begin)());
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->begin)();
}

static  void method_5732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >)((((::std::vector<HcalLongRecoParam>*)o)->end)());
  else   (((::std::vector<HcalLongRecoParam>*)o)->end)();
}

static  void method_5733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalLongRecoParam*,std::vector<HcalLongRecoParam> >)((((const ::std::vector<HcalLongRecoParam>*)o)->end)());
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->end)();
}

static  void method_5738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalLongRecoParam>*)o)->size)());
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->size)();
}

static  void method_5739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalLongRecoParam>*)o)->max_size)());
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->max_size)();
}

static  void method_5740( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalLongRecoParam>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalLongRecoParam>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalLongRecoParam*)arg[1]);
  }
}

static  void method_5741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalLongRecoParam>*)o)->capacity)());
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->capacity)();
}

static  void method_5742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalLongRecoParam>*)o)->empty)());
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->empty)();
}

static  void method_5743( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLongRecoParam>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLongRecoParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalLongRecoParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLongRecoParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLongRecoParam>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalLongRecoParam>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLongRecoParam>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLongRecoParam>*)o)->front)();
  else   (((::std::vector<HcalLongRecoParam>*)o)->front)();
}

static  void method_5750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLongRecoParam>*)o)->front)();
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->front)();
}

static  void method_5751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLongRecoParam>*)o)->back)();
  else   (((::std::vector<HcalLongRecoParam>*)o)->back)();
}

static  void method_5752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLongRecoParam>*)o)->back)();
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->back)();
}

static  void method_5753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalLongRecoParam>*)o)->data)());
  else   (((::std::vector<HcalLongRecoParam>*)o)->data)();
}

static  void method_5754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalLongRecoParam>*)o)->data)());
  else   (((const ::std::vector<HcalLongRecoParam>*)o)->data)();
}

static  void method_5755( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLongRecoParam>*)o)->push_back)(*(const ::HcalLongRecoParam*)arg[0]);
}

static  void method_5756( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalLongRecoParam>*)o)->pop_back)();
}

static  void method_5757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >)((((::std::vector<HcalLongRecoParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >*)arg[0],
    *(const ::HcalLongRecoParam*)arg[1]));
  else   (((::std::vector<HcalLongRecoParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >*)arg[0],
    *(const ::HcalLongRecoParam*)arg[1]);
}

static  void method_5758( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLongRecoParam>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalLongRecoParam*)arg[2]);
}

static  void method_5759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >)((((::std::vector<HcalLongRecoParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >*)arg[0]));
  else   (((::std::vector<HcalLongRecoParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >*)arg[0]);
}

static  void method_5760( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >)((((::std::vector<HcalLongRecoParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >*)arg[1]));
  else   (((::std::vector<HcalLongRecoParam>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalLongRecoParam*,std::vector<HcalLongRecoParam> >*)arg[1]);
}

static  void method_5761( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLongRecoParam>*)o)->swap)(*(::std::vector<HcalLongRecoParam>*)arg[0]);
}

static  void method_5762( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalLongRecoParam>*)o)->clear)();
}

static void method_newdel_1854( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLongRecoParam> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLongRecoParam> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLongRecoParam> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLongRecoParam> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLongRecoParam> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x107( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalLongRecoParam,std::allocator<HcalLongRecoParam> >")), ::Reflex::BaseOffset< ::std::vector<HcalLongRecoParam>,::std::_Vector_base<HcalLongRecoParam,std::allocator<HcalLongRecoParam> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x108( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalLongRecoParam> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalLongRecoParam> >::Generate();
}

//------Dictionary for class vector<HcalLongRecoParam,std::allocator<HcalLongRecoParam> > -------------------------------
void __std__vector_HcalLongRecoParam__db_datamem(Reflex::Class*);
void __std__vector_HcalLongRecoParam__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalLongRecoParam__datamem_bld(&__std__vector_HcalLongRecoParam__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalLongRecoParam__funcmem_bld(&__std__vector_HcalLongRecoParam__db_funcmem);
void __std__vector_HcalLongRecoParam__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalLongRecoParam>"), typeid(::std::vector<HcalLongRecoParam>), sizeof(::std::vector<HcalLongRecoParam>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1794, ::Reflex::BaseOffset< ::std::vector<HcalLongRecoParam>, ::std::_Vector_base<HcalLongRecoParam,std::allocator<HcalLongRecoParam> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1748, Reflex::Literal("std::vector<HcalLongRecoParam>::_Alloc_value_type"))
  .AddTypedef(type_1794, Reflex::Literal("std::vector<HcalLongRecoParam>::_Base"))
  .AddTypedef(type_2142, Reflex::Literal("std::vector<HcalLongRecoParam>::_Tp_alloc_type"))
  .AddTypedef(type_3889, Reflex::Literal("std::vector<HcalLongRecoParam>::_Alloc_traits"))
  .AddTypedef(type_1748, Reflex::Literal("std::vector<HcalLongRecoParam>::value_type"))
  .AddTypedef(type_4768, Reflex::Literal("std::vector<HcalLongRecoParam>::pointer"))
  .AddTypedef(type_5710, Reflex::Literal("std::vector<HcalLongRecoParam>::const_pointer"))
  .AddTypedef(type_5712, Reflex::Literal("std::vector<HcalLongRecoParam>::reference"))
  .AddTypedef(type_5714, Reflex::Literal("std::vector<HcalLongRecoParam>::const_reference"))
  .AddTypedef(type_3799, Reflex::Literal("std::vector<HcalLongRecoParam>::iterator"))
  .AddTypedef(type_3800, Reflex::Literal("std::vector<HcalLongRecoParam>::const_iterator"))
  .AddTypedef(type_2274, Reflex::Literal("std::vector<HcalLongRecoParam>::const_reverse_iterator"))
  .AddTypedef(type_2275, Reflex::Literal("std::vector<HcalLongRecoParam>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalLongRecoParam>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalLongRecoParam>::difference_type"))
  .AddTypedef(type_2142, Reflex::Literal("std::vector<HcalLongRecoParam>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5723, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12447), Reflex::Literal("vector"), constructor_5724, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_5714, type_12447), Reflex::Literal("vector"), constructor_5725, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12853), Reflex::Literal("vector"), constructor_5726, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5727, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1854, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x107, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x108, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalLongRecoParam__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalLongRecoParam,std::allocator<HcalLongRecoParam> > -------------------
void __std__vector_HcalLongRecoParam__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalLongRecoParam,std::allocator<HcalLongRecoParam> > -------------------
void __std__vector_HcalLongRecoParam__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12854, type_12853), Reflex::Literal("operator="), operator_5728, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_5714), Reflex::Literal("assign"), method_5729, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3799), Reflex::Literal("begin"), method_5730, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3800), Reflex::Literal("begin"), method_5731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3799), Reflex::Literal("end"), method_5732, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3800), Reflex::Literal("end"), method_5733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_5738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_5739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1748), Reflex::Literal("resize"), method_5740, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_5741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_5742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_5743, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5712, type_2122), Reflex::Literal("operator[]"), operator_5744, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5714, type_2122), Reflex::Literal("operator[]"), operator_5745, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5712, type_2122), Reflex::Literal("at"), method_5747, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5714, type_2122), Reflex::Literal("at"), method_5748, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5712), Reflex::Literal("front"), method_5749, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5714), Reflex::Literal("front"), method_5750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5712), Reflex::Literal("back"), method_5751, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5714), Reflex::Literal("back"), method_5752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4768), Reflex::Literal("data"), method_5753, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5710), Reflex::Literal("data"), method_5754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_5714), Reflex::Literal("push_back"), method_5755, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_5756, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3799, type_3799, type_5714), Reflex::Literal("insert"), method_5757, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3799, type_2122, type_5714), Reflex::Literal("insert"), method_5758, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3799, type_3799), Reflex::Literal("erase"), method_5759, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3799, type_3799, type_3799), Reflex::Literal("erase"), method_5760, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12854), Reflex::Literal("swap"), method_5761, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_5762, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Item -------------------------------
static void destructor_10017(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalDcsMap::Item*)o)->::HcalDcsMap::Item::~Item)();
}
static  void operator_10018( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalDcsMap::Item*)o)->operator=)(*(const ::HcalDcsMap::Item*)arg[0]);
  else   (((::HcalDcsMap::Item*)o)->operator=)(*(const ::HcalDcsMap::Item*)arg[0]);
}

static void constructor_10019( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsMap::Item(*(const ::HcalDcsMap::Item*)arg[0]);
  else ::new(mem) ::HcalDcsMap::Item(*(const ::HcalDcsMap::Item*)arg[0]);
}

static void constructor_10020( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsMap::Item();
  else ::new(mem) ::HcalDcsMap::Item();
}

static void constructor_10021( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsMap::Item(*(::uint32_t*)arg[0],
      *(::uint32_t*)arg[1]);
  else ::new(mem) ::HcalDcsMap::Item(*(::uint32_t*)arg[0],
      *(::uint32_t*)arg[1]);
}

static void method_newdel_3088( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalDcsMap::Item >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalDcsMap::Item >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalDcsMap::Item >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalDcsMap::Item >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalDcsMap::Item >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Item -------------------------------
void __HcalDcsMap__Item_db_datamem(Reflex::Class*);
void __HcalDcsMap__Item_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalDcsMap__Item_datamem_bld(&__HcalDcsMap__Item_db_datamem);
Reflex::GenreflexMemberBuilder __HcalDcsMap__Item_funcmem_bld(&__HcalDcsMap__Item_db_funcmem);
void __HcalDcsMap__Item_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalDcsMap::Item"), typeid(::HcalDcsMap::Item), sizeof(::HcalDcsMap::Item), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_10017, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5776, type_5778), Reflex::Literal("operator="), operator_10018, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5778), Reflex::Literal("Item"), constructor_10019, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_10020, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_370, type_370), Reflex::Literal("Item"), constructor_10021, 0, "fId;fDcsId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3088, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalDcsMap__Item_datamem_bld);
}

//------Delayed data member builder for class Item -------------------
void __HcalDcsMap__Item_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalDcsMap__Item, mId), ::Reflex::PUBLIC)
  .AddDataMember(type_370, Reflex::Literal("mDcsId"), OffsetOf(__shadow__::__HcalDcsMap__Item, mDcsId), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class Item -------------------
void __HcalDcsMap__Item_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<HcalDcsMap::Item,std::allocator<HcalDcsMap::Item> > -------------------------------
static void constructor_5787( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsMap::Item>();
  else ::new(mem) ::std::vector<HcalDcsMap::Item>();
}

static void constructor_5788( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsMap::Item>(*(const ::std::allocator<HcalDcsMap::Item>*)arg[0]);
  else ::new(mem) ::std::vector<HcalDcsMap::Item>(*(const ::std::allocator<HcalDcsMap::Item>*)arg[0]);
}

static void constructor_5789( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsMap::Item>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalDcsMap::Item>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsMap::Item>(*(::std::size_t*)arg[0],
      *(const ::HcalDcsMap::Item*)arg[1]);
  else ::new(mem) ::std::vector<HcalDcsMap::Item>(*(::std::size_t*)arg[0],
      *(const ::HcalDcsMap::Item*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsMap::Item>(*(::std::size_t*)arg[0],
      *(const ::HcalDcsMap::Item*)arg[1],
      *(const ::std::allocator<HcalDcsMap::Item>*)arg[2]);
  else ::new(mem) ::std::vector<HcalDcsMap::Item>(*(::std::size_t*)arg[0],
      *(const ::HcalDcsMap::Item*)arg[1],
      *(const ::std::allocator<HcalDcsMap::Item>*)arg[2]);
  }
}

static void constructor_5790( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsMap::Item>(*(const ::std::vector<HcalDcsMap::Item>*)arg[0]);
  else ::new(mem) ::std::vector<HcalDcsMap::Item>(*(const ::std::vector<HcalDcsMap::Item>*)arg[0]);
}

static void destructor_5791(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalDcsMap::Item>*)o)->::std::vector<HcalDcsMap::Item>::~vector)();
}
static  void operator_5792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalDcsMap::Item>*)o)->operator=)(*(const ::std::vector<HcalDcsMap::Item>*)arg[0]);
  else   (((::std::vector<HcalDcsMap::Item>*)o)->operator=)(*(const ::std::vector<HcalDcsMap::Item>*)arg[0]);
}

static  void method_5793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalDcsMap::Item>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalDcsMap::Item*)arg[1]);
}

static  void method_5794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >)((((::std::vector<HcalDcsMap::Item>*)o)->begin)());
  else   (((::std::vector<HcalDcsMap::Item>*)o)->begin)();
}

static  void method_5795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >)((((const ::std::vector<HcalDcsMap::Item>*)o)->begin)());
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->begin)();
}

static  void method_5796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >)((((::std::vector<HcalDcsMap::Item>*)o)->end)());
  else   (((::std::vector<HcalDcsMap::Item>*)o)->end)();
}

static  void method_5797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >)((((const ::std::vector<HcalDcsMap::Item>*)o)->end)());
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->end)();
}

static  void method_5802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalDcsMap::Item>*)o)->size)());
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->size)();
}

static  void method_5803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalDcsMap::Item>*)o)->max_size)());
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->max_size)();
}

static  void method_5804( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalDcsMap::Item>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalDcsMap::Item>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalDcsMap::Item*)arg[1]);
  }
}

static  void method_5805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalDcsMap::Item>*)o)->capacity)());
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->capacity)();
}

static  void method_5806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalDcsMap::Item>*)o)->empty)());
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->empty)();
}

static  void method_5807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalDcsMap::Item>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalDcsMap::Item>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalDcsMap::Item>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalDcsMap::Item>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalDcsMap::Item>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalDcsMap::Item>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalDcsMap::Item>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalDcsMap::Item>*)o)->front)();
  else   (((::std::vector<HcalDcsMap::Item>*)o)->front)();
}

static  void method_5814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalDcsMap::Item>*)o)->front)();
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->front)();
}

static  void method_5815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalDcsMap::Item>*)o)->back)();
  else   (((::std::vector<HcalDcsMap::Item>*)o)->back)();
}

static  void method_5816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalDcsMap::Item>*)o)->back)();
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->back)();
}

static  void method_5817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalDcsMap::Item>*)o)->data)());
  else   (((::std::vector<HcalDcsMap::Item>*)o)->data)();
}

static  void method_5818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalDcsMap::Item>*)o)->data)());
  else   (((const ::std::vector<HcalDcsMap::Item>*)o)->data)();
}

static  void method_5819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalDcsMap::Item>*)o)->push_back)(*(const ::HcalDcsMap::Item*)arg[0]);
}

static  void method_5820( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalDcsMap::Item>*)o)->pop_back)();
}

static  void method_5821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >)((((::std::vector<HcalDcsMap::Item>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >*)arg[0],
    *(const ::HcalDcsMap::Item*)arg[1]));
  else   (((::std::vector<HcalDcsMap::Item>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >*)arg[0],
    *(const ::HcalDcsMap::Item*)arg[1]);
}

static  void method_5822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalDcsMap::Item>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalDcsMap::Item*)arg[2]);
}

static  void method_5823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >)((((::std::vector<HcalDcsMap::Item>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >*)arg[0]));
  else   (((::std::vector<HcalDcsMap::Item>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >*)arg[0]);
}

static  void method_5824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >)((((::std::vector<HcalDcsMap::Item>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >*)arg[1]));
  else   (((::std::vector<HcalDcsMap::Item>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalDcsMap::Item*,std::vector<HcalDcsMap::Item> >*)arg[1]);
}

static  void method_5825( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalDcsMap::Item>*)o)->swap)(*(::std::vector<HcalDcsMap::Item>*)arg[0]);
}

static  void method_5826( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalDcsMap::Item>*)o)->clear)();
}

static void method_newdel_1855( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalDcsMap::Item> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalDcsMap::Item> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalDcsMap::Item> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalDcsMap::Item> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalDcsMap::Item> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalDcsMap::Item,std::allocator<HcalDcsMap::Item> >")), ::Reflex::BaseOffset< ::std::vector<HcalDcsMap::Item>,::std::_Vector_base<HcalDcsMap::Item,std::allocator<HcalDcsMap::Item> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x112( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalDcsMap::Item> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalDcsMap::Item> >::Generate();
}

//------Dictionary for class vector<HcalDcsMap::Item,std::allocator<HcalDcsMap::Item> > -------------------------------
void __std__vector_HcalDcsMap__Item__db_datamem(Reflex::Class*);
void __std__vector_HcalDcsMap__Item__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalDcsMap__Item__datamem_bld(&__std__vector_HcalDcsMap__Item__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalDcsMap__Item__funcmem_bld(&__std__vector_HcalDcsMap__Item__db_funcmem);
void __std__vector_HcalDcsMap__Item__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalDcsMap::Item>"), typeid(::std::vector<HcalDcsMap::Item>), sizeof(::std::vector<HcalDcsMap::Item>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1799, ::Reflex::BaseOffset< ::std::vector<HcalDcsMap::Item>, ::std::_Vector_base<HcalDcsMap::Item,std::allocator<HcalDcsMap::Item> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3088, Reflex::Literal("std::vector<HcalDcsMap::Item>::_Alloc_value_type"))
  .AddTypedef(type_1799, Reflex::Literal("std::vector<HcalDcsMap::Item>::_Base"))
  .AddTypedef(type_2143, Reflex::Literal("std::vector<HcalDcsMap::Item>::_Tp_alloc_type"))
  .AddTypedef(type_3894, Reflex::Literal("std::vector<HcalDcsMap::Item>::_Alloc_traits"))
  .AddTypedef(type_3088, Reflex::Literal("std::vector<HcalDcsMap::Item>::value_type"))
  .AddTypedef(type_4862, Reflex::Literal("std::vector<HcalDcsMap::Item>::pointer"))
  .AddTypedef(type_5348, Reflex::Literal("std::vector<HcalDcsMap::Item>::const_pointer"))
  .AddTypedef(type_5776, Reflex::Literal("std::vector<HcalDcsMap::Item>::reference"))
  .AddTypedef(type_5778, Reflex::Literal("std::vector<HcalDcsMap::Item>::const_reference"))
  .AddTypedef(type_3810, Reflex::Literal("std::vector<HcalDcsMap::Item>::iterator"))
  .AddTypedef(type_3811, Reflex::Literal("std::vector<HcalDcsMap::Item>::const_iterator"))
  .AddTypedef(type_2284, Reflex::Literal("std::vector<HcalDcsMap::Item>::const_reverse_iterator"))
  .AddTypedef(type_2285, Reflex::Literal("std::vector<HcalDcsMap::Item>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalDcsMap::Item>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalDcsMap::Item>::difference_type"))
  .AddTypedef(type_2143, Reflex::Literal("std::vector<HcalDcsMap::Item>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5787, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12512), Reflex::Literal("vector"), constructor_5788, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_5778, type_12512), Reflex::Literal("vector"), constructor_5789, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12855), Reflex::Literal("vector"), constructor_5790, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5791, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1855, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalDcsMap__Item__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalDcsMap::Item,std::allocator<HcalDcsMap::Item> > -------------------
void __std__vector_HcalDcsMap__Item__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalDcsMap::Item,std::allocator<HcalDcsMap::Item> > -------------------
void __std__vector_HcalDcsMap__Item__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12856, type_12855), Reflex::Literal("operator="), operator_5792, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_5778), Reflex::Literal("assign"), method_5793, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3810), Reflex::Literal("begin"), method_5794, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3811), Reflex::Literal("begin"), method_5795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3810), Reflex::Literal("end"), method_5796, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3811), Reflex::Literal("end"), method_5797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_5802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_5803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_3088), Reflex::Literal("resize"), method_5804, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_5805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_5806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_5807, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5776, type_2122), Reflex::Literal("operator[]"), operator_5808, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5778, type_2122), Reflex::Literal("operator[]"), operator_5809, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5776, type_2122), Reflex::Literal("at"), method_5811, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5778, type_2122), Reflex::Literal("at"), method_5812, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5776), Reflex::Literal("front"), method_5813, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5778), Reflex::Literal("front"), method_5814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5776), Reflex::Literal("back"), method_5815, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5778), Reflex::Literal("back"), method_5816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4862), Reflex::Literal("data"), method_5817, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5348), Reflex::Literal("data"), method_5818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_5778), Reflex::Literal("push_back"), method_5819, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_5820, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3810, type_3810, type_5778), Reflex::Literal("insert"), method_5821, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3810, type_2122, type_5778), Reflex::Literal("insert"), method_5822, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3810, type_3810), Reflex::Literal("erase"), method_5823, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3810, type_3810, type_3810), Reflex::Literal("erase"), method_5824, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12856), Reflex::Literal("swap"), method_5825, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_5826, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalDcsValue,std::allocator<HcalDcsValue> > -------------------------------
static void constructor_5852( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsValue>();
  else ::new(mem) ::std::vector<HcalDcsValue>();
}

static void constructor_5853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsValue>(*(const ::std::allocator<HcalDcsValue>*)arg[0]);
  else ::new(mem) ::std::vector<HcalDcsValue>(*(const ::std::allocator<HcalDcsValue>*)arg[0]);
}

static void constructor_5854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsValue>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalDcsValue>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsValue>(*(::std::size_t*)arg[0],
      *(const ::HcalDcsValue*)arg[1]);
  else ::new(mem) ::std::vector<HcalDcsValue>(*(::std::size_t*)arg[0],
      *(const ::HcalDcsValue*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsValue>(*(::std::size_t*)arg[0],
      *(const ::HcalDcsValue*)arg[1],
      *(const ::std::allocator<HcalDcsValue>*)arg[2]);
  else ::new(mem) ::std::vector<HcalDcsValue>(*(::std::size_t*)arg[0],
      *(const ::HcalDcsValue*)arg[1],
      *(const ::std::allocator<HcalDcsValue>*)arg[2]);
  }
}

static void constructor_5855( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalDcsValue>(*(const ::std::vector<HcalDcsValue>*)arg[0]);
  else ::new(mem) ::std::vector<HcalDcsValue>(*(const ::std::vector<HcalDcsValue>*)arg[0]);
}

static void destructor_5856(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalDcsValue>*)o)->::std::vector<HcalDcsValue>::~vector)();
}
static  void operator_5857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalDcsValue>*)o)->operator=)(*(const ::std::vector<HcalDcsValue>*)arg[0]);
  else   (((::std::vector<HcalDcsValue>*)o)->operator=)(*(const ::std::vector<HcalDcsValue>*)arg[0]);
}

static  void method_5858( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalDcsValue>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalDcsValue*)arg[1]);
}

static  void method_5859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >)((((::std::vector<HcalDcsValue>*)o)->begin)());
  else   (((::std::vector<HcalDcsValue>*)o)->begin)();
}

static  void method_5860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalDcsValue*,std::vector<HcalDcsValue> >)((((const ::std::vector<HcalDcsValue>*)o)->begin)());
  else   (((const ::std::vector<HcalDcsValue>*)o)->begin)();
}

static  void method_5861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >)((((::std::vector<HcalDcsValue>*)o)->end)());
  else   (((::std::vector<HcalDcsValue>*)o)->end)();
}

static  void method_5862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalDcsValue*,std::vector<HcalDcsValue> >)((((const ::std::vector<HcalDcsValue>*)o)->end)());
  else   (((const ::std::vector<HcalDcsValue>*)o)->end)();
}

static  void method_5867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalDcsValue>*)o)->size)());
  else   (((const ::std::vector<HcalDcsValue>*)o)->size)();
}

static  void method_5868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalDcsValue>*)o)->max_size)());
  else   (((const ::std::vector<HcalDcsValue>*)o)->max_size)();
}

static  void method_5869( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalDcsValue>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalDcsValue>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalDcsValue*)arg[1]);
  }
}

static  void method_5870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalDcsValue>*)o)->capacity)());
  else   (((const ::std::vector<HcalDcsValue>*)o)->capacity)();
}

static  void method_5871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalDcsValue>*)o)->empty)());
  else   (((const ::std::vector<HcalDcsValue>*)o)->empty)();
}

static  void method_5872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalDcsValue>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalDcsValue>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalDcsValue>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalDcsValue>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalDcsValue>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalDcsValue>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalDcsValue>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalDcsValue>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalDcsValue>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalDcsValue>*)o)->front)();
  else   (((::std::vector<HcalDcsValue>*)o)->front)();
}

static  void method_5879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalDcsValue>*)o)->front)();
  else   (((const ::std::vector<HcalDcsValue>*)o)->front)();
}

static  void method_5880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalDcsValue>*)o)->back)();
  else   (((::std::vector<HcalDcsValue>*)o)->back)();
}

static  void method_5881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalDcsValue>*)o)->back)();
  else   (((const ::std::vector<HcalDcsValue>*)o)->back)();
}

static  void method_5882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalDcsValue>*)o)->data)());
  else   (((::std::vector<HcalDcsValue>*)o)->data)();
}

static  void method_5883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalDcsValue>*)o)->data)());
  else   (((const ::std::vector<HcalDcsValue>*)o)->data)();
}

static  void method_5884( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalDcsValue>*)o)->push_back)(*(const ::HcalDcsValue*)arg[0]);
}

static  void method_5885( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalDcsValue>*)o)->pop_back)();
}

static  void method_5886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >)((((::std::vector<HcalDcsValue>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >*)arg[0],
    *(const ::HcalDcsValue*)arg[1]));
  else   (((::std::vector<HcalDcsValue>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >*)arg[0],
    *(const ::HcalDcsValue*)arg[1]);
}

static  void method_5887( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalDcsValue>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalDcsValue*)arg[2]);
}

static  void method_5888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >)((((::std::vector<HcalDcsValue>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >*)arg[0]));
  else   (((::std::vector<HcalDcsValue>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >*)arg[0]);
}

static  void method_5889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >)((((::std::vector<HcalDcsValue>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >*)arg[1]));
  else   (((::std::vector<HcalDcsValue>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalDcsValue*,std::vector<HcalDcsValue> >*)arg[1]);
}

static  void method_5890( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalDcsValue>*)o)->swap)(*(::std::vector<HcalDcsValue>*)arg[0]);
}

static  void method_5891( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalDcsValue>*)o)->clear)();
}

static void method_newdel_1856( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalDcsValue> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalDcsValue> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalDcsValue> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalDcsValue> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalDcsValue> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x114( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalDcsValue,std::allocator<HcalDcsValue> >")), ::Reflex::BaseOffset< ::std::vector<HcalDcsValue>,::std::_Vector_base<HcalDcsValue,std::allocator<HcalDcsValue> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x115( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalDcsValue> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalDcsValue> >::Generate();
}

//------Dictionary for class vector<HcalDcsValue,std::allocator<HcalDcsValue> > -------------------------------
void __std__vector_HcalDcsValue__db_datamem(Reflex::Class*);
void __std__vector_HcalDcsValue__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalDcsValue__datamem_bld(&__std__vector_HcalDcsValue__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalDcsValue__funcmem_bld(&__std__vector_HcalDcsValue__db_funcmem);
void __std__vector_HcalDcsValue__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalDcsValue>"), typeid(::std::vector<HcalDcsValue>), sizeof(::std::vector<HcalDcsValue>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1801, ::Reflex::BaseOffset< ::std::vector<HcalDcsValue>, ::std::_Vector_base<HcalDcsValue,std::allocator<HcalDcsValue> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1419, Reflex::Literal("std::vector<HcalDcsValue>::_Alloc_value_type"))
  .AddTypedef(type_1801, Reflex::Literal("std::vector<HcalDcsValue>::_Base"))
  .AddTypedef(type_2144, Reflex::Literal("std::vector<HcalDcsValue>::_Tp_alloc_type"))
  .AddTypedef(type_3896, Reflex::Literal("std::vector<HcalDcsValue>::_Alloc_traits"))
  .AddTypedef(type_1419, Reflex::Literal("std::vector<HcalDcsValue>::value_type"))
  .AddTypedef(type_4900, Reflex::Literal("std::vector<HcalDcsValue>::pointer"))
  .AddTypedef(type_5839, Reflex::Literal("std::vector<HcalDcsValue>::const_pointer"))
  .AddTypedef(type_5841, Reflex::Literal("std::vector<HcalDcsValue>::reference"))
  .AddTypedef(type_5843, Reflex::Literal("std::vector<HcalDcsValue>::const_reference"))
  .AddTypedef(type_3813, Reflex::Literal("std::vector<HcalDcsValue>::iterator"))
  .AddTypedef(type_3814, Reflex::Literal("std::vector<HcalDcsValue>::const_iterator"))
  .AddTypedef(type_2288, Reflex::Literal("std::vector<HcalDcsValue>::const_reverse_iterator"))
  .AddTypedef(type_2289, Reflex::Literal("std::vector<HcalDcsValue>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalDcsValue>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalDcsValue>::difference_type"))
  .AddTypedef(type_2144, Reflex::Literal("std::vector<HcalDcsValue>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5852, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12538), Reflex::Literal("vector"), constructor_5853, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_5843, type_12538), Reflex::Literal("vector"), constructor_5854, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10162), Reflex::Literal("vector"), constructor_5855, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5856, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1856, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x114, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x115, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalDcsValue__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalDcsValue,std::allocator<HcalDcsValue> > -------------------
void __std__vector_HcalDcsValue__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalDcsValue,std::allocator<HcalDcsValue> > -------------------
void __std__vector_HcalDcsValue__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10163, type_10162), Reflex::Literal("operator="), operator_5857, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_5843), Reflex::Literal("assign"), method_5858, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3813), Reflex::Literal("begin"), method_5859, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3814), Reflex::Literal("begin"), method_5860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3813), Reflex::Literal("end"), method_5861, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3814), Reflex::Literal("end"), method_5862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_5867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_5868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1419), Reflex::Literal("resize"), method_5869, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_5870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_5871, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_5872, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5841, type_2122), Reflex::Literal("operator[]"), operator_5873, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5843, type_2122), Reflex::Literal("operator[]"), operator_5874, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5841, type_2122), Reflex::Literal("at"), method_5876, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5843, type_2122), Reflex::Literal("at"), method_5877, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5841), Reflex::Literal("front"), method_5878, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5843), Reflex::Literal("front"), method_5879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5841), Reflex::Literal("back"), method_5880, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5843), Reflex::Literal("back"), method_5881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4900), Reflex::Literal("data"), method_5882, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5839), Reflex::Literal("data"), method_5883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_5843), Reflex::Literal("push_back"), method_5884, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_5885, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3813, type_3813, type_5843), Reflex::Literal("insert"), method_5886, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3813, type_2122, type_5843), Reflex::Literal("insert"), method_5887, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3813, type_3813), Reflex::Literal("erase"), method_5888, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3813, type_3813, type_3813), Reflex::Literal("erase"), method_5889, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_10163), Reflex::Literal("swap"), method_5890, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_5891, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalCovarianceMatrix,std::allocator<HcalCovarianceMatrix> > -------------------------------
static void constructor_5917( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCovarianceMatrix>();
  else ::new(mem) ::std::vector<HcalCovarianceMatrix>();
}

static void constructor_5918( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCovarianceMatrix>(*(const ::std::allocator<HcalCovarianceMatrix>*)arg[0]);
  else ::new(mem) ::std::vector<HcalCovarianceMatrix>(*(const ::std::allocator<HcalCovarianceMatrix>*)arg[0]);
}

static void constructor_5919( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCovarianceMatrix>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalCovarianceMatrix>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCovarianceMatrix>(*(::std::size_t*)arg[0],
      *(const ::HcalCovarianceMatrix*)arg[1]);
  else ::new(mem) ::std::vector<HcalCovarianceMatrix>(*(::std::size_t*)arg[0],
      *(const ::HcalCovarianceMatrix*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCovarianceMatrix>(*(::std::size_t*)arg[0],
      *(const ::HcalCovarianceMatrix*)arg[1],
      *(const ::std::allocator<HcalCovarianceMatrix>*)arg[2]);
  else ::new(mem) ::std::vector<HcalCovarianceMatrix>(*(::std::size_t*)arg[0],
      *(const ::HcalCovarianceMatrix*)arg[1],
      *(const ::std::allocator<HcalCovarianceMatrix>*)arg[2]);
  }
}

static void constructor_5920( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCovarianceMatrix>(*(const ::std::vector<HcalCovarianceMatrix>*)arg[0]);
  else ::new(mem) ::std::vector<HcalCovarianceMatrix>(*(const ::std::vector<HcalCovarianceMatrix>*)arg[0]);
}

static void destructor_5921(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalCovarianceMatrix>*)o)->::std::vector<HcalCovarianceMatrix>::~vector)();
}
static  void operator_5922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCovarianceMatrix>*)o)->operator=)(*(const ::std::vector<HcalCovarianceMatrix>*)arg[0]);
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->operator=)(*(const ::std::vector<HcalCovarianceMatrix>*)arg[0]);
}

static  void method_5923( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCovarianceMatrix>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalCovarianceMatrix*)arg[1]);
}

static  void method_5924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >)((((::std::vector<HcalCovarianceMatrix>*)o)->begin)());
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->begin)();
}

static  void method_5925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >)((((const ::std::vector<HcalCovarianceMatrix>*)o)->begin)());
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->begin)();
}

static  void method_5926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >)((((::std::vector<HcalCovarianceMatrix>*)o)->end)());
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->end)();
}

static  void method_5927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >)((((const ::std::vector<HcalCovarianceMatrix>*)o)->end)());
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->end)();
}

static  void method_5932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalCovarianceMatrix>*)o)->size)());
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->size)();
}

static  void method_5933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalCovarianceMatrix>*)o)->max_size)());
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->max_size)();
}

static  void method_5934( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalCovarianceMatrix>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalCovarianceMatrix>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalCovarianceMatrix*)arg[1]);
  }
}

static  void method_5935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalCovarianceMatrix>*)o)->capacity)());
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->capacity)();
}

static  void method_5936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalCovarianceMatrix>*)o)->empty)());
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->empty)();
}

static  void method_5937( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCovarianceMatrix>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCovarianceMatrix>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCovarianceMatrix>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCovarianceMatrix>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCovarianceMatrix>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCovarianceMatrix>*)o)->front)();
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->front)();
}

static  void method_5944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCovarianceMatrix>*)o)->front)();
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->front)();
}

static  void method_5945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCovarianceMatrix>*)o)->back)();
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->back)();
}

static  void method_5946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCovarianceMatrix>*)o)->back)();
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->back)();
}

static  void method_5947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalCovarianceMatrix>*)o)->data)());
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->data)();
}

static  void method_5948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalCovarianceMatrix>*)o)->data)());
  else   (((const ::std::vector<HcalCovarianceMatrix>*)o)->data)();
}

static  void method_5949( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCovarianceMatrix>*)o)->push_back)(*(const ::HcalCovarianceMatrix*)arg[0]);
}

static  void method_5950( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalCovarianceMatrix>*)o)->pop_back)();
}

static  void method_5951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >)((((::std::vector<HcalCovarianceMatrix>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >*)arg[0],
    *(const ::HcalCovarianceMatrix*)arg[1]));
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >*)arg[0],
    *(const ::HcalCovarianceMatrix*)arg[1]);
}

static  void method_5952( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCovarianceMatrix>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalCovarianceMatrix*)arg[2]);
}

static  void method_5953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >)((((::std::vector<HcalCovarianceMatrix>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >*)arg[0]));
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >*)arg[0]);
}

static  void method_5954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >)((((::std::vector<HcalCovarianceMatrix>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >*)arg[1]));
  else   (((::std::vector<HcalCovarianceMatrix>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalCovarianceMatrix*,std::vector<HcalCovarianceMatrix> >*)arg[1]);
}

static  void method_5955( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCovarianceMatrix>*)o)->swap)(*(::std::vector<HcalCovarianceMatrix>*)arg[0]);
}

static  void method_5956( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalCovarianceMatrix>*)o)->clear)();
}

static void method_newdel_1857( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCovarianceMatrix> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCovarianceMatrix> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCovarianceMatrix> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCovarianceMatrix> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCovarianceMatrix> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalCovarianceMatrix,std::allocator<HcalCovarianceMatrix> >")), ::Reflex::BaseOffset< ::std::vector<HcalCovarianceMatrix>,::std::_Vector_base<HcalCovarianceMatrix,std::allocator<HcalCovarianceMatrix> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalCovarianceMatrix> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalCovarianceMatrix> >::Generate();
}

//------Dictionary for class vector<HcalCovarianceMatrix,std::allocator<HcalCovarianceMatrix> > -------------------------------
void __std__vector_HcalCovarianceMatrix__db_datamem(Reflex::Class*);
void __std__vector_HcalCovarianceMatrix__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalCovarianceMatrix__datamem_bld(&__std__vector_HcalCovarianceMatrix__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalCovarianceMatrix__funcmem_bld(&__std__vector_HcalCovarianceMatrix__db_funcmem);
void __std__vector_HcalCovarianceMatrix__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalCovarianceMatrix>"), typeid(::std::vector<HcalCovarianceMatrix>), sizeof(::std::vector<HcalCovarianceMatrix>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1797, ::Reflex::BaseOffset< ::std::vector<HcalCovarianceMatrix>, ::std::_Vector_base<HcalCovarianceMatrix,std::allocator<HcalCovarianceMatrix> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_333, Reflex::Literal("std::vector<HcalCovarianceMatrix>::_Alloc_value_type"))
  .AddTypedef(type_1797, Reflex::Literal("std::vector<HcalCovarianceMatrix>::_Base"))
  .AddTypedef(type_2145, Reflex::Literal("std::vector<HcalCovarianceMatrix>::_Tp_alloc_type"))
  .AddTypedef(type_3892, Reflex::Literal("std::vector<HcalCovarianceMatrix>::_Alloc_traits"))
  .AddTypedef(type_333, Reflex::Literal("std::vector<HcalCovarianceMatrix>::value_type"))
  .AddTypedef(type_4824, Reflex::Literal("std::vector<HcalCovarianceMatrix>::pointer"))
  .AddTypedef(type_5904, Reflex::Literal("std::vector<HcalCovarianceMatrix>::const_pointer"))
  .AddTypedef(type_5906, Reflex::Literal("std::vector<HcalCovarianceMatrix>::reference"))
  .AddTypedef(type_5908, Reflex::Literal("std::vector<HcalCovarianceMatrix>::const_reference"))
  .AddTypedef(type_3805, Reflex::Literal("std::vector<HcalCovarianceMatrix>::iterator"))
  .AddTypedef(type_3806, Reflex::Literal("std::vector<HcalCovarianceMatrix>::const_iterator"))
  .AddTypedef(type_2280, Reflex::Literal("std::vector<HcalCovarianceMatrix>::const_reverse_iterator"))
  .AddTypedef(type_2281, Reflex::Literal("std::vector<HcalCovarianceMatrix>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalCovarianceMatrix>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalCovarianceMatrix>::difference_type"))
  .AddTypedef(type_2145, Reflex::Literal("std::vector<HcalCovarianceMatrix>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5917, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12486), Reflex::Literal("vector"), constructor_5918, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_5908, type_12486), Reflex::Literal("vector"), constructor_5919, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12859), Reflex::Literal("vector"), constructor_5920, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5921, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1857, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalCovarianceMatrix__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalCovarianceMatrix,std::allocator<HcalCovarianceMatrix> > -------------------
void __std__vector_HcalCovarianceMatrix__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalCovarianceMatrix,std::allocator<HcalCovarianceMatrix> > -------------------
void __std__vector_HcalCovarianceMatrix__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12860, type_12859), Reflex::Literal("operator="), operator_5922, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_5908), Reflex::Literal("assign"), method_5923, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3805), Reflex::Literal("begin"), method_5924, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3806), Reflex::Literal("begin"), method_5925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3805), Reflex::Literal("end"), method_5926, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3806), Reflex::Literal("end"), method_5927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_5932, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_5933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_333), Reflex::Literal("resize"), method_5934, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_5935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_5936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_5937, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5906, type_2122), Reflex::Literal("operator[]"), operator_5938, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5908, type_2122), Reflex::Literal("operator[]"), operator_5939, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5906, type_2122), Reflex::Literal("at"), method_5941, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5908, type_2122), Reflex::Literal("at"), method_5942, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5906), Reflex::Literal("front"), method_5943, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5908), Reflex::Literal("front"), method_5944, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5906), Reflex::Literal("back"), method_5945, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5908), Reflex::Literal("back"), method_5946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4824), Reflex::Literal("data"), method_5947, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5904), Reflex::Literal("data"), method_5948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_5908), Reflex::Literal("push_back"), method_5949, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_5950, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3805, type_3805, type_5908), Reflex::Literal("insert"), method_5951, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3805, type_2122, type_5908), Reflex::Literal("insert"), method_5952, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3805, type_3805), Reflex::Literal("erase"), method_5953, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3805, type_3805, type_3805), Reflex::Literal("erase"), method_5954, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12860), Reflex::Literal("swap"), method_5955, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_5956, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalCholeskyMatrix,std::allocator<HcalCholeskyMatrix> > -------------------------------
static void constructor_5982( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCholeskyMatrix>();
  else ::new(mem) ::std::vector<HcalCholeskyMatrix>();
}

static void constructor_5983( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCholeskyMatrix>(*(const ::std::allocator<HcalCholeskyMatrix>*)arg[0]);
  else ::new(mem) ::std::vector<HcalCholeskyMatrix>(*(const ::std::allocator<HcalCholeskyMatrix>*)arg[0]);
}

static void constructor_5984( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCholeskyMatrix>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalCholeskyMatrix>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCholeskyMatrix>(*(::std::size_t*)arg[0],
      *(const ::HcalCholeskyMatrix*)arg[1]);
  else ::new(mem) ::std::vector<HcalCholeskyMatrix>(*(::std::size_t*)arg[0],
      *(const ::HcalCholeskyMatrix*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCholeskyMatrix>(*(::std::size_t*)arg[0],
      *(const ::HcalCholeskyMatrix*)arg[1],
      *(const ::std::allocator<HcalCholeskyMatrix>*)arg[2]);
  else ::new(mem) ::std::vector<HcalCholeskyMatrix>(*(::std::size_t*)arg[0],
      *(const ::HcalCholeskyMatrix*)arg[1],
      *(const ::std::allocator<HcalCholeskyMatrix>*)arg[2]);
  }
}

static void constructor_5985( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCholeskyMatrix>(*(const ::std::vector<HcalCholeskyMatrix>*)arg[0]);
  else ::new(mem) ::std::vector<HcalCholeskyMatrix>(*(const ::std::vector<HcalCholeskyMatrix>*)arg[0]);
}

static void destructor_5986(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalCholeskyMatrix>*)o)->::std::vector<HcalCholeskyMatrix>::~vector)();
}
static  void operator_5987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCholeskyMatrix>*)o)->operator=)(*(const ::std::vector<HcalCholeskyMatrix>*)arg[0]);
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->operator=)(*(const ::std::vector<HcalCholeskyMatrix>*)arg[0]);
}

static  void method_5988( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCholeskyMatrix>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalCholeskyMatrix*)arg[1]);
}

static  void method_5989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >)((((::std::vector<HcalCholeskyMatrix>*)o)->begin)());
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->begin)();
}

static  void method_5990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >)((((const ::std::vector<HcalCholeskyMatrix>*)o)->begin)());
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->begin)();
}

static  void method_5991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >)((((::std::vector<HcalCholeskyMatrix>*)o)->end)());
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->end)();
}

static  void method_5992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >)((((const ::std::vector<HcalCholeskyMatrix>*)o)->end)());
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->end)();
}

static  void method_5997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalCholeskyMatrix>*)o)->size)());
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->size)();
}

static  void method_5998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalCholeskyMatrix>*)o)->max_size)());
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->max_size)();
}

static  void method_5999( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalCholeskyMatrix>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalCholeskyMatrix>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalCholeskyMatrix*)arg[1]);
  }
}

static  void method_6000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalCholeskyMatrix>*)o)->capacity)());
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->capacity)();
}

static  void method_6001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalCholeskyMatrix>*)o)->empty)());
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->empty)();
}

static  void method_6002( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCholeskyMatrix>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCholeskyMatrix>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6004( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCholeskyMatrix>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6006( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCholeskyMatrix>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6007( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCholeskyMatrix>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCholeskyMatrix>*)o)->front)();
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->front)();
}

static  void method_6009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCholeskyMatrix>*)o)->front)();
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->front)();
}

static  void method_6010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCholeskyMatrix>*)o)->back)();
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->back)();
}

static  void method_6011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCholeskyMatrix>*)o)->back)();
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->back)();
}

static  void method_6012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalCholeskyMatrix>*)o)->data)());
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->data)();
}

static  void method_6013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalCholeskyMatrix>*)o)->data)());
  else   (((const ::std::vector<HcalCholeskyMatrix>*)o)->data)();
}

static  void method_6014( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCholeskyMatrix>*)o)->push_back)(*(const ::HcalCholeskyMatrix*)arg[0]);
}

static  void method_6015( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalCholeskyMatrix>*)o)->pop_back)();
}

static  void method_6016( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >)((((::std::vector<HcalCholeskyMatrix>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >*)arg[0],
    *(const ::HcalCholeskyMatrix*)arg[1]));
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >*)arg[0],
    *(const ::HcalCholeskyMatrix*)arg[1]);
}

static  void method_6017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCholeskyMatrix>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalCholeskyMatrix*)arg[2]);
}

static  void method_6018( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >)((((::std::vector<HcalCholeskyMatrix>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >*)arg[0]));
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >*)arg[0]);
}

static  void method_6019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >)((((::std::vector<HcalCholeskyMatrix>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >*)arg[1]));
  else   (((::std::vector<HcalCholeskyMatrix>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalCholeskyMatrix*,std::vector<HcalCholeskyMatrix> >*)arg[1]);
}

static  void method_6020( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCholeskyMatrix>*)o)->swap)(*(::std::vector<HcalCholeskyMatrix>*)arg[0]);
}

static  void method_6021( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalCholeskyMatrix>*)o)->clear)();
}

static void method_newdel_1858( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCholeskyMatrix> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCholeskyMatrix> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCholeskyMatrix> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCholeskyMatrix> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCholeskyMatrix> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x120( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalCholeskyMatrix,std::allocator<HcalCholeskyMatrix> >")), ::Reflex::BaseOffset< ::std::vector<HcalCholeskyMatrix>,::std::_Vector_base<HcalCholeskyMatrix,std::allocator<HcalCholeskyMatrix> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x121( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalCholeskyMatrix> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalCholeskyMatrix> >::Generate();
}

//------Dictionary for class vector<HcalCholeskyMatrix,std::allocator<HcalCholeskyMatrix> > -------------------------------
void __std__vector_HcalCholeskyMatrix__db_datamem(Reflex::Class*);
void __std__vector_HcalCholeskyMatrix__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalCholeskyMatrix__datamem_bld(&__std__vector_HcalCholeskyMatrix__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalCholeskyMatrix__funcmem_bld(&__std__vector_HcalCholeskyMatrix__db_funcmem);
void __std__vector_HcalCholeskyMatrix__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalCholeskyMatrix>"), typeid(::std::vector<HcalCholeskyMatrix>), sizeof(::std::vector<HcalCholeskyMatrix>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1798, ::Reflex::BaseOffset< ::std::vector<HcalCholeskyMatrix>, ::std::_Vector_base<HcalCholeskyMatrix,std::allocator<HcalCholeskyMatrix> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1671, Reflex::Literal("std::vector<HcalCholeskyMatrix>::_Alloc_value_type"))
  .AddTypedef(type_1798, Reflex::Literal("std::vector<HcalCholeskyMatrix>::_Base"))
  .AddTypedef(type_2146, Reflex::Literal("std::vector<HcalCholeskyMatrix>::_Tp_alloc_type"))
  .AddTypedef(type_3893, Reflex::Literal("std::vector<HcalCholeskyMatrix>::_Alloc_traits"))
  .AddTypedef(type_1671, Reflex::Literal("std::vector<HcalCholeskyMatrix>::value_type"))
  .AddTypedef(type_4843, Reflex::Literal("std::vector<HcalCholeskyMatrix>::pointer"))
  .AddTypedef(type_5969, Reflex::Literal("std::vector<HcalCholeskyMatrix>::const_pointer"))
  .AddTypedef(type_5971, Reflex::Literal("std::vector<HcalCholeskyMatrix>::reference"))
  .AddTypedef(type_5973, Reflex::Literal("std::vector<HcalCholeskyMatrix>::const_reference"))
  .AddTypedef(type_3807, Reflex::Literal("std::vector<HcalCholeskyMatrix>::iterator"))
  .AddTypedef(type_3808, Reflex::Literal("std::vector<HcalCholeskyMatrix>::const_iterator"))
  .AddTypedef(type_2282, Reflex::Literal("std::vector<HcalCholeskyMatrix>::const_reverse_iterator"))
  .AddTypedef(type_2283, Reflex::Literal("std::vector<HcalCholeskyMatrix>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalCholeskyMatrix>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalCholeskyMatrix>::difference_type"))
  .AddTypedef(type_2146, Reflex::Literal("std::vector<HcalCholeskyMatrix>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5982, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12499), Reflex::Literal("vector"), constructor_5983, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_5973, type_12499), Reflex::Literal("vector"), constructor_5984, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12862), Reflex::Literal("vector"), constructor_5985, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5986, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1858, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x121, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalCholeskyMatrix__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalCholeskyMatrix,std::allocator<HcalCholeskyMatrix> > -------------------
void __std__vector_HcalCholeskyMatrix__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalCholeskyMatrix,std::allocator<HcalCholeskyMatrix> > -------------------
void __std__vector_HcalCholeskyMatrix__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12863, type_12862), Reflex::Literal("operator="), operator_5987, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_5973), Reflex::Literal("assign"), method_5988, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3807), Reflex::Literal("begin"), method_5989, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3808), Reflex::Literal("begin"), method_5990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3807), Reflex::Literal("end"), method_5991, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3808), Reflex::Literal("end"), method_5992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_5997, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_5998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1671), Reflex::Literal("resize"), method_5999, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6000, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6001, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6002, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5971, type_2122), Reflex::Literal("operator[]"), operator_6003, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5973, type_2122), Reflex::Literal("operator[]"), operator_6004, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5971, type_2122), Reflex::Literal("at"), method_6006, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5973, type_2122), Reflex::Literal("at"), method_6007, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5971), Reflex::Literal("front"), method_6008, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5973), Reflex::Literal("front"), method_6009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5971), Reflex::Literal("back"), method_6010, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5973), Reflex::Literal("back"), method_6011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4843), Reflex::Literal("data"), method_6012, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5969), Reflex::Literal("data"), method_6013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_5973), Reflex::Literal("push_back"), method_6014, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6015, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3807, type_3807, type_5973), Reflex::Literal("insert"), method_6016, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3807, type_2122, type_5973), Reflex::Literal("insert"), method_6017, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3807, type_3807), Reflex::Literal("erase"), method_6018, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3807, type_3807, type_3807), Reflex::Literal("erase"), method_6019, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12863), Reflex::Literal("swap"), method_6020, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6021, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalLutMetadatum,std::allocator<HcalLutMetadatum> > -------------------------------
static void constructor_6047( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLutMetadatum>();
  else ::new(mem) ::std::vector<HcalLutMetadatum>();
}

static void constructor_6048( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLutMetadatum>(*(const ::std::allocator<HcalLutMetadatum>*)arg[0]);
  else ::new(mem) ::std::vector<HcalLutMetadatum>(*(const ::std::allocator<HcalLutMetadatum>*)arg[0]);
}

static void constructor_6049( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLutMetadatum>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalLutMetadatum>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLutMetadatum>(*(::std::size_t*)arg[0],
      *(const ::HcalLutMetadatum*)arg[1]);
  else ::new(mem) ::std::vector<HcalLutMetadatum>(*(::std::size_t*)arg[0],
      *(const ::HcalLutMetadatum*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLutMetadatum>(*(::std::size_t*)arg[0],
      *(const ::HcalLutMetadatum*)arg[1],
      *(const ::std::allocator<HcalLutMetadatum>*)arg[2]);
  else ::new(mem) ::std::vector<HcalLutMetadatum>(*(::std::size_t*)arg[0],
      *(const ::HcalLutMetadatum*)arg[1],
      *(const ::std::allocator<HcalLutMetadatum>*)arg[2]);
  }
}

static void constructor_6050( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLutMetadatum>(*(const ::std::vector<HcalLutMetadatum>*)arg[0]);
  else ::new(mem) ::std::vector<HcalLutMetadatum>(*(const ::std::vector<HcalLutMetadatum>*)arg[0]);
}

static void destructor_6051(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalLutMetadatum>*)o)->::std::vector<HcalLutMetadatum>::~vector)();
}
static  void operator_6052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLutMetadatum>*)o)->operator=)(*(const ::std::vector<HcalLutMetadatum>*)arg[0]);
  else   (((::std::vector<HcalLutMetadatum>*)o)->operator=)(*(const ::std::vector<HcalLutMetadatum>*)arg[0]);
}

static  void method_6053( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLutMetadatum>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalLutMetadatum*)arg[1]);
}

static  void method_6054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >)((((::std::vector<HcalLutMetadatum>*)o)->begin)());
  else   (((::std::vector<HcalLutMetadatum>*)o)->begin)();
}

static  void method_6055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalLutMetadatum*,std::vector<HcalLutMetadatum> >)((((const ::std::vector<HcalLutMetadatum>*)o)->begin)());
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->begin)();
}

static  void method_6056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >)((((::std::vector<HcalLutMetadatum>*)o)->end)());
  else   (((::std::vector<HcalLutMetadatum>*)o)->end)();
}

static  void method_6057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalLutMetadatum*,std::vector<HcalLutMetadatum> >)((((const ::std::vector<HcalLutMetadatum>*)o)->end)());
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->end)();
}

static  void method_6062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalLutMetadatum>*)o)->size)());
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->size)();
}

static  void method_6063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalLutMetadatum>*)o)->max_size)());
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->max_size)();
}

static  void method_6064( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalLutMetadatum>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalLutMetadatum>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalLutMetadatum*)arg[1]);
  }
}

static  void method_6065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalLutMetadatum>*)o)->capacity)());
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->capacity)();
}

static  void method_6066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalLutMetadatum>*)o)->empty)());
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->empty)();
}

static  void method_6067( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLutMetadatum>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLutMetadatum>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalLutMetadatum>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLutMetadatum>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLutMetadatum>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalLutMetadatum>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLutMetadatum>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLutMetadatum>*)o)->front)();
  else   (((::std::vector<HcalLutMetadatum>*)o)->front)();
}

static  void method_6074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLutMetadatum>*)o)->front)();
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->front)();
}

static  void method_6075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLutMetadatum>*)o)->back)();
  else   (((::std::vector<HcalLutMetadatum>*)o)->back)();
}

static  void method_6076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLutMetadatum>*)o)->back)();
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->back)();
}

static  void method_6077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalLutMetadatum>*)o)->data)());
  else   (((::std::vector<HcalLutMetadatum>*)o)->data)();
}

static  void method_6078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalLutMetadatum>*)o)->data)());
  else   (((const ::std::vector<HcalLutMetadatum>*)o)->data)();
}

static  void method_6079( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLutMetadatum>*)o)->push_back)(*(const ::HcalLutMetadatum*)arg[0]);
}

static  void method_6080( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalLutMetadatum>*)o)->pop_back)();
}

static  void method_6081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >)((((::std::vector<HcalLutMetadatum>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >*)arg[0],
    *(const ::HcalLutMetadatum*)arg[1]));
  else   (((::std::vector<HcalLutMetadatum>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >*)arg[0],
    *(const ::HcalLutMetadatum*)arg[1]);
}

static  void method_6082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLutMetadatum>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalLutMetadatum*)arg[2]);
}

static  void method_6083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >)((((::std::vector<HcalLutMetadatum>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >*)arg[0]));
  else   (((::std::vector<HcalLutMetadatum>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >*)arg[0]);
}

static  void method_6084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >)((((::std::vector<HcalLutMetadatum>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >*)arg[1]));
  else   (((::std::vector<HcalLutMetadatum>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalLutMetadatum*,std::vector<HcalLutMetadatum> >*)arg[1]);
}

static  void method_6085( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLutMetadatum>*)o)->swap)(*(::std::vector<HcalLutMetadatum>*)arg[0]);
}

static  void method_6086( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalLutMetadatum>*)o)->clear)();
}

static void method_newdel_1859( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLutMetadatum> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLutMetadatum> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLutMetadatum> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLutMetadatum> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLutMetadatum> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x123( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalLutMetadatum,std::allocator<HcalLutMetadatum> >")), ::Reflex::BaseOffset< ::std::vector<HcalLutMetadatum>,::std::_Vector_base<HcalLutMetadatum,std::allocator<HcalLutMetadatum> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalLutMetadatum> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalLutMetadatum> >::Generate();
}

//------Dictionary for class vector<HcalLutMetadatum,std::allocator<HcalLutMetadatum> > -------------------------------
void __std__vector_HcalLutMetadatum__db_datamem(Reflex::Class*);
void __std__vector_HcalLutMetadatum__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalLutMetadatum__datamem_bld(&__std__vector_HcalLutMetadatum__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalLutMetadatum__funcmem_bld(&__std__vector_HcalLutMetadatum__db_funcmem);
void __std__vector_HcalLutMetadatum__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalLutMetadatum>"), typeid(::std::vector<HcalLutMetadatum>), sizeof(::std::vector<HcalLutMetadatum>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1802, ::Reflex::BaseOffset< ::std::vector<HcalLutMetadatum>, ::std::_Vector_base<HcalLutMetadatum,std::allocator<HcalLutMetadatum> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1624, Reflex::Literal("std::vector<HcalLutMetadatum>::_Alloc_value_type"))
  .AddTypedef(type_1802, Reflex::Literal("std::vector<HcalLutMetadatum>::_Base"))
  .AddTypedef(type_2147, Reflex::Literal("std::vector<HcalLutMetadatum>::_Tp_alloc_type"))
  .AddTypedef(type_3897, Reflex::Literal("std::vector<HcalLutMetadatum>::_Alloc_traits"))
  .AddTypedef(type_1624, Reflex::Literal("std::vector<HcalLutMetadatum>::value_type"))
  .AddTypedef(type_4919, Reflex::Literal("std::vector<HcalLutMetadatum>::pointer"))
  .AddTypedef(type_6034, Reflex::Literal("std::vector<HcalLutMetadatum>::const_pointer"))
  .AddTypedef(type_6036, Reflex::Literal("std::vector<HcalLutMetadatum>::reference"))
  .AddTypedef(type_6038, Reflex::Literal("std::vector<HcalLutMetadatum>::const_reference"))
  .AddTypedef(type_3815, Reflex::Literal("std::vector<HcalLutMetadatum>::iterator"))
  .AddTypedef(type_3816, Reflex::Literal("std::vector<HcalLutMetadatum>::const_iterator"))
  .AddTypedef(type_2290, Reflex::Literal("std::vector<HcalLutMetadatum>::const_reverse_iterator"))
  .AddTypedef(type_2291, Reflex::Literal("std::vector<HcalLutMetadatum>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalLutMetadatum>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalLutMetadatum>::difference_type"))
  .AddTypedef(type_2147, Reflex::Literal("std::vector<HcalLutMetadatum>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6047, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12551), Reflex::Literal("vector"), constructor_6048, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6038, type_12551), Reflex::Literal("vector"), constructor_6049, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12865), Reflex::Literal("vector"), constructor_6050, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6051, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1859, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x123, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalLutMetadatum__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalLutMetadatum,std::allocator<HcalLutMetadatum> > -------------------
void __std__vector_HcalLutMetadatum__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalLutMetadatum,std::allocator<HcalLutMetadatum> > -------------------
void __std__vector_HcalLutMetadatum__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12866, type_12865), Reflex::Literal("operator="), operator_6052, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6038), Reflex::Literal("assign"), method_6053, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3815), Reflex::Literal("begin"), method_6054, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3816), Reflex::Literal("begin"), method_6055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3815), Reflex::Literal("end"), method_6056, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3816), Reflex::Literal("end"), method_6057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1624), Reflex::Literal("resize"), method_6064, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6067, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6036, type_2122), Reflex::Literal("operator[]"), operator_6068, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6038, type_2122), Reflex::Literal("operator[]"), operator_6069, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6036, type_2122), Reflex::Literal("at"), method_6071, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6038, type_2122), Reflex::Literal("at"), method_6072, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6036), Reflex::Literal("front"), method_6073, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6038), Reflex::Literal("front"), method_6074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6036), Reflex::Literal("back"), method_6075, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6038), Reflex::Literal("back"), method_6076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4919), Reflex::Literal("data"), method_6077, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6034), Reflex::Literal("data"), method_6078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6038), Reflex::Literal("push_back"), method_6079, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6080, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3815, type_3815, type_6038), Reflex::Literal("insert"), method_6081, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3815, type_2122, type_6038), Reflex::Literal("insert"), method_6082, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3815, type_3815), Reflex::Literal("erase"), method_6083, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3815, type_3815, type_3815), Reflex::Literal("erase"), method_6084, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12866), Reflex::Literal("swap"), method_6085, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6086, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalValidationCorr,std::allocator<HcalValidationCorr> > -------------------------------
static void constructor_6112( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalValidationCorr>();
  else ::new(mem) ::std::vector<HcalValidationCorr>();
}

static void constructor_6113( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalValidationCorr>(*(const ::std::allocator<HcalValidationCorr>*)arg[0]);
  else ::new(mem) ::std::vector<HcalValidationCorr>(*(const ::std::allocator<HcalValidationCorr>*)arg[0]);
}

static void constructor_6114( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalValidationCorr>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalValidationCorr>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalValidationCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalValidationCorr*)arg[1]);
  else ::new(mem) ::std::vector<HcalValidationCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalValidationCorr*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalValidationCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalValidationCorr*)arg[1],
      *(const ::std::allocator<HcalValidationCorr>*)arg[2]);
  else ::new(mem) ::std::vector<HcalValidationCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalValidationCorr*)arg[1],
      *(const ::std::allocator<HcalValidationCorr>*)arg[2]);
  }
}

static void constructor_6115( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalValidationCorr>(*(const ::std::vector<HcalValidationCorr>*)arg[0]);
  else ::new(mem) ::std::vector<HcalValidationCorr>(*(const ::std::vector<HcalValidationCorr>*)arg[0]);
}

static void destructor_6116(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalValidationCorr>*)o)->::std::vector<HcalValidationCorr>::~vector)();
}
static  void operator_6117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalValidationCorr>*)o)->operator=)(*(const ::std::vector<HcalValidationCorr>*)arg[0]);
  else   (((::std::vector<HcalValidationCorr>*)o)->operator=)(*(const ::std::vector<HcalValidationCorr>*)arg[0]);
}

static  void method_6118( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalValidationCorr>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalValidationCorr*)arg[1]);
}

static  void method_6119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >)((((::std::vector<HcalValidationCorr>*)o)->begin)());
  else   (((::std::vector<HcalValidationCorr>*)o)->begin)();
}

static  void method_6120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalValidationCorr*,std::vector<HcalValidationCorr> >)((((const ::std::vector<HcalValidationCorr>*)o)->begin)());
  else   (((const ::std::vector<HcalValidationCorr>*)o)->begin)();
}

static  void method_6121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >)((((::std::vector<HcalValidationCorr>*)o)->end)());
  else   (((::std::vector<HcalValidationCorr>*)o)->end)();
}

static  void method_6122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalValidationCorr*,std::vector<HcalValidationCorr> >)((((const ::std::vector<HcalValidationCorr>*)o)->end)());
  else   (((const ::std::vector<HcalValidationCorr>*)o)->end)();
}

static  void method_6127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalValidationCorr>*)o)->size)());
  else   (((const ::std::vector<HcalValidationCorr>*)o)->size)();
}

static  void method_6128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalValidationCorr>*)o)->max_size)());
  else   (((const ::std::vector<HcalValidationCorr>*)o)->max_size)();
}

static  void method_6129( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalValidationCorr>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalValidationCorr>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalValidationCorr*)arg[1]);
  }
}

static  void method_6130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalValidationCorr>*)o)->capacity)());
  else   (((const ::std::vector<HcalValidationCorr>*)o)->capacity)();
}

static  void method_6131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalValidationCorr>*)o)->empty)());
  else   (((const ::std::vector<HcalValidationCorr>*)o)->empty)();
}

static  void method_6132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalValidationCorr>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalValidationCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalValidationCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalValidationCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalValidationCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalValidationCorr>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalValidationCorr>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalValidationCorr>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalValidationCorr>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalValidationCorr>*)o)->front)();
  else   (((::std::vector<HcalValidationCorr>*)o)->front)();
}

static  void method_6139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalValidationCorr>*)o)->front)();
  else   (((const ::std::vector<HcalValidationCorr>*)o)->front)();
}

static  void method_6140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalValidationCorr>*)o)->back)();
  else   (((::std::vector<HcalValidationCorr>*)o)->back)();
}

static  void method_6141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalValidationCorr>*)o)->back)();
  else   (((const ::std::vector<HcalValidationCorr>*)o)->back)();
}

static  void method_6142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalValidationCorr>*)o)->data)());
  else   (((::std::vector<HcalValidationCorr>*)o)->data)();
}

static  void method_6143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalValidationCorr>*)o)->data)());
  else   (((const ::std::vector<HcalValidationCorr>*)o)->data)();
}

static  void method_6144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalValidationCorr>*)o)->push_back)(*(const ::HcalValidationCorr*)arg[0]);
}

static  void method_6145( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalValidationCorr>*)o)->pop_back)();
}

static  void method_6146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >)((((::std::vector<HcalValidationCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >*)arg[0],
    *(const ::HcalValidationCorr*)arg[1]));
  else   (((::std::vector<HcalValidationCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >*)arg[0],
    *(const ::HcalValidationCorr*)arg[1]);
}

static  void method_6147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalValidationCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalValidationCorr*)arg[2]);
}

static  void method_6148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >)((((::std::vector<HcalValidationCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >*)arg[0]));
  else   (((::std::vector<HcalValidationCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >*)arg[0]);
}

static  void method_6149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >)((((::std::vector<HcalValidationCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >*)arg[1]));
  else   (((::std::vector<HcalValidationCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalValidationCorr*,std::vector<HcalValidationCorr> >*)arg[1]);
}

static  void method_6150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalValidationCorr>*)o)->swap)(*(::std::vector<HcalValidationCorr>*)arg[0]);
}

static  void method_6151( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalValidationCorr>*)o)->clear)();
}

static void method_newdel_1860( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalValidationCorr> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalValidationCorr> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalValidationCorr> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalValidationCorr> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalValidationCorr> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalValidationCorr,std::allocator<HcalValidationCorr> >")), ::Reflex::BaseOffset< ::std::vector<HcalValidationCorr>,::std::_Vector_base<HcalValidationCorr,std::allocator<HcalValidationCorr> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x127( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalValidationCorr> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalValidationCorr> >::Generate();
}

//------Dictionary for class vector<HcalValidationCorr,std::allocator<HcalValidationCorr> > -------------------------------
void __std__vector_HcalValidationCorr__db_datamem(Reflex::Class*);
void __std__vector_HcalValidationCorr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalValidationCorr__datamem_bld(&__std__vector_HcalValidationCorr__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalValidationCorr__funcmem_bld(&__std__vector_HcalValidationCorr__db_funcmem);
void __std__vector_HcalValidationCorr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalValidationCorr>"), typeid(::std::vector<HcalValidationCorr>), sizeof(::std::vector<HcalValidationCorr>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1803, ::Reflex::BaseOffset< ::std::vector<HcalValidationCorr>, ::std::_Vector_base<HcalValidationCorr,std::allocator<HcalValidationCorr> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_50, Reflex::Literal("std::vector<HcalValidationCorr>::_Alloc_value_type"))
  .AddTypedef(type_1803, Reflex::Literal("std::vector<HcalValidationCorr>::_Base"))
  .AddTypedef(type_2148, Reflex::Literal("std::vector<HcalValidationCorr>::_Tp_alloc_type"))
  .AddTypedef(type_3898, Reflex::Literal("std::vector<HcalValidationCorr>::_Alloc_traits"))
  .AddTypedef(type_50, Reflex::Literal("std::vector<HcalValidationCorr>::value_type"))
  .AddTypedef(type_4938, Reflex::Literal("std::vector<HcalValidationCorr>::pointer"))
  .AddTypedef(type_6099, Reflex::Literal("std::vector<HcalValidationCorr>::const_pointer"))
  .AddTypedef(type_6101, Reflex::Literal("std::vector<HcalValidationCorr>::reference"))
  .AddTypedef(type_6103, Reflex::Literal("std::vector<HcalValidationCorr>::const_reference"))
  .AddTypedef(type_3817, Reflex::Literal("std::vector<HcalValidationCorr>::iterator"))
  .AddTypedef(type_3818, Reflex::Literal("std::vector<HcalValidationCorr>::const_iterator"))
  .AddTypedef(type_2292, Reflex::Literal("std::vector<HcalValidationCorr>::const_reverse_iterator"))
  .AddTypedef(type_2293, Reflex::Literal("std::vector<HcalValidationCorr>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalValidationCorr>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalValidationCorr>::difference_type"))
  .AddTypedef(type_2148, Reflex::Literal("std::vector<HcalValidationCorr>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6112, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12564), Reflex::Literal("vector"), constructor_6113, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6103, type_12564), Reflex::Literal("vector"), constructor_6114, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12868), Reflex::Literal("vector"), constructor_6115, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6116, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1860, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x127, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalValidationCorr__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalValidationCorr,std::allocator<HcalValidationCorr> > -------------------
void __std__vector_HcalValidationCorr__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalValidationCorr,std::allocator<HcalValidationCorr> > -------------------
void __std__vector_HcalValidationCorr__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12869, type_12868), Reflex::Literal("operator="), operator_6117, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6103), Reflex::Literal("assign"), method_6118, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3817), Reflex::Literal("begin"), method_6119, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3818), Reflex::Literal("begin"), method_6120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3817), Reflex::Literal("end"), method_6121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3818), Reflex::Literal("end"), method_6122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_50), Reflex::Literal("resize"), method_6129, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6132, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6101, type_2122), Reflex::Literal("operator[]"), operator_6133, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6103, type_2122), Reflex::Literal("operator[]"), operator_6134, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6101, type_2122), Reflex::Literal("at"), method_6136, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6103, type_2122), Reflex::Literal("at"), method_6137, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6101), Reflex::Literal("front"), method_6138, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6103), Reflex::Literal("front"), method_6139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6101), Reflex::Literal("back"), method_6140, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6103), Reflex::Literal("back"), method_6141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4938), Reflex::Literal("data"), method_6142, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6099), Reflex::Literal("data"), method_6143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6103), Reflex::Literal("push_back"), method_6144, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6145, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3817, type_3817, type_6103), Reflex::Literal("insert"), method_6146, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3817, type_2122, type_6103), Reflex::Literal("insert"), method_6147, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3817, type_3817), Reflex::Literal("erase"), method_6148, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3817, type_3817, type_3817), Reflex::Literal("erase"), method_6149, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12869), Reflex::Literal("swap"), method_6150, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6151, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalTimeCorr,std::allocator<HcalTimeCorr> > -------------------------------
static void constructor_6177( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimeCorr>();
  else ::new(mem) ::std::vector<HcalTimeCorr>();
}

static void constructor_6178( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimeCorr>(*(const ::std::allocator<HcalTimeCorr>*)arg[0]);
  else ::new(mem) ::std::vector<HcalTimeCorr>(*(const ::std::allocator<HcalTimeCorr>*)arg[0]);
}

static void constructor_6179( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimeCorr>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalTimeCorr>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimeCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalTimeCorr*)arg[1]);
  else ::new(mem) ::std::vector<HcalTimeCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalTimeCorr*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimeCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalTimeCorr*)arg[1],
      *(const ::std::allocator<HcalTimeCorr>*)arg[2]);
  else ::new(mem) ::std::vector<HcalTimeCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalTimeCorr*)arg[1],
      *(const ::std::allocator<HcalTimeCorr>*)arg[2]);
  }
}

static void constructor_6180( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalTimeCorr>(*(const ::std::vector<HcalTimeCorr>*)arg[0]);
  else ::new(mem) ::std::vector<HcalTimeCorr>(*(const ::std::vector<HcalTimeCorr>*)arg[0]);
}

static void destructor_6181(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalTimeCorr>*)o)->::std::vector<HcalTimeCorr>::~vector)();
}
static  void operator_6182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalTimeCorr>*)o)->operator=)(*(const ::std::vector<HcalTimeCorr>*)arg[0]);
  else   (((::std::vector<HcalTimeCorr>*)o)->operator=)(*(const ::std::vector<HcalTimeCorr>*)arg[0]);
}

static  void method_6183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalTimeCorr>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalTimeCorr*)arg[1]);
}

static  void method_6184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >)((((::std::vector<HcalTimeCorr>*)o)->begin)());
  else   (((::std::vector<HcalTimeCorr>*)o)->begin)();
}

static  void method_6185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalTimeCorr*,std::vector<HcalTimeCorr> >)((((const ::std::vector<HcalTimeCorr>*)o)->begin)());
  else   (((const ::std::vector<HcalTimeCorr>*)o)->begin)();
}

static  void method_6186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >)((((::std::vector<HcalTimeCorr>*)o)->end)());
  else   (((::std::vector<HcalTimeCorr>*)o)->end)();
}

static  void method_6187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalTimeCorr*,std::vector<HcalTimeCorr> >)((((const ::std::vector<HcalTimeCorr>*)o)->end)());
  else   (((const ::std::vector<HcalTimeCorr>*)o)->end)();
}

static  void method_6192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalTimeCorr>*)o)->size)());
  else   (((const ::std::vector<HcalTimeCorr>*)o)->size)();
}

static  void method_6193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalTimeCorr>*)o)->max_size)());
  else   (((const ::std::vector<HcalTimeCorr>*)o)->max_size)();
}

static  void method_6194( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalTimeCorr>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalTimeCorr>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalTimeCorr*)arg[1]);
  }
}

static  void method_6195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalTimeCorr>*)o)->capacity)());
  else   (((const ::std::vector<HcalTimeCorr>*)o)->capacity)();
}

static  void method_6196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalTimeCorr>*)o)->empty)());
  else   (((const ::std::vector<HcalTimeCorr>*)o)->empty)();
}

static  void method_6197( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalTimeCorr>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalTimeCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalTimeCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalTimeCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalTimeCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalTimeCorr>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalTimeCorr>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalTimeCorr>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalTimeCorr>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalTimeCorr>*)o)->front)();
  else   (((::std::vector<HcalTimeCorr>*)o)->front)();
}

static  void method_6204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalTimeCorr>*)o)->front)();
  else   (((const ::std::vector<HcalTimeCorr>*)o)->front)();
}

static  void method_6205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalTimeCorr>*)o)->back)();
  else   (((::std::vector<HcalTimeCorr>*)o)->back)();
}

static  void method_6206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalTimeCorr>*)o)->back)();
  else   (((const ::std::vector<HcalTimeCorr>*)o)->back)();
}

static  void method_6207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalTimeCorr>*)o)->data)());
  else   (((::std::vector<HcalTimeCorr>*)o)->data)();
}

static  void method_6208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalTimeCorr>*)o)->data)());
  else   (((const ::std::vector<HcalTimeCorr>*)o)->data)();
}

static  void method_6209( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalTimeCorr>*)o)->push_back)(*(const ::HcalTimeCorr*)arg[0]);
}

static  void method_6210( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalTimeCorr>*)o)->pop_back)();
}

static  void method_6211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >)((((::std::vector<HcalTimeCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >*)arg[0],
    *(const ::HcalTimeCorr*)arg[1]));
  else   (((::std::vector<HcalTimeCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >*)arg[0],
    *(const ::HcalTimeCorr*)arg[1]);
}

static  void method_6212( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalTimeCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalTimeCorr*)arg[2]);
}

static  void method_6213( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >)((((::std::vector<HcalTimeCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >*)arg[0]));
  else   (((::std::vector<HcalTimeCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >*)arg[0]);
}

static  void method_6214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >)((((::std::vector<HcalTimeCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >*)arg[1]));
  else   (((::std::vector<HcalTimeCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalTimeCorr*,std::vector<HcalTimeCorr> >*)arg[1]);
}

static  void method_6215( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalTimeCorr>*)o)->swap)(*(::std::vector<HcalTimeCorr>*)arg[0]);
}

static  void method_6216( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalTimeCorr>*)o)->clear)();
}

static void method_newdel_1861( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalTimeCorr> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalTimeCorr> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalTimeCorr> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalTimeCorr> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalTimeCorr> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x129( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalTimeCorr,std::allocator<HcalTimeCorr> >")), ::Reflex::BaseOffset< ::std::vector<HcalTimeCorr>,::std::_Vector_base<HcalTimeCorr,std::allocator<HcalTimeCorr> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x130( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalTimeCorr> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalTimeCorr> >::Generate();
}

//------Dictionary for class vector<HcalTimeCorr,std::allocator<HcalTimeCorr> > -------------------------------
void __std__vector_HcalTimeCorr__db_datamem(Reflex::Class*);
void __std__vector_HcalTimeCorr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalTimeCorr__datamem_bld(&__std__vector_HcalTimeCorr__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalTimeCorr__funcmem_bld(&__std__vector_HcalTimeCorr__db_funcmem);
void __std__vector_HcalTimeCorr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalTimeCorr>"), typeid(::std::vector<HcalTimeCorr>), sizeof(::std::vector<HcalTimeCorr>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1806, ::Reflex::BaseOffset< ::std::vector<HcalTimeCorr>, ::std::_Vector_base<HcalTimeCorr,std::allocator<HcalTimeCorr> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_27, Reflex::Literal("std::vector<HcalTimeCorr>::_Alloc_value_type"))
  .AddTypedef(type_1806, Reflex::Literal("std::vector<HcalTimeCorr>::_Base"))
  .AddTypedef(type_2149, Reflex::Literal("std::vector<HcalTimeCorr>::_Tp_alloc_type"))
  .AddTypedef(type_3901, Reflex::Literal("std::vector<HcalTimeCorr>::_Alloc_traits"))
  .AddTypedef(type_27, Reflex::Literal("std::vector<HcalTimeCorr>::value_type"))
  .AddTypedef(type_4995, Reflex::Literal("std::vector<HcalTimeCorr>::pointer"))
  .AddTypedef(type_6164, Reflex::Literal("std::vector<HcalTimeCorr>::const_pointer"))
  .AddTypedef(type_6166, Reflex::Literal("std::vector<HcalTimeCorr>::reference"))
  .AddTypedef(type_6168, Reflex::Literal("std::vector<HcalTimeCorr>::const_reference"))
  .AddTypedef(type_3823, Reflex::Literal("std::vector<HcalTimeCorr>::iterator"))
  .AddTypedef(type_3824, Reflex::Literal("std::vector<HcalTimeCorr>::const_iterator"))
  .AddTypedef(type_2298, Reflex::Literal("std::vector<HcalTimeCorr>::const_reverse_iterator"))
  .AddTypedef(type_2299, Reflex::Literal("std::vector<HcalTimeCorr>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalTimeCorr>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalTimeCorr>::difference_type"))
  .AddTypedef(type_2149, Reflex::Literal("std::vector<HcalTimeCorr>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6177, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12603), Reflex::Literal("vector"), constructor_6178, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6168, type_12603), Reflex::Literal("vector"), constructor_6179, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12871), Reflex::Literal("vector"), constructor_6180, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6181, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1861, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x129, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalTimeCorr__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalTimeCorr,std::allocator<HcalTimeCorr> > -------------------
void __std__vector_HcalTimeCorr__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalTimeCorr,std::allocator<HcalTimeCorr> > -------------------
void __std__vector_HcalTimeCorr__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12872, type_12871), Reflex::Literal("operator="), operator_6182, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6168), Reflex::Literal("assign"), method_6183, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3823), Reflex::Literal("begin"), method_6184, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3824), Reflex::Literal("begin"), method_6185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3823), Reflex::Literal("end"), method_6186, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3824), Reflex::Literal("end"), method_6187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_27), Reflex::Literal("resize"), method_6194, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6197, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6166, type_2122), Reflex::Literal("operator[]"), operator_6198, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6168, type_2122), Reflex::Literal("operator[]"), operator_6199, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6166, type_2122), Reflex::Literal("at"), method_6201, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6168, type_2122), Reflex::Literal("at"), method_6202, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6166), Reflex::Literal("front"), method_6203, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6168), Reflex::Literal("front"), method_6204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6166), Reflex::Literal("back"), method_6205, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6168), Reflex::Literal("back"), method_6206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4995), Reflex::Literal("data"), method_6207, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6164), Reflex::Literal("data"), method_6208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6168), Reflex::Literal("push_back"), method_6209, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6210, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3823, type_3823, type_6168), Reflex::Literal("insert"), method_6211, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3823, type_2122, type_6168), Reflex::Literal("insert"), method_6212, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3823, type_3823), Reflex::Literal("erase"), method_6213, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3823, type_3823, type_3823), Reflex::Literal("erase"), method_6214, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12872), Reflex::Literal("swap"), method_6215, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6216, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalL1TriggerObject,std::allocator<HcalL1TriggerObject> > -------------------------------
static void constructor_6242( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalL1TriggerObject>();
  else ::new(mem) ::std::vector<HcalL1TriggerObject>();
}

static void constructor_6243( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalL1TriggerObject>(*(const ::std::allocator<HcalL1TriggerObject>*)arg[0]);
  else ::new(mem) ::std::vector<HcalL1TriggerObject>(*(const ::std::allocator<HcalL1TriggerObject>*)arg[0]);
}

static void constructor_6244( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalL1TriggerObject>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalL1TriggerObject>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalL1TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::HcalL1TriggerObject*)arg[1]);
  else ::new(mem) ::std::vector<HcalL1TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::HcalL1TriggerObject*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalL1TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::HcalL1TriggerObject*)arg[1],
      *(const ::std::allocator<HcalL1TriggerObject>*)arg[2]);
  else ::new(mem) ::std::vector<HcalL1TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::HcalL1TriggerObject*)arg[1],
      *(const ::std::allocator<HcalL1TriggerObject>*)arg[2]);
  }
}

static void constructor_6245( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalL1TriggerObject>(*(const ::std::vector<HcalL1TriggerObject>*)arg[0]);
  else ::new(mem) ::std::vector<HcalL1TriggerObject>(*(const ::std::vector<HcalL1TriggerObject>*)arg[0]);
}

static void destructor_6246(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalL1TriggerObject>*)o)->::std::vector<HcalL1TriggerObject>::~vector)();
}
static  void operator_6247( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalL1TriggerObject>*)o)->operator=)(*(const ::std::vector<HcalL1TriggerObject>*)arg[0]);
  else   (((::std::vector<HcalL1TriggerObject>*)o)->operator=)(*(const ::std::vector<HcalL1TriggerObject>*)arg[0]);
}

static  void method_6248( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalL1TriggerObject>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalL1TriggerObject*)arg[1]);
}

static  void method_6249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >)((((::std::vector<HcalL1TriggerObject>*)o)->begin)());
  else   (((::std::vector<HcalL1TriggerObject>*)o)->begin)();
}

static  void method_6250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >)((((const ::std::vector<HcalL1TriggerObject>*)o)->begin)());
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->begin)();
}

static  void method_6251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >)((((::std::vector<HcalL1TriggerObject>*)o)->end)());
  else   (((::std::vector<HcalL1TriggerObject>*)o)->end)();
}

static  void method_6252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >)((((const ::std::vector<HcalL1TriggerObject>*)o)->end)());
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->end)();
}

static  void method_6257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalL1TriggerObject>*)o)->size)());
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->size)();
}

static  void method_6258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalL1TriggerObject>*)o)->max_size)());
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->max_size)();
}

static  void method_6259( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalL1TriggerObject>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalL1TriggerObject>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalL1TriggerObject*)arg[1]);
  }
}

static  void method_6260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalL1TriggerObject>*)o)->capacity)());
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->capacity)();
}

static  void method_6261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalL1TriggerObject>*)o)->empty)());
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->empty)();
}

static  void method_6262( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalL1TriggerObject>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6263( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalL1TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalL1TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalL1TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalL1TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalL1TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalL1TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalL1TriggerObject>*)o)->front)();
  else   (((::std::vector<HcalL1TriggerObject>*)o)->front)();
}

static  void method_6269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalL1TriggerObject>*)o)->front)();
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->front)();
}

static  void method_6270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalL1TriggerObject>*)o)->back)();
  else   (((::std::vector<HcalL1TriggerObject>*)o)->back)();
}

static  void method_6271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalL1TriggerObject>*)o)->back)();
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->back)();
}

static  void method_6272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalL1TriggerObject>*)o)->data)());
  else   (((::std::vector<HcalL1TriggerObject>*)o)->data)();
}

static  void method_6273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalL1TriggerObject>*)o)->data)());
  else   (((const ::std::vector<HcalL1TriggerObject>*)o)->data)();
}

static  void method_6274( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalL1TriggerObject>*)o)->push_back)(*(const ::HcalL1TriggerObject*)arg[0]);
}

static  void method_6275( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalL1TriggerObject>*)o)->pop_back)();
}

static  void method_6276( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >)((((::std::vector<HcalL1TriggerObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >*)arg[0],
    *(const ::HcalL1TriggerObject*)arg[1]));
  else   (((::std::vector<HcalL1TriggerObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >*)arg[0],
    *(const ::HcalL1TriggerObject*)arg[1]);
}

static  void method_6277( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalL1TriggerObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalL1TriggerObject*)arg[2]);
}

static  void method_6278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >)((((::std::vector<HcalL1TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >*)arg[0]));
  else   (((::std::vector<HcalL1TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >*)arg[0]);
}

static  void method_6279( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >)((((::std::vector<HcalL1TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >*)arg[1]));
  else   (((::std::vector<HcalL1TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalL1TriggerObject*,std::vector<HcalL1TriggerObject> >*)arg[1]);
}

static  void method_6280( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalL1TriggerObject>*)o)->swap)(*(::std::vector<HcalL1TriggerObject>*)arg[0]);
}

static  void method_6281( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalL1TriggerObject>*)o)->clear)();
}

static void method_newdel_1862( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalL1TriggerObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalL1TriggerObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalL1TriggerObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalL1TriggerObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalL1TriggerObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x132( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalL1TriggerObject,std::allocator<HcalL1TriggerObject> >")), ::Reflex::BaseOffset< ::std::vector<HcalL1TriggerObject>,::std::_Vector_base<HcalL1TriggerObject,std::allocator<HcalL1TriggerObject> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x133( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalL1TriggerObject> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalL1TriggerObject> >::Generate();
}

//------Dictionary for class vector<HcalL1TriggerObject,std::allocator<HcalL1TriggerObject> > -------------------------------
void __std__vector_HcalL1TriggerObject__db_datamem(Reflex::Class*);
void __std__vector_HcalL1TriggerObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalL1TriggerObject__datamem_bld(&__std__vector_HcalL1TriggerObject__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalL1TriggerObject__funcmem_bld(&__std__vector_HcalL1TriggerObject__db_funcmem);
void __std__vector_HcalL1TriggerObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalL1TriggerObject>"), typeid(::std::vector<HcalL1TriggerObject>), sizeof(::std::vector<HcalL1TriggerObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1807, ::Reflex::BaseOffset< ::std::vector<HcalL1TriggerObject>, ::std::_Vector_base<HcalL1TriggerObject,std::allocator<HcalL1TriggerObject> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_491, Reflex::Literal("std::vector<HcalL1TriggerObject>::_Alloc_value_type"))
  .AddTypedef(type_1807, Reflex::Literal("std::vector<HcalL1TriggerObject>::_Base"))
  .AddTypedef(type_2150, Reflex::Literal("std::vector<HcalL1TriggerObject>::_Tp_alloc_type"))
  .AddTypedef(type_3902, Reflex::Literal("std::vector<HcalL1TriggerObject>::_Alloc_traits"))
  .AddTypedef(type_491, Reflex::Literal("std::vector<HcalL1TriggerObject>::value_type"))
  .AddTypedef(type_5014, Reflex::Literal("std::vector<HcalL1TriggerObject>::pointer"))
  .AddTypedef(type_6229, Reflex::Literal("std::vector<HcalL1TriggerObject>::const_pointer"))
  .AddTypedef(type_6231, Reflex::Literal("std::vector<HcalL1TriggerObject>::reference"))
  .AddTypedef(type_6233, Reflex::Literal("std::vector<HcalL1TriggerObject>::const_reference"))
  .AddTypedef(type_3825, Reflex::Literal("std::vector<HcalL1TriggerObject>::iterator"))
  .AddTypedef(type_3826, Reflex::Literal("std::vector<HcalL1TriggerObject>::const_iterator"))
  .AddTypedef(type_2300, Reflex::Literal("std::vector<HcalL1TriggerObject>::const_reverse_iterator"))
  .AddTypedef(type_2301, Reflex::Literal("std::vector<HcalL1TriggerObject>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalL1TriggerObject>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalL1TriggerObject>::difference_type"))
  .AddTypedef(type_2150, Reflex::Literal("std::vector<HcalL1TriggerObject>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6242, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12616), Reflex::Literal("vector"), constructor_6243, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6233, type_12616), Reflex::Literal("vector"), constructor_6244, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12874), Reflex::Literal("vector"), constructor_6245, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6246, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1862, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x132, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x133, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalL1TriggerObject__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalL1TriggerObject,std::allocator<HcalL1TriggerObject> > -------------------
void __std__vector_HcalL1TriggerObject__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalL1TriggerObject,std::allocator<HcalL1TriggerObject> > -------------------
void __std__vector_HcalL1TriggerObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12875, type_12874), Reflex::Literal("operator="), operator_6247, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6233), Reflex::Literal("assign"), method_6248, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825), Reflex::Literal("begin"), method_6249, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3826), Reflex::Literal("begin"), method_6250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825), Reflex::Literal("end"), method_6251, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3826), Reflex::Literal("end"), method_6252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6257, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_491), Reflex::Literal("resize"), method_6259, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6261, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6262, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6231, type_2122), Reflex::Literal("operator[]"), operator_6263, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6233, type_2122), Reflex::Literal("operator[]"), operator_6264, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6231, type_2122), Reflex::Literal("at"), method_6266, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6233, type_2122), Reflex::Literal("at"), method_6267, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6231), Reflex::Literal("front"), method_6268, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6233), Reflex::Literal("front"), method_6269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6231), Reflex::Literal("back"), method_6270, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6233), Reflex::Literal("back"), method_6271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5014), Reflex::Literal("data"), method_6272, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6229), Reflex::Literal("data"), method_6273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6233), Reflex::Literal("push_back"), method_6274, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6275, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825, type_3825, type_6233), Reflex::Literal("insert"), method_6276, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3825, type_2122, type_6233), Reflex::Literal("insert"), method_6277, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825, type_3825), Reflex::Literal("erase"), method_6278, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825, type_3825, type_3825), Reflex::Literal("erase"), method_6279, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12875), Reflex::Literal("swap"), method_6280, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6281, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalPFCorr,std::allocator<HcalPFCorr> > -------------------------------
static void constructor_6307( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPFCorr>();
  else ::new(mem) ::std::vector<HcalPFCorr>();
}

static void constructor_6308( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPFCorr>(*(const ::std::allocator<HcalPFCorr>*)arg[0]);
  else ::new(mem) ::std::vector<HcalPFCorr>(*(const ::std::allocator<HcalPFCorr>*)arg[0]);
}

static void constructor_6309( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPFCorr>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalPFCorr>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPFCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalPFCorr*)arg[1]);
  else ::new(mem) ::std::vector<HcalPFCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalPFCorr*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPFCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalPFCorr*)arg[1],
      *(const ::std::allocator<HcalPFCorr>*)arg[2]);
  else ::new(mem) ::std::vector<HcalPFCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalPFCorr*)arg[1],
      *(const ::std::allocator<HcalPFCorr>*)arg[2]);
  }
}

static void constructor_6310( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPFCorr>(*(const ::std::vector<HcalPFCorr>*)arg[0]);
  else ::new(mem) ::std::vector<HcalPFCorr>(*(const ::std::vector<HcalPFCorr>*)arg[0]);
}

static void destructor_6311(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalPFCorr>*)o)->::std::vector<HcalPFCorr>::~vector)();
}
static  void operator_6312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPFCorr>*)o)->operator=)(*(const ::std::vector<HcalPFCorr>*)arg[0]);
  else   (((::std::vector<HcalPFCorr>*)o)->operator=)(*(const ::std::vector<HcalPFCorr>*)arg[0]);
}

static  void method_6313( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPFCorr>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalPFCorr*)arg[1]);
}

static  void method_6314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >)((((::std::vector<HcalPFCorr>*)o)->begin)());
  else   (((::std::vector<HcalPFCorr>*)o)->begin)();
}

static  void method_6315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalPFCorr*,std::vector<HcalPFCorr> >)((((const ::std::vector<HcalPFCorr>*)o)->begin)());
  else   (((const ::std::vector<HcalPFCorr>*)o)->begin)();
}

static  void method_6316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >)((((::std::vector<HcalPFCorr>*)o)->end)());
  else   (((::std::vector<HcalPFCorr>*)o)->end)();
}

static  void method_6317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalPFCorr*,std::vector<HcalPFCorr> >)((((const ::std::vector<HcalPFCorr>*)o)->end)());
  else   (((const ::std::vector<HcalPFCorr>*)o)->end)();
}

static  void method_6322( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalPFCorr>*)o)->size)());
  else   (((const ::std::vector<HcalPFCorr>*)o)->size)();
}

static  void method_6323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalPFCorr>*)o)->max_size)());
  else   (((const ::std::vector<HcalPFCorr>*)o)->max_size)();
}

static  void method_6324( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalPFCorr>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalPFCorr>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalPFCorr*)arg[1]);
  }
}

static  void method_6325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalPFCorr>*)o)->capacity)());
  else   (((const ::std::vector<HcalPFCorr>*)o)->capacity)();
}

static  void method_6326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalPFCorr>*)o)->empty)());
  else   (((const ::std::vector<HcalPFCorr>*)o)->empty)();
}

static  void method_6327( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPFCorr>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6328( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPFCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalPFCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPFCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalPFCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPFCorr>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalPFCorr>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6332( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPFCorr>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalPFCorr>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPFCorr>*)o)->front)();
  else   (((::std::vector<HcalPFCorr>*)o)->front)();
}

static  void method_6334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPFCorr>*)o)->front)();
  else   (((const ::std::vector<HcalPFCorr>*)o)->front)();
}

static  void method_6335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPFCorr>*)o)->back)();
  else   (((::std::vector<HcalPFCorr>*)o)->back)();
}

static  void method_6336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPFCorr>*)o)->back)();
  else   (((const ::std::vector<HcalPFCorr>*)o)->back)();
}

static  void method_6337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalPFCorr>*)o)->data)());
  else   (((::std::vector<HcalPFCorr>*)o)->data)();
}

static  void method_6338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalPFCorr>*)o)->data)());
  else   (((const ::std::vector<HcalPFCorr>*)o)->data)();
}

static  void method_6339( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPFCorr>*)o)->push_back)(*(const ::HcalPFCorr*)arg[0]);
}

static  void method_6340( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalPFCorr>*)o)->pop_back)();
}

static  void method_6341( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >)((((::std::vector<HcalPFCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >*)arg[0],
    *(const ::HcalPFCorr*)arg[1]));
  else   (((::std::vector<HcalPFCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >*)arg[0],
    *(const ::HcalPFCorr*)arg[1]);
}

static  void method_6342( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPFCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalPFCorr*)arg[2]);
}

static  void method_6343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >)((((::std::vector<HcalPFCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >*)arg[0]));
  else   (((::std::vector<HcalPFCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >*)arg[0]);
}

static  void method_6344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >)((((::std::vector<HcalPFCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >*)arg[1]));
  else   (((::std::vector<HcalPFCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalPFCorr*,std::vector<HcalPFCorr> >*)arg[1]);
}

static  void method_6345( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPFCorr>*)o)->swap)(*(::std::vector<HcalPFCorr>*)arg[0]);
}

static  void method_6346( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalPFCorr>*)o)->clear)();
}

static void method_newdel_1863( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPFCorr> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPFCorr> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPFCorr> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPFCorr> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPFCorr> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x135( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalPFCorr,std::allocator<HcalPFCorr> >")), ::Reflex::BaseOffset< ::std::vector<HcalPFCorr>,::std::_Vector_base<HcalPFCorr,std::allocator<HcalPFCorr> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x136( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalPFCorr> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalPFCorr> >::Generate();
}

//------Dictionary for class vector<HcalPFCorr,std::allocator<HcalPFCorr> > -------------------------------
void __std__vector_HcalPFCorr__db_datamem(Reflex::Class*);
void __std__vector_HcalPFCorr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalPFCorr__datamem_bld(&__std__vector_HcalPFCorr__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalPFCorr__funcmem_bld(&__std__vector_HcalPFCorr__db_funcmem);
void __std__vector_HcalPFCorr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalPFCorr>"), typeid(::std::vector<HcalPFCorr>), sizeof(::std::vector<HcalPFCorr>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1804, ::Reflex::BaseOffset< ::std::vector<HcalPFCorr>, ::std::_Vector_base<HcalPFCorr,std::allocator<HcalPFCorr> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1530, Reflex::Literal("std::vector<HcalPFCorr>::_Alloc_value_type"))
  .AddTypedef(type_1804, Reflex::Literal("std::vector<HcalPFCorr>::_Base"))
  .AddTypedef(type_2151, Reflex::Literal("std::vector<HcalPFCorr>::_Tp_alloc_type"))
  .AddTypedef(type_3899, Reflex::Literal("std::vector<HcalPFCorr>::_Alloc_traits"))
  .AddTypedef(type_1530, Reflex::Literal("std::vector<HcalPFCorr>::value_type"))
  .AddTypedef(type_4957, Reflex::Literal("std::vector<HcalPFCorr>::pointer"))
  .AddTypedef(type_6294, Reflex::Literal("std::vector<HcalPFCorr>::const_pointer"))
  .AddTypedef(type_6296, Reflex::Literal("std::vector<HcalPFCorr>::reference"))
  .AddTypedef(type_6298, Reflex::Literal("std::vector<HcalPFCorr>::const_reference"))
  .AddTypedef(type_3819, Reflex::Literal("std::vector<HcalPFCorr>::iterator"))
  .AddTypedef(type_3820, Reflex::Literal("std::vector<HcalPFCorr>::const_iterator"))
  .AddTypedef(type_2294, Reflex::Literal("std::vector<HcalPFCorr>::const_reverse_iterator"))
  .AddTypedef(type_2295, Reflex::Literal("std::vector<HcalPFCorr>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalPFCorr>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalPFCorr>::difference_type"))
  .AddTypedef(type_2151, Reflex::Literal("std::vector<HcalPFCorr>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6307, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12577), Reflex::Literal("vector"), constructor_6308, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6298, type_12577), Reflex::Literal("vector"), constructor_6309, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12877), Reflex::Literal("vector"), constructor_6310, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6311, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1863, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x136, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalPFCorr__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalPFCorr,std::allocator<HcalPFCorr> > -------------------
void __std__vector_HcalPFCorr__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalPFCorr,std::allocator<HcalPFCorr> > -------------------
void __std__vector_HcalPFCorr__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12878, type_12877), Reflex::Literal("operator="), operator_6312, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6298), Reflex::Literal("assign"), method_6313, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3819), Reflex::Literal("begin"), method_6314, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3820), Reflex::Literal("begin"), method_6315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3819), Reflex::Literal("end"), method_6316, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3820), Reflex::Literal("end"), method_6317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6322, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6323, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1530), Reflex::Literal("resize"), method_6324, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6326, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6327, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6296, type_2122), Reflex::Literal("operator[]"), operator_6328, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6298, type_2122), Reflex::Literal("operator[]"), operator_6329, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6296, type_2122), Reflex::Literal("at"), method_6331, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6298, type_2122), Reflex::Literal("at"), method_6332, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6296), Reflex::Literal("front"), method_6333, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6298), Reflex::Literal("front"), method_6334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6296), Reflex::Literal("back"), method_6335, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6298), Reflex::Literal("back"), method_6336, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4957), Reflex::Literal("data"), method_6337, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6294), Reflex::Literal("data"), method_6338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6298), Reflex::Literal("push_back"), method_6339, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6340, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3819, type_3819, type_6298), Reflex::Literal("insert"), method_6341, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3819, type_2122, type_6298), Reflex::Literal("insert"), method_6342, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3819, type_3819), Reflex::Literal("erase"), method_6343, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3819, type_3819, type_3819), Reflex::Literal("erase"), method_6344, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12878), Reflex::Literal("swap"), method_6345, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6346, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalLUTCorr,std::allocator<HcalLUTCorr> > -------------------------------
static void constructor_6372( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLUTCorr>();
  else ::new(mem) ::std::vector<HcalLUTCorr>();
}

static void constructor_6373( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLUTCorr>(*(const ::std::allocator<HcalLUTCorr>*)arg[0]);
  else ::new(mem) ::std::vector<HcalLUTCorr>(*(const ::std::allocator<HcalLUTCorr>*)arg[0]);
}

static void constructor_6374( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLUTCorr>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalLUTCorr>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLUTCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalLUTCorr*)arg[1]);
  else ::new(mem) ::std::vector<HcalLUTCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalLUTCorr*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLUTCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalLUTCorr*)arg[1],
      *(const ::std::allocator<HcalLUTCorr>*)arg[2]);
  else ::new(mem) ::std::vector<HcalLUTCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalLUTCorr*)arg[1],
      *(const ::std::allocator<HcalLUTCorr>*)arg[2]);
  }
}

static void constructor_6375( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalLUTCorr>(*(const ::std::vector<HcalLUTCorr>*)arg[0]);
  else ::new(mem) ::std::vector<HcalLUTCorr>(*(const ::std::vector<HcalLUTCorr>*)arg[0]);
}

static void destructor_6376(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalLUTCorr>*)o)->::std::vector<HcalLUTCorr>::~vector)();
}
static  void operator_6377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLUTCorr>*)o)->operator=)(*(const ::std::vector<HcalLUTCorr>*)arg[0]);
  else   (((::std::vector<HcalLUTCorr>*)o)->operator=)(*(const ::std::vector<HcalLUTCorr>*)arg[0]);
}

static  void method_6378( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLUTCorr>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalLUTCorr*)arg[1]);
}

static  void method_6379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >)((((::std::vector<HcalLUTCorr>*)o)->begin)());
  else   (((::std::vector<HcalLUTCorr>*)o)->begin)();
}

static  void method_6380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalLUTCorr*,std::vector<HcalLUTCorr> >)((((const ::std::vector<HcalLUTCorr>*)o)->begin)());
  else   (((const ::std::vector<HcalLUTCorr>*)o)->begin)();
}

static  void method_6381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >)((((::std::vector<HcalLUTCorr>*)o)->end)());
  else   (((::std::vector<HcalLUTCorr>*)o)->end)();
}

static  void method_6382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalLUTCorr*,std::vector<HcalLUTCorr> >)((((const ::std::vector<HcalLUTCorr>*)o)->end)());
  else   (((const ::std::vector<HcalLUTCorr>*)o)->end)();
}

static  void method_6387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalLUTCorr>*)o)->size)());
  else   (((const ::std::vector<HcalLUTCorr>*)o)->size)();
}

static  void method_6388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalLUTCorr>*)o)->max_size)());
  else   (((const ::std::vector<HcalLUTCorr>*)o)->max_size)();
}

static  void method_6389( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalLUTCorr>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalLUTCorr>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalLUTCorr*)arg[1]);
  }
}

static  void method_6390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalLUTCorr>*)o)->capacity)());
  else   (((const ::std::vector<HcalLUTCorr>*)o)->capacity)();
}

static  void method_6391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalLUTCorr>*)o)->empty)());
  else   (((const ::std::vector<HcalLUTCorr>*)o)->empty)();
}

static  void method_6392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLUTCorr>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLUTCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalLUTCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLUTCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalLUTCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLUTCorr>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalLUTCorr>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6397( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLUTCorr>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalLUTCorr>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLUTCorr>*)o)->front)();
  else   (((::std::vector<HcalLUTCorr>*)o)->front)();
}

static  void method_6399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLUTCorr>*)o)->front)();
  else   (((const ::std::vector<HcalLUTCorr>*)o)->front)();
}

static  void method_6400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalLUTCorr>*)o)->back)();
  else   (((::std::vector<HcalLUTCorr>*)o)->back)();
}

static  void method_6401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalLUTCorr>*)o)->back)();
  else   (((const ::std::vector<HcalLUTCorr>*)o)->back)();
}

static  void method_6402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalLUTCorr>*)o)->data)());
  else   (((::std::vector<HcalLUTCorr>*)o)->data)();
}

static  void method_6403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalLUTCorr>*)o)->data)());
  else   (((const ::std::vector<HcalLUTCorr>*)o)->data)();
}

static  void method_6404( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLUTCorr>*)o)->push_back)(*(const ::HcalLUTCorr*)arg[0]);
}

static  void method_6405( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalLUTCorr>*)o)->pop_back)();
}

static  void method_6406( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >)((((::std::vector<HcalLUTCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >*)arg[0],
    *(const ::HcalLUTCorr*)arg[1]));
  else   (((::std::vector<HcalLUTCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >*)arg[0],
    *(const ::HcalLUTCorr*)arg[1]);
}

static  void method_6407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLUTCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalLUTCorr*)arg[2]);
}

static  void method_6408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >)((((::std::vector<HcalLUTCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >*)arg[0]));
  else   (((::std::vector<HcalLUTCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >*)arg[0]);
}

static  void method_6409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >)((((::std::vector<HcalLUTCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >*)arg[1]));
  else   (((::std::vector<HcalLUTCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalLUTCorr*,std::vector<HcalLUTCorr> >*)arg[1]);
}

static  void method_6410( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalLUTCorr>*)o)->swap)(*(::std::vector<HcalLUTCorr>*)arg[0]);
}

static  void method_6411( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalLUTCorr>*)o)->clear)();
}

static void method_newdel_1864( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLUTCorr> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLUTCorr> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLUTCorr> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLUTCorr> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalLUTCorr> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalLUTCorr,std::allocator<HcalLUTCorr> >")), ::Reflex::BaseOffset< ::std::vector<HcalLUTCorr>,::std::_Vector_base<HcalLUTCorr,std::allocator<HcalLUTCorr> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x139( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalLUTCorr> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalLUTCorr> >::Generate();
}

//------Dictionary for class vector<HcalLUTCorr,std::allocator<HcalLUTCorr> > -------------------------------
void __std__vector_HcalLUTCorr__db_datamem(Reflex::Class*);
void __std__vector_HcalLUTCorr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalLUTCorr__datamem_bld(&__std__vector_HcalLUTCorr__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalLUTCorr__funcmem_bld(&__std__vector_HcalLUTCorr__db_funcmem);
void __std__vector_HcalLUTCorr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalLUTCorr>"), typeid(::std::vector<HcalLUTCorr>), sizeof(::std::vector<HcalLUTCorr>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1805, ::Reflex::BaseOffset< ::std::vector<HcalLUTCorr>, ::std::_Vector_base<HcalLUTCorr,std::allocator<HcalLUTCorr> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1511, Reflex::Literal("std::vector<HcalLUTCorr>::_Alloc_value_type"))
  .AddTypedef(type_1805, Reflex::Literal("std::vector<HcalLUTCorr>::_Base"))
  .AddTypedef(type_2152, Reflex::Literal("std::vector<HcalLUTCorr>::_Tp_alloc_type"))
  .AddTypedef(type_3900, Reflex::Literal("std::vector<HcalLUTCorr>::_Alloc_traits"))
  .AddTypedef(type_1511, Reflex::Literal("std::vector<HcalLUTCorr>::value_type"))
  .AddTypedef(type_4976, Reflex::Literal("std::vector<HcalLUTCorr>::pointer"))
  .AddTypedef(type_6359, Reflex::Literal("std::vector<HcalLUTCorr>::const_pointer"))
  .AddTypedef(type_6361, Reflex::Literal("std::vector<HcalLUTCorr>::reference"))
  .AddTypedef(type_6363, Reflex::Literal("std::vector<HcalLUTCorr>::const_reference"))
  .AddTypedef(type_3821, Reflex::Literal("std::vector<HcalLUTCorr>::iterator"))
  .AddTypedef(type_3822, Reflex::Literal("std::vector<HcalLUTCorr>::const_iterator"))
  .AddTypedef(type_2296, Reflex::Literal("std::vector<HcalLUTCorr>::const_reverse_iterator"))
  .AddTypedef(type_2297, Reflex::Literal("std::vector<HcalLUTCorr>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalLUTCorr>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalLUTCorr>::difference_type"))
  .AddTypedef(type_2152, Reflex::Literal("std::vector<HcalLUTCorr>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6372, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12590), Reflex::Literal("vector"), constructor_6373, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6363, type_12590), Reflex::Literal("vector"), constructor_6374, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12880), Reflex::Literal("vector"), constructor_6375, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6376, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1864, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x139, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalLUTCorr__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalLUTCorr,std::allocator<HcalLUTCorr> > -------------------
void __std__vector_HcalLUTCorr__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalLUTCorr,std::allocator<HcalLUTCorr> > -------------------
void __std__vector_HcalLUTCorr__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12881, type_12880), Reflex::Literal("operator="), operator_6377, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6363), Reflex::Literal("assign"), method_6378, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3821), Reflex::Literal("begin"), method_6379, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3822), Reflex::Literal("begin"), method_6380, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3821), Reflex::Literal("end"), method_6381, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3822), Reflex::Literal("end"), method_6382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1511), Reflex::Literal("resize"), method_6389, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6390, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6392, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6361, type_2122), Reflex::Literal("operator[]"), operator_6393, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6363, type_2122), Reflex::Literal("operator[]"), operator_6394, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6361, type_2122), Reflex::Literal("at"), method_6396, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6363, type_2122), Reflex::Literal("at"), method_6397, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6361), Reflex::Literal("front"), method_6398, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6363), Reflex::Literal("front"), method_6399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6361), Reflex::Literal("back"), method_6400, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6363), Reflex::Literal("back"), method_6401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4976), Reflex::Literal("data"), method_6402, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6359), Reflex::Literal("data"), method_6403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6363), Reflex::Literal("push_back"), method_6404, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6405, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3821, type_3821, type_6363), Reflex::Literal("insert"), method_6406, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3821, type_2122, type_6363), Reflex::Literal("insert"), method_6407, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3821, type_3821), Reflex::Literal("erase"), method_6408, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3821, type_3821, type_3821), Reflex::Literal("erase"), method_6409, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12881), Reflex::Literal("swap"), method_6410, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6411, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalRespCorr,std::allocator<HcalRespCorr> > -------------------------------
static void constructor_6437( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRespCorr>();
  else ::new(mem) ::std::vector<HcalRespCorr>();
}

static void constructor_6438( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRespCorr>(*(const ::std::allocator<HcalRespCorr>*)arg[0]);
  else ::new(mem) ::std::vector<HcalRespCorr>(*(const ::std::allocator<HcalRespCorr>*)arg[0]);
}

static void constructor_6439( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRespCorr>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalRespCorr>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRespCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalRespCorr*)arg[1]);
  else ::new(mem) ::std::vector<HcalRespCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalRespCorr*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRespCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalRespCorr*)arg[1],
      *(const ::std::allocator<HcalRespCorr>*)arg[2]);
  else ::new(mem) ::std::vector<HcalRespCorr>(*(::std::size_t*)arg[0],
      *(const ::HcalRespCorr*)arg[1],
      *(const ::std::allocator<HcalRespCorr>*)arg[2]);
  }
}

static void constructor_6440( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalRespCorr>(*(const ::std::vector<HcalRespCorr>*)arg[0]);
  else ::new(mem) ::std::vector<HcalRespCorr>(*(const ::std::vector<HcalRespCorr>*)arg[0]);
}

static void destructor_6441(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalRespCorr>*)o)->::std::vector<HcalRespCorr>::~vector)();
}
static  void operator_6442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalRespCorr>*)o)->operator=)(*(const ::std::vector<HcalRespCorr>*)arg[0]);
  else   (((::std::vector<HcalRespCorr>*)o)->operator=)(*(const ::std::vector<HcalRespCorr>*)arg[0]);
}

static  void method_6443( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalRespCorr>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalRespCorr*)arg[1]);
}

static  void method_6444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >)((((::std::vector<HcalRespCorr>*)o)->begin)());
  else   (((::std::vector<HcalRespCorr>*)o)->begin)();
}

static  void method_6445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalRespCorr*,std::vector<HcalRespCorr> >)((((const ::std::vector<HcalRespCorr>*)o)->begin)());
  else   (((const ::std::vector<HcalRespCorr>*)o)->begin)();
}

static  void method_6446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >)((((::std::vector<HcalRespCorr>*)o)->end)());
  else   (((::std::vector<HcalRespCorr>*)o)->end)();
}

static  void method_6447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalRespCorr*,std::vector<HcalRespCorr> >)((((const ::std::vector<HcalRespCorr>*)o)->end)());
  else   (((const ::std::vector<HcalRespCorr>*)o)->end)();
}

static  void method_6452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalRespCorr>*)o)->size)());
  else   (((const ::std::vector<HcalRespCorr>*)o)->size)();
}

static  void method_6453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalRespCorr>*)o)->max_size)());
  else   (((const ::std::vector<HcalRespCorr>*)o)->max_size)();
}

static  void method_6454( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalRespCorr>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalRespCorr>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalRespCorr*)arg[1]);
  }
}

static  void method_6455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalRespCorr>*)o)->capacity)());
  else   (((const ::std::vector<HcalRespCorr>*)o)->capacity)();
}

static  void method_6456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalRespCorr>*)o)->empty)());
  else   (((const ::std::vector<HcalRespCorr>*)o)->empty)();
}

static  void method_6457( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalRespCorr>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6458( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalRespCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalRespCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalRespCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalRespCorr>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6461( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalRespCorr>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalRespCorr>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalRespCorr>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalRespCorr>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalRespCorr>*)o)->front)();
  else   (((::std::vector<HcalRespCorr>*)o)->front)();
}

static  void method_6464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalRespCorr>*)o)->front)();
  else   (((const ::std::vector<HcalRespCorr>*)o)->front)();
}

static  void method_6465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalRespCorr>*)o)->back)();
  else   (((::std::vector<HcalRespCorr>*)o)->back)();
}

static  void method_6466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalRespCorr>*)o)->back)();
  else   (((const ::std::vector<HcalRespCorr>*)o)->back)();
}

static  void method_6467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalRespCorr>*)o)->data)());
  else   (((::std::vector<HcalRespCorr>*)o)->data)();
}

static  void method_6468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalRespCorr>*)o)->data)());
  else   (((const ::std::vector<HcalRespCorr>*)o)->data)();
}

static  void method_6469( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalRespCorr>*)o)->push_back)(*(const ::HcalRespCorr*)arg[0]);
}

static  void method_6470( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalRespCorr>*)o)->pop_back)();
}

static  void method_6471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >)((((::std::vector<HcalRespCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >*)arg[0],
    *(const ::HcalRespCorr*)arg[1]));
  else   (((::std::vector<HcalRespCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >*)arg[0],
    *(const ::HcalRespCorr*)arg[1]);
}

static  void method_6472( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalRespCorr>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalRespCorr*)arg[2]);
}

static  void method_6473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >)((((::std::vector<HcalRespCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >*)arg[0]));
  else   (((::std::vector<HcalRespCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >*)arg[0]);
}

static  void method_6474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >)((((::std::vector<HcalRespCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >*)arg[1]));
  else   (((::std::vector<HcalRespCorr>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalRespCorr*,std::vector<HcalRespCorr> >*)arg[1]);
}

static  void method_6475( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalRespCorr>*)o)->swap)(*(::std::vector<HcalRespCorr>*)arg[0]);
}

static  void method_6476( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalRespCorr>*)o)->clear)();
}

static void method_newdel_1865( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalRespCorr> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalRespCorr> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalRespCorr> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalRespCorr> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalRespCorr> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalRespCorr,std::allocator<HcalRespCorr> >")), ::Reflex::BaseOffset< ::std::vector<HcalRespCorr>,::std::_Vector_base<HcalRespCorr,std::allocator<HcalRespCorr> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x142( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalRespCorr> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalRespCorr> >::Generate();
}

//------Dictionary for class vector<HcalRespCorr,std::allocator<HcalRespCorr> > -------------------------------
void __std__vector_HcalRespCorr__db_datamem(Reflex::Class*);
void __std__vector_HcalRespCorr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalRespCorr__datamem_bld(&__std__vector_HcalRespCorr__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalRespCorr__funcmem_bld(&__std__vector_HcalRespCorr__db_funcmem);
void __std__vector_HcalRespCorr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalRespCorr>"), typeid(::std::vector<HcalRespCorr>), sizeof(::std::vector<HcalRespCorr>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1808, ::Reflex::BaseOffset< ::std::vector<HcalRespCorr>, ::std::_Vector_base<HcalRespCorr,std::allocator<HcalRespCorr> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_231, Reflex::Literal("std::vector<HcalRespCorr>::_Alloc_value_type"))
  .AddTypedef(type_1808, Reflex::Literal("std::vector<HcalRespCorr>::_Base"))
  .AddTypedef(type_2153, Reflex::Literal("std::vector<HcalRespCorr>::_Tp_alloc_type"))
  .AddTypedef(type_3903, Reflex::Literal("std::vector<HcalRespCorr>::_Alloc_traits"))
  .AddTypedef(type_231, Reflex::Literal("std::vector<HcalRespCorr>::value_type"))
  .AddTypedef(type_5033, Reflex::Literal("std::vector<HcalRespCorr>::pointer"))
  .AddTypedef(type_6424, Reflex::Literal("std::vector<HcalRespCorr>::const_pointer"))
  .AddTypedef(type_6426, Reflex::Literal("std::vector<HcalRespCorr>::reference"))
  .AddTypedef(type_6428, Reflex::Literal("std::vector<HcalRespCorr>::const_reference"))
  .AddTypedef(type_3827, Reflex::Literal("std::vector<HcalRespCorr>::iterator"))
  .AddTypedef(type_3828, Reflex::Literal("std::vector<HcalRespCorr>::const_iterator"))
  .AddTypedef(type_2302, Reflex::Literal("std::vector<HcalRespCorr>::const_reverse_iterator"))
  .AddTypedef(type_2303, Reflex::Literal("std::vector<HcalRespCorr>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalRespCorr>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalRespCorr>::difference_type"))
  .AddTypedef(type_2153, Reflex::Literal("std::vector<HcalRespCorr>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6437, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12629), Reflex::Literal("vector"), constructor_6438, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6428, type_12629), Reflex::Literal("vector"), constructor_6439, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12883), Reflex::Literal("vector"), constructor_6440, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6441, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1865, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x142, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalRespCorr__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalRespCorr,std::allocator<HcalRespCorr> > -------------------
void __std__vector_HcalRespCorr__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalRespCorr,std::allocator<HcalRespCorr> > -------------------
void __std__vector_HcalRespCorr__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12884, type_12883), Reflex::Literal("operator="), operator_6442, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6428), Reflex::Literal("assign"), method_6443, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3827), Reflex::Literal("begin"), method_6444, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3828), Reflex::Literal("begin"), method_6445, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3827), Reflex::Literal("end"), method_6446, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3828), Reflex::Literal("end"), method_6447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6452, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_231), Reflex::Literal("resize"), method_6454, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6457, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6426, type_2122), Reflex::Literal("operator[]"), operator_6458, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6428, type_2122), Reflex::Literal("operator[]"), operator_6459, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6426, type_2122), Reflex::Literal("at"), method_6461, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6428, type_2122), Reflex::Literal("at"), method_6462, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6426), Reflex::Literal("front"), method_6463, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6428), Reflex::Literal("front"), method_6464, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6426), Reflex::Literal("back"), method_6465, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6428), Reflex::Literal("back"), method_6466, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5033), Reflex::Literal("data"), method_6467, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6424), Reflex::Literal("data"), method_6468, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6428), Reflex::Literal("push_back"), method_6469, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6470, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3827, type_3827, type_6428), Reflex::Literal("insert"), method_6471, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3827, type_2122, type_6428), Reflex::Literal("insert"), method_6472, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3827, type_3827), Reflex::Literal("erase"), method_6473, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3827, type_3827, type_3827), Reflex::Literal("erase"), method_6474, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12884), Reflex::Literal("swap"), method_6475, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6476, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalZSThreshold,std::allocator<HcalZSThreshold> > -------------------------------
static void constructor_6502( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalZSThreshold>();
  else ::new(mem) ::std::vector<HcalZSThreshold>();
}

static void constructor_6503( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalZSThreshold>(*(const ::std::allocator<HcalZSThreshold>*)arg[0]);
  else ::new(mem) ::std::vector<HcalZSThreshold>(*(const ::std::allocator<HcalZSThreshold>*)arg[0]);
}

static void constructor_6504( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalZSThreshold>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalZSThreshold>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalZSThreshold>(*(::std::size_t*)arg[0],
      *(const ::HcalZSThreshold*)arg[1]);
  else ::new(mem) ::std::vector<HcalZSThreshold>(*(::std::size_t*)arg[0],
      *(const ::HcalZSThreshold*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalZSThreshold>(*(::std::size_t*)arg[0],
      *(const ::HcalZSThreshold*)arg[1],
      *(const ::std::allocator<HcalZSThreshold>*)arg[2]);
  else ::new(mem) ::std::vector<HcalZSThreshold>(*(::std::size_t*)arg[0],
      *(const ::HcalZSThreshold*)arg[1],
      *(const ::std::allocator<HcalZSThreshold>*)arg[2]);
  }
}

static void constructor_6505( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalZSThreshold>(*(const ::std::vector<HcalZSThreshold>*)arg[0]);
  else ::new(mem) ::std::vector<HcalZSThreshold>(*(const ::std::vector<HcalZSThreshold>*)arg[0]);
}

static void destructor_6506(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalZSThreshold>*)o)->::std::vector<HcalZSThreshold>::~vector)();
}
static  void operator_6507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalZSThreshold>*)o)->operator=)(*(const ::std::vector<HcalZSThreshold>*)arg[0]);
  else   (((::std::vector<HcalZSThreshold>*)o)->operator=)(*(const ::std::vector<HcalZSThreshold>*)arg[0]);
}

static  void method_6508( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalZSThreshold>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalZSThreshold*)arg[1]);
}

static  void method_6509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >)((((::std::vector<HcalZSThreshold>*)o)->begin)());
  else   (((::std::vector<HcalZSThreshold>*)o)->begin)();
}

static  void method_6510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalZSThreshold*,std::vector<HcalZSThreshold> >)((((const ::std::vector<HcalZSThreshold>*)o)->begin)());
  else   (((const ::std::vector<HcalZSThreshold>*)o)->begin)();
}

static  void method_6511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >)((((::std::vector<HcalZSThreshold>*)o)->end)());
  else   (((::std::vector<HcalZSThreshold>*)o)->end)();
}

static  void method_6512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalZSThreshold*,std::vector<HcalZSThreshold> >)((((const ::std::vector<HcalZSThreshold>*)o)->end)());
  else   (((const ::std::vector<HcalZSThreshold>*)o)->end)();
}

static  void method_6517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalZSThreshold>*)o)->size)());
  else   (((const ::std::vector<HcalZSThreshold>*)o)->size)();
}

static  void method_6518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalZSThreshold>*)o)->max_size)());
  else   (((const ::std::vector<HcalZSThreshold>*)o)->max_size)();
}

static  void method_6519( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalZSThreshold>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalZSThreshold>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalZSThreshold*)arg[1]);
  }
}

static  void method_6520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalZSThreshold>*)o)->capacity)());
  else   (((const ::std::vector<HcalZSThreshold>*)o)->capacity)();
}

static  void method_6521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalZSThreshold>*)o)->empty)());
  else   (((const ::std::vector<HcalZSThreshold>*)o)->empty)();
}

static  void method_6522( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalZSThreshold>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalZSThreshold>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalZSThreshold>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalZSThreshold>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalZSThreshold>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6526( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalZSThreshold>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalZSThreshold>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalZSThreshold>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalZSThreshold>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalZSThreshold>*)o)->front)();
  else   (((::std::vector<HcalZSThreshold>*)o)->front)();
}

static  void method_6529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalZSThreshold>*)o)->front)();
  else   (((const ::std::vector<HcalZSThreshold>*)o)->front)();
}

static  void method_6530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalZSThreshold>*)o)->back)();
  else   (((::std::vector<HcalZSThreshold>*)o)->back)();
}

static  void method_6531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalZSThreshold>*)o)->back)();
  else   (((const ::std::vector<HcalZSThreshold>*)o)->back)();
}

static  void method_6532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalZSThreshold>*)o)->data)());
  else   (((::std::vector<HcalZSThreshold>*)o)->data)();
}

static  void method_6533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalZSThreshold>*)o)->data)());
  else   (((const ::std::vector<HcalZSThreshold>*)o)->data)();
}

static  void method_6534( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalZSThreshold>*)o)->push_back)(*(const ::HcalZSThreshold*)arg[0]);
}

static  void method_6535( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalZSThreshold>*)o)->pop_back)();
}

static  void method_6536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >)((((::std::vector<HcalZSThreshold>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >*)arg[0],
    *(const ::HcalZSThreshold*)arg[1]));
  else   (((::std::vector<HcalZSThreshold>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >*)arg[0],
    *(const ::HcalZSThreshold*)arg[1]);
}

static  void method_6537( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalZSThreshold>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalZSThreshold*)arg[2]);
}

static  void method_6538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >)((((::std::vector<HcalZSThreshold>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >*)arg[0]));
  else   (((::std::vector<HcalZSThreshold>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >*)arg[0]);
}

static  void method_6539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >)((((::std::vector<HcalZSThreshold>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >*)arg[1]));
  else   (((::std::vector<HcalZSThreshold>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalZSThreshold*,std::vector<HcalZSThreshold> >*)arg[1]);
}

static  void method_6540( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalZSThreshold>*)o)->swap)(*(::std::vector<HcalZSThreshold>*)arg[0]);
}

static  void method_6541( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalZSThreshold>*)o)->clear)();
}

static void method_newdel_1866( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalZSThreshold> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalZSThreshold> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalZSThreshold> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalZSThreshold> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalZSThreshold> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x144( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalZSThreshold,std::allocator<HcalZSThreshold> >")), ::Reflex::BaseOffset< ::std::vector<HcalZSThreshold>,::std::_Vector_base<HcalZSThreshold,std::allocator<HcalZSThreshold> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x145( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalZSThreshold> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalZSThreshold> >::Generate();
}

//------Dictionary for class vector<HcalZSThreshold,std::allocator<HcalZSThreshold> > -------------------------------
void __std__vector_HcalZSThreshold__db_datamem(Reflex::Class*);
void __std__vector_HcalZSThreshold__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalZSThreshold__datamem_bld(&__std__vector_HcalZSThreshold__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalZSThreshold__funcmem_bld(&__std__vector_HcalZSThreshold__db_funcmem);
void __std__vector_HcalZSThreshold__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalZSThreshold>"), typeid(::std::vector<HcalZSThreshold>), sizeof(::std::vector<HcalZSThreshold>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1809, ::Reflex::BaseOffset< ::std::vector<HcalZSThreshold>, ::std::_Vector_base<HcalZSThreshold,std::allocator<HcalZSThreshold> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_530, Reflex::Literal("std::vector<HcalZSThreshold>::_Alloc_value_type"))
  .AddTypedef(type_1809, Reflex::Literal("std::vector<HcalZSThreshold>::_Base"))
  .AddTypedef(type_2154, Reflex::Literal("std::vector<HcalZSThreshold>::_Tp_alloc_type"))
  .AddTypedef(type_3904, Reflex::Literal("std::vector<HcalZSThreshold>::_Alloc_traits"))
  .AddTypedef(type_530, Reflex::Literal("std::vector<HcalZSThreshold>::value_type"))
  .AddTypedef(type_5052, Reflex::Literal("std::vector<HcalZSThreshold>::pointer"))
  .AddTypedef(type_6489, Reflex::Literal("std::vector<HcalZSThreshold>::const_pointer"))
  .AddTypedef(type_6491, Reflex::Literal("std::vector<HcalZSThreshold>::reference"))
  .AddTypedef(type_6493, Reflex::Literal("std::vector<HcalZSThreshold>::const_reference"))
  .AddTypedef(type_3829, Reflex::Literal("std::vector<HcalZSThreshold>::iterator"))
  .AddTypedef(type_3830, Reflex::Literal("std::vector<HcalZSThreshold>::const_iterator"))
  .AddTypedef(type_2304, Reflex::Literal("std::vector<HcalZSThreshold>::const_reverse_iterator"))
  .AddTypedef(type_2305, Reflex::Literal("std::vector<HcalZSThreshold>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalZSThreshold>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalZSThreshold>::difference_type"))
  .AddTypedef(type_2154, Reflex::Literal("std::vector<HcalZSThreshold>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6502, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12642), Reflex::Literal("vector"), constructor_6503, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6493, type_12642), Reflex::Literal("vector"), constructor_6504, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12886), Reflex::Literal("vector"), constructor_6505, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6506, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1866, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x144, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x145, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalZSThreshold__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalZSThreshold,std::allocator<HcalZSThreshold> > -------------------
void __std__vector_HcalZSThreshold__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalZSThreshold,std::allocator<HcalZSThreshold> > -------------------
void __std__vector_HcalZSThreshold__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12887, type_12886), Reflex::Literal("operator="), operator_6507, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6493), Reflex::Literal("assign"), method_6508, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3829), Reflex::Literal("begin"), method_6509, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3830), Reflex::Literal("begin"), method_6510, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3829), Reflex::Literal("end"), method_6511, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3830), Reflex::Literal("end"), method_6512, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6517, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_530), Reflex::Literal("resize"), method_6519, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6522, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6491, type_2122), Reflex::Literal("operator[]"), operator_6523, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6493, type_2122), Reflex::Literal("operator[]"), operator_6524, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6491, type_2122), Reflex::Literal("at"), method_6526, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6493, type_2122), Reflex::Literal("at"), method_6527, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6491), Reflex::Literal("front"), method_6528, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6493), Reflex::Literal("front"), method_6529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6491), Reflex::Literal("back"), method_6530, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6493), Reflex::Literal("back"), method_6531, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5052), Reflex::Literal("data"), method_6532, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6489), Reflex::Literal("data"), method_6533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6493), Reflex::Literal("push_back"), method_6534, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6535, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3829, type_3829, type_6493), Reflex::Literal("insert"), method_6536, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3829, type_2122, type_6493), Reflex::Literal("insert"), method_6537, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3829, type_3829), Reflex::Literal("erase"), method_6538, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3829, type_3829, type_3829), Reflex::Literal("erase"), method_6539, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12887), Reflex::Literal("swap"), method_6540, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6541, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalChannelStatus,std::allocator<HcalChannelStatus> > -------------------------------
static void constructor_6567( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalChannelStatus>();
  else ::new(mem) ::std::vector<HcalChannelStatus>();
}

static void constructor_6568( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalChannelStatus>(*(const ::std::allocator<HcalChannelStatus>*)arg[0]);
  else ::new(mem) ::std::vector<HcalChannelStatus>(*(const ::std::allocator<HcalChannelStatus>*)arg[0]);
}

static void constructor_6569( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalChannelStatus>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalChannelStatus>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalChannelStatus>(*(::std::size_t*)arg[0],
      *(const ::HcalChannelStatus*)arg[1]);
  else ::new(mem) ::std::vector<HcalChannelStatus>(*(::std::size_t*)arg[0],
      *(const ::HcalChannelStatus*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalChannelStatus>(*(::std::size_t*)arg[0],
      *(const ::HcalChannelStatus*)arg[1],
      *(const ::std::allocator<HcalChannelStatus>*)arg[2]);
  else ::new(mem) ::std::vector<HcalChannelStatus>(*(::std::size_t*)arg[0],
      *(const ::HcalChannelStatus*)arg[1],
      *(const ::std::allocator<HcalChannelStatus>*)arg[2]);
  }
}

static void constructor_6570( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalChannelStatus>(*(const ::std::vector<HcalChannelStatus>*)arg[0]);
  else ::new(mem) ::std::vector<HcalChannelStatus>(*(const ::std::vector<HcalChannelStatus>*)arg[0]);
}

static void destructor_6571(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalChannelStatus>*)o)->::std::vector<HcalChannelStatus>::~vector)();
}
static  void operator_6572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalChannelStatus>*)o)->operator=)(*(const ::std::vector<HcalChannelStatus>*)arg[0]);
  else   (((::std::vector<HcalChannelStatus>*)o)->operator=)(*(const ::std::vector<HcalChannelStatus>*)arg[0]);
}

static  void method_6573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalChannelStatus>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalChannelStatus*)arg[1]);
}

static  void method_6574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >)((((::std::vector<HcalChannelStatus>*)o)->begin)());
  else   (((::std::vector<HcalChannelStatus>*)o)->begin)();
}

static  void method_6575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalChannelStatus*,std::vector<HcalChannelStatus> >)((((const ::std::vector<HcalChannelStatus>*)o)->begin)());
  else   (((const ::std::vector<HcalChannelStatus>*)o)->begin)();
}

static  void method_6576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >)((((::std::vector<HcalChannelStatus>*)o)->end)());
  else   (((::std::vector<HcalChannelStatus>*)o)->end)();
}

static  void method_6577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalChannelStatus*,std::vector<HcalChannelStatus> >)((((const ::std::vector<HcalChannelStatus>*)o)->end)());
  else   (((const ::std::vector<HcalChannelStatus>*)o)->end)();
}

static  void method_6582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalChannelStatus>*)o)->size)());
  else   (((const ::std::vector<HcalChannelStatus>*)o)->size)();
}

static  void method_6583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalChannelStatus>*)o)->max_size)());
  else   (((const ::std::vector<HcalChannelStatus>*)o)->max_size)();
}

static  void method_6584( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalChannelStatus>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalChannelStatus>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalChannelStatus*)arg[1]);
  }
}

static  void method_6585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalChannelStatus>*)o)->capacity)());
  else   (((const ::std::vector<HcalChannelStatus>*)o)->capacity)();
}

static  void method_6586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalChannelStatus>*)o)->empty)());
  else   (((const ::std::vector<HcalChannelStatus>*)o)->empty)();
}

static  void method_6587( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalChannelStatus>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalChannelStatus>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalChannelStatus>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalChannelStatus>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalChannelStatus>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalChannelStatus>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalChannelStatus>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6592( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalChannelStatus>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalChannelStatus>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalChannelStatus>*)o)->front)();
  else   (((::std::vector<HcalChannelStatus>*)o)->front)();
}

static  void method_6594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalChannelStatus>*)o)->front)();
  else   (((const ::std::vector<HcalChannelStatus>*)o)->front)();
}

static  void method_6595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalChannelStatus>*)o)->back)();
  else   (((::std::vector<HcalChannelStatus>*)o)->back)();
}

static  void method_6596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalChannelStatus>*)o)->back)();
  else   (((const ::std::vector<HcalChannelStatus>*)o)->back)();
}

static  void method_6597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalChannelStatus>*)o)->data)());
  else   (((::std::vector<HcalChannelStatus>*)o)->data)();
}

static  void method_6598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalChannelStatus>*)o)->data)());
  else   (((const ::std::vector<HcalChannelStatus>*)o)->data)();
}

static  void method_6599( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalChannelStatus>*)o)->push_back)(*(const ::HcalChannelStatus*)arg[0]);
}

static  void method_6600( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalChannelStatus>*)o)->pop_back)();
}

static  void method_6601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >)((((::std::vector<HcalChannelStatus>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >*)arg[0],
    *(const ::HcalChannelStatus*)arg[1]));
  else   (((::std::vector<HcalChannelStatus>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >*)arg[0],
    *(const ::HcalChannelStatus*)arg[1]);
}

static  void method_6602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalChannelStatus>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalChannelStatus*)arg[2]);
}

static  void method_6603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >)((((::std::vector<HcalChannelStatus>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >*)arg[0]));
  else   (((::std::vector<HcalChannelStatus>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >*)arg[0]);
}

static  void method_6604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >)((((::std::vector<HcalChannelStatus>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >*)arg[1]));
  else   (((::std::vector<HcalChannelStatus>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalChannelStatus*,std::vector<HcalChannelStatus> >*)arg[1]);
}

static  void method_6605( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalChannelStatus>*)o)->swap)(*(::std::vector<HcalChannelStatus>*)arg[0]);
}

static  void method_6606( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalChannelStatus>*)o)->clear)();
}

static void method_newdel_1867( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalChannelStatus> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalChannelStatus> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalChannelStatus> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalChannelStatus> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalChannelStatus> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x147( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalChannelStatus,std::allocator<HcalChannelStatus> >")), ::Reflex::BaseOffset< ::std::vector<HcalChannelStatus>,::std::_Vector_base<HcalChannelStatus,std::allocator<HcalChannelStatus> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x148( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalChannelStatus> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalChannelStatus> >::Generate();
}

//------Dictionary for class vector<HcalChannelStatus,std::allocator<HcalChannelStatus> > -------------------------------
void __std__vector_HcalChannelStatus__db_datamem(Reflex::Class*);
void __std__vector_HcalChannelStatus__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalChannelStatus__datamem_bld(&__std__vector_HcalChannelStatus__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalChannelStatus__funcmem_bld(&__std__vector_HcalChannelStatus__db_funcmem);
void __std__vector_HcalChannelStatus__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalChannelStatus>"), typeid(::std::vector<HcalChannelStatus>), sizeof(::std::vector<HcalChannelStatus>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1814, ::Reflex::BaseOffset< ::std::vector<HcalChannelStatus>, ::std::_Vector_base<HcalChannelStatus,std::allocator<HcalChannelStatus> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1391, Reflex::Literal("std::vector<HcalChannelStatus>::_Alloc_value_type"))
  .AddTypedef(type_1814, Reflex::Literal("std::vector<HcalChannelStatus>::_Base"))
  .AddTypedef(type_2155, Reflex::Literal("std::vector<HcalChannelStatus>::_Tp_alloc_type"))
  .AddTypedef(type_3909, Reflex::Literal("std::vector<HcalChannelStatus>::_Alloc_traits"))
  .AddTypedef(type_1391, Reflex::Literal("std::vector<HcalChannelStatus>::value_type"))
  .AddTypedef(type_5147, Reflex::Literal("std::vector<HcalChannelStatus>::pointer"))
  .AddTypedef(type_6554, Reflex::Literal("std::vector<HcalChannelStatus>::const_pointer"))
  .AddTypedef(type_6556, Reflex::Literal("std::vector<HcalChannelStatus>::reference"))
  .AddTypedef(type_6558, Reflex::Literal("std::vector<HcalChannelStatus>::const_reference"))
  .AddTypedef(type_3839, Reflex::Literal("std::vector<HcalChannelStatus>::iterator"))
  .AddTypedef(type_3840, Reflex::Literal("std::vector<HcalChannelStatus>::const_iterator"))
  .AddTypedef(type_2314, Reflex::Literal("std::vector<HcalChannelStatus>::const_reverse_iterator"))
  .AddTypedef(type_2315, Reflex::Literal("std::vector<HcalChannelStatus>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalChannelStatus>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalChannelStatus>::difference_type"))
  .AddTypedef(type_2155, Reflex::Literal("std::vector<HcalChannelStatus>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6567, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12707), Reflex::Literal("vector"), constructor_6568, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6558, type_12707), Reflex::Literal("vector"), constructor_6569, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12889), Reflex::Literal("vector"), constructor_6570, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6571, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1867, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x148, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalChannelStatus__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalChannelStatus,std::allocator<HcalChannelStatus> > -------------------
void __std__vector_HcalChannelStatus__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalChannelStatus,std::allocator<HcalChannelStatus> > -------------------
void __std__vector_HcalChannelStatus__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12890, type_12889), Reflex::Literal("operator="), operator_6572, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6558), Reflex::Literal("assign"), method_6573, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3839), Reflex::Literal("begin"), method_6574, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3840), Reflex::Literal("begin"), method_6575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3839), Reflex::Literal("end"), method_6576, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3840), Reflex::Literal("end"), method_6577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6582, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1391), Reflex::Literal("resize"), method_6584, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6587, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6556, type_2122), Reflex::Literal("operator[]"), operator_6588, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6558, type_2122), Reflex::Literal("operator[]"), operator_6589, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6556, type_2122), Reflex::Literal("at"), method_6591, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6558, type_2122), Reflex::Literal("at"), method_6592, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6556), Reflex::Literal("front"), method_6593, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6558), Reflex::Literal("front"), method_6594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6556), Reflex::Literal("back"), method_6595, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6558), Reflex::Literal("back"), method_6596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5147), Reflex::Literal("data"), method_6597, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6554), Reflex::Literal("data"), method_6598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6558), Reflex::Literal("push_back"), method_6599, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6600, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3839, type_3839, type_6558), Reflex::Literal("insert"), method_6601, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3839, type_2122, type_6558), Reflex::Literal("insert"), method_6602, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3839, type_3839), Reflex::Literal("erase"), method_6603, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3839, type_3839, type_3839), Reflex::Literal("erase"), method_6604, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12890), Reflex::Literal("swap"), method_6605, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6606, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TriggerItem -------------------------------
static void destructor_9887(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalElectronicsMap::TriggerItem*)o)->::HcalElectronicsMap::TriggerItem::~TriggerItem)();
}
static  void operator_9888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalElectronicsMap::TriggerItem*)o)->operator=)(*(const ::HcalElectronicsMap::TriggerItem*)arg[0]);
  else   (((::HcalElectronicsMap::TriggerItem*)o)->operator=)(*(const ::HcalElectronicsMap::TriggerItem*)arg[0]);
}

static void constructor_9889( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsMap::TriggerItem(*(const ::HcalElectronicsMap::TriggerItem*)arg[0]);
  else ::new(mem) ::HcalElectronicsMap::TriggerItem(*(const ::HcalElectronicsMap::TriggerItem*)arg[0]);
}

static void constructor_9890( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsMap::TriggerItem();
  else ::new(mem) ::HcalElectronicsMap::TriggerItem();
}

static void constructor_9891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsMap::TriggerItem(*(::uint32_t*)arg[0],
      *(::uint32_t*)arg[1]);
  else ::new(mem) ::HcalElectronicsMap::TriggerItem(*(::uint32_t*)arg[0],
      *(::uint32_t*)arg[1]);
}

static void method_newdel_2577( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap::TriggerItem >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap::TriggerItem >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap::TriggerItem >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap::TriggerItem >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap::TriggerItem >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerItem -------------------------------
void __HcalElectronicsMap__TriggerItem_db_datamem(Reflex::Class*);
void __HcalElectronicsMap__TriggerItem_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalElectronicsMap__TriggerItem_datamem_bld(&__HcalElectronicsMap__TriggerItem_db_datamem);
Reflex::GenreflexMemberBuilder __HcalElectronicsMap__TriggerItem_funcmem_bld(&__HcalElectronicsMap__TriggerItem_db_funcmem);
void __HcalElectronicsMap__TriggerItem_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalElectronicsMap::TriggerItem"), typeid(::HcalElectronicsMap::TriggerItem), sizeof(::HcalElectronicsMap::TriggerItem), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerItem"), destructor_9887, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6621, type_6623), Reflex::Literal("operator="), operator_9888, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6623), Reflex::Literal("TriggerItem"), constructor_9889, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerItem"), constructor_9890, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_370, type_370), Reflex::Literal("TriggerItem"), constructor_9891, 0, "fTrigId;fElId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2577, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalElectronicsMap__TriggerItem_datamem_bld);
}

//------Delayed data member builder for class TriggerItem -------------------
void __HcalElectronicsMap__TriggerItem_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mTrigId"), OffsetOf(__shadow__::__HcalElectronicsMap__TriggerItem, mTrigId), ::Reflex::PUBLIC)
  .AddDataMember(type_370, Reflex::Literal("mElId"), OffsetOf(__shadow__::__HcalElectronicsMap__TriggerItem, mElId), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TriggerItem -------------------
void __HcalElectronicsMap__TriggerItem_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<HcalElectronicsMap::TriggerItem,std::allocator<HcalElectronicsMap::TriggerItem> > -------------------------------
static void constructor_6632( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>();
  else ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>();
}

static void constructor_6633( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>(*(const ::std::allocator<HcalElectronicsMap::TriggerItem>*)arg[0]);
  else ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>(*(const ::std::allocator<HcalElectronicsMap::TriggerItem>*)arg[0]);
}

static void constructor_6634( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsMap::TriggerItem*)arg[1]);
  else ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsMap::TriggerItem*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsMap::TriggerItem*)arg[1],
      *(const ::std::allocator<HcalElectronicsMap::TriggerItem>*)arg[2]);
  else ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsMap::TriggerItem*)arg[1],
      *(const ::std::allocator<HcalElectronicsMap::TriggerItem>*)arg[2]);
  }
}

static void constructor_6635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>(*(const ::std::vector<HcalElectronicsMap::TriggerItem>*)arg[0]);
  else ::new(mem) ::std::vector<HcalElectronicsMap::TriggerItem>(*(const ::std::vector<HcalElectronicsMap::TriggerItem>*)arg[0]);
}

static void destructor_6636(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->::std::vector<HcalElectronicsMap::TriggerItem>::~vector)();
}
static  void operator_6637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->operator=)(*(const ::std::vector<HcalElectronicsMap::TriggerItem>*)arg[0]);
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->operator=)(*(const ::std::vector<HcalElectronicsMap::TriggerItem>*)arg[0]);
}

static  void method_6638( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalElectronicsMap::TriggerItem*)arg[1]);
}

static  void method_6639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >)((((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->begin)());
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->begin)();
}

static  void method_6640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >)((((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->begin)());
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->begin)();
}

static  void method_6641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >)((((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->end)());
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->end)();
}

static  void method_6642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >)((((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->end)());
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->end)();
}

static  void method_6647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->size)());
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->size)();
}

static  void method_6648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->max_size)());
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->max_size)();
}

static  void method_6649( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalElectronicsMap::TriggerItem*)arg[1]);
  }
}

static  void method_6650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->capacity)());
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->capacity)();
}

static  void method_6651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->empty)());
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->empty)();
}

static  void method_6652( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->front)();
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->front)();
}

static  void method_6659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->front)();
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->front)();
}

static  void method_6660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->back)();
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->back)();
}

static  void method_6661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->back)();
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->back)();
}

static  void method_6662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->data)());
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->data)();
}

static  void method_6663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->data)());
  else   (((const ::std::vector<HcalElectronicsMap::TriggerItem>*)o)->data)();
}

static  void method_6664( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->push_back)(*(const ::HcalElectronicsMap::TriggerItem*)arg[0]);
}

static  void method_6665( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->pop_back)();
}

static  void method_6666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >)((((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >*)arg[0],
    *(const ::HcalElectronicsMap::TriggerItem*)arg[1]));
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >*)arg[0],
    *(const ::HcalElectronicsMap::TriggerItem*)arg[1]);
}

static  void method_6667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalElectronicsMap::TriggerItem*)arg[2]);
}

static  void method_6668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >)((((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >*)arg[0]));
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >*)arg[0]);
}

static  void method_6669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >)((((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >*)arg[1]));
  else   (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::TriggerItem*,std::vector<HcalElectronicsMap::TriggerItem> >*)arg[1]);
}

static  void method_6670( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->swap)(*(::std::vector<HcalElectronicsMap::TriggerItem>*)arg[0]);
}

static  void method_6671( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalElectronicsMap::TriggerItem>*)o)->clear)();
}

static void method_newdel_1868( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsMap::TriggerItem> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsMap::TriggerItem> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsMap::TriggerItem> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsMap::TriggerItem> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsMap::TriggerItem> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x151( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalElectronicsMap::TriggerItem,std::allocator<HcalElectronicsMap::TriggerItem> >")), ::Reflex::BaseOffset< ::std::vector<HcalElectronicsMap::TriggerItem>,::std::_Vector_base<HcalElectronicsMap::TriggerItem,std::allocator<HcalElectronicsMap::TriggerItem> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalElectronicsMap::TriggerItem> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalElectronicsMap::TriggerItem> >::Generate();
}

//------Dictionary for class vector<HcalElectronicsMap::TriggerItem,std::allocator<HcalElectronicsMap::TriggerItem> > -------------------------------
void __std__vector_HcalElectronicsMap__TriggerItem__db_datamem(Reflex::Class*);
void __std__vector_HcalElectronicsMap__TriggerItem__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalElectronicsMap__TriggerItem__datamem_bld(&__std__vector_HcalElectronicsMap__TriggerItem__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalElectronicsMap__TriggerItem__funcmem_bld(&__std__vector_HcalElectronicsMap__TriggerItem__db_funcmem);
void __std__vector_HcalElectronicsMap__TriggerItem__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>"), typeid(::std::vector<HcalElectronicsMap::TriggerItem>), sizeof(::std::vector<HcalElectronicsMap::TriggerItem>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1812, ::Reflex::BaseOffset< ::std::vector<HcalElectronicsMap::TriggerItem>, ::std::_Vector_base<HcalElectronicsMap::TriggerItem,std::allocator<HcalElectronicsMap::TriggerItem> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2577, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::_Alloc_value_type"))
  .AddTypedef(type_1812, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::_Base"))
  .AddTypedef(type_2156, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::_Tp_alloc_type"))
  .AddTypedef(type_3907, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::_Alloc_traits"))
  .AddTypedef(type_2577, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::value_type"))
  .AddTypedef(type_5109, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::pointer"))
  .AddTypedef(type_6619, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::const_pointer"))
  .AddTypedef(type_6621, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::reference"))
  .AddTypedef(type_6623, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::const_reference"))
  .AddTypedef(type_3835, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::iterator"))
  .AddTypedef(type_3836, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::const_iterator"))
  .AddTypedef(type_2310, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::const_reverse_iterator"))
  .AddTypedef(type_2311, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::difference_type"))
  .AddTypedef(type_2156, Reflex::Literal("std::vector<HcalElectronicsMap::TriggerItem>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6632, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12681), Reflex::Literal("vector"), constructor_6633, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6623, type_12681), Reflex::Literal("vector"), constructor_6634, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12892), Reflex::Literal("vector"), constructor_6635, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6636, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1868, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x151, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalElectronicsMap__TriggerItem__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalElectronicsMap::TriggerItem,std::allocator<HcalElectronicsMap::TriggerItem> > -------------------
void __std__vector_HcalElectronicsMap__TriggerItem__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalElectronicsMap::TriggerItem,std::allocator<HcalElectronicsMap::TriggerItem> > -------------------
void __std__vector_HcalElectronicsMap__TriggerItem__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12893, type_12892), Reflex::Literal("operator="), operator_6637, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6623), Reflex::Literal("assign"), method_6638, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3835), Reflex::Literal("begin"), method_6639, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3836), Reflex::Literal("begin"), method_6640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3835), Reflex::Literal("end"), method_6641, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3836), Reflex::Literal("end"), method_6642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_2577), Reflex::Literal("resize"), method_6649, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6651, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6652, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6621, type_2122), Reflex::Literal("operator[]"), operator_6653, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6623, type_2122), Reflex::Literal("operator[]"), operator_6654, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6621, type_2122), Reflex::Literal("at"), method_6656, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6623, type_2122), Reflex::Literal("at"), method_6657, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6621), Reflex::Literal("front"), method_6658, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6623), Reflex::Literal("front"), method_6659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6621), Reflex::Literal("back"), method_6660, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6623), Reflex::Literal("back"), method_6661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109), Reflex::Literal("data"), method_6662, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6619), Reflex::Literal("data"), method_6663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6623), Reflex::Literal("push_back"), method_6664, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6665, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3835, type_3835, type_6623), Reflex::Literal("insert"), method_6666, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3835, type_2122, type_6623), Reflex::Literal("insert"), method_6667, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3835, type_3835), Reflex::Literal("erase"), method_6668, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3835, type_3835, type_3835), Reflex::Literal("erase"), method_6669, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12893), Reflex::Literal("swap"), method_6670, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6671, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PrecisionItem -------------------------------
static void destructor_9880(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalElectronicsMap::PrecisionItem*)o)->::HcalElectronicsMap::PrecisionItem::~PrecisionItem)();
}
static  void operator_9881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalElectronicsMap::PrecisionItem*)o)->operator=)(*(const ::HcalElectronicsMap::PrecisionItem*)arg[0]);
  else   (((::HcalElectronicsMap::PrecisionItem*)o)->operator=)(*(const ::HcalElectronicsMap::PrecisionItem*)arg[0]);
}

static void constructor_9882( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsMap::PrecisionItem(*(const ::HcalElectronicsMap::PrecisionItem*)arg[0]);
  else ::new(mem) ::HcalElectronicsMap::PrecisionItem(*(const ::HcalElectronicsMap::PrecisionItem*)arg[0]);
}

static void constructor_9883( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsMap::PrecisionItem();
  else ::new(mem) ::HcalElectronicsMap::PrecisionItem();
}

static void constructor_9884( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsMap::PrecisionItem(*(::uint32_t*)arg[0],
      *(::uint32_t*)arg[1]);
  else ::new(mem) ::HcalElectronicsMap::PrecisionItem(*(::uint32_t*)arg[0],
      *(::uint32_t*)arg[1]);
}

static void method_newdel_2576( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap::PrecisionItem >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap::PrecisionItem >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap::PrecisionItem >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap::PrecisionItem >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalElectronicsMap::PrecisionItem >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PrecisionItem -------------------------------
void __HcalElectronicsMap__PrecisionItem_db_datamem(Reflex::Class*);
void __HcalElectronicsMap__PrecisionItem_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalElectronicsMap__PrecisionItem_datamem_bld(&__HcalElectronicsMap__PrecisionItem_db_datamem);
Reflex::GenreflexMemberBuilder __HcalElectronicsMap__PrecisionItem_funcmem_bld(&__HcalElectronicsMap__PrecisionItem_db_funcmem);
void __HcalElectronicsMap__PrecisionItem_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalElectronicsMap::PrecisionItem"), typeid(::HcalElectronicsMap::PrecisionItem), sizeof(::HcalElectronicsMap::PrecisionItem), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PrecisionItem"), destructor_9880, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6686, type_6688), Reflex::Literal("operator="), operator_9881, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6688), Reflex::Literal("PrecisionItem"), constructor_9882, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PrecisionItem"), constructor_9883, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_370, type_370), Reflex::Literal("PrecisionItem"), constructor_9884, 0, "fId;fElId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2576, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalElectronicsMap__PrecisionItem_datamem_bld);
}

//------Delayed data member builder for class PrecisionItem -------------------
void __HcalElectronicsMap__PrecisionItem_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_370, Reflex::Literal("mId"), OffsetOf(__shadow__::__HcalElectronicsMap__PrecisionItem, mId), ::Reflex::PUBLIC)
  .AddDataMember(type_370, Reflex::Literal("mElId"), OffsetOf(__shadow__::__HcalElectronicsMap__PrecisionItem, mElId), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class PrecisionItem -------------------
void __HcalElectronicsMap__PrecisionItem_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<HcalElectronicsMap::PrecisionItem,std::allocator<HcalElectronicsMap::PrecisionItem> > -------------------------------
static void constructor_6697( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>();
  else ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>();
}

static void constructor_6698( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>(*(const ::std::allocator<HcalElectronicsMap::PrecisionItem>*)arg[0]);
  else ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>(*(const ::std::allocator<HcalElectronicsMap::PrecisionItem>*)arg[0]);
}

static void constructor_6699( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsMap::PrecisionItem*)arg[1]);
  else ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsMap::PrecisionItem*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsMap::PrecisionItem*)arg[1],
      *(const ::std::allocator<HcalElectronicsMap::PrecisionItem>*)arg[2]);
  else ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsMap::PrecisionItem*)arg[1],
      *(const ::std::allocator<HcalElectronicsMap::PrecisionItem>*)arg[2]);
  }
}

static void constructor_6700( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>(*(const ::std::vector<HcalElectronicsMap::PrecisionItem>*)arg[0]);
  else ::new(mem) ::std::vector<HcalElectronicsMap::PrecisionItem>(*(const ::std::vector<HcalElectronicsMap::PrecisionItem>*)arg[0]);
}

static void destructor_6701(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->::std::vector<HcalElectronicsMap::PrecisionItem>::~vector)();
}
static  void operator_6702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->operator=)(*(const ::std::vector<HcalElectronicsMap::PrecisionItem>*)arg[0]);
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->operator=)(*(const ::std::vector<HcalElectronicsMap::PrecisionItem>*)arg[0]);
}

static  void method_6703( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalElectronicsMap::PrecisionItem*)arg[1]);
}

static  void method_6704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >)((((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->begin)());
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->begin)();
}

static  void method_6705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >)((((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->begin)());
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->begin)();
}

static  void method_6706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >)((((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->end)());
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->end)();
}

static  void method_6707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >)((((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->end)());
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->end)();
}

static  void method_6712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->size)());
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->size)();
}

static  void method_6713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->max_size)());
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->max_size)();
}

static  void method_6714( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalElectronicsMap::PrecisionItem*)arg[1]);
  }
}

static  void method_6715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->capacity)());
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->capacity)();
}

static  void method_6716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->empty)());
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->empty)();
}

static  void method_6717( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6718( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->front)();
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->front)();
}

static  void method_6724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->front)();
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->front)();
}

static  void method_6725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->back)();
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->back)();
}

static  void method_6726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->back)();
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->back)();
}

static  void method_6727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->data)());
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->data)();
}

static  void method_6728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->data)());
  else   (((const ::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->data)();
}

static  void method_6729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->push_back)(*(const ::HcalElectronicsMap::PrecisionItem*)arg[0]);
}

static  void method_6730( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->pop_back)();
}

static  void method_6731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >)((((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >*)arg[0],
    *(const ::HcalElectronicsMap::PrecisionItem*)arg[1]));
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >*)arg[0],
    *(const ::HcalElectronicsMap::PrecisionItem*)arg[1]);
}

static  void method_6732( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalElectronicsMap::PrecisionItem*)arg[2]);
}

static  void method_6733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >)((((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >*)arg[0]));
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >*)arg[0]);
}

static  void method_6734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >)((((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >*)arg[1]));
  else   (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalElectronicsMap::PrecisionItem*,std::vector<HcalElectronicsMap::PrecisionItem> >*)arg[1]);
}

static  void method_6735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->swap)(*(::std::vector<HcalElectronicsMap::PrecisionItem>*)arg[0]);
}

static  void method_6736( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalElectronicsMap::PrecisionItem>*)o)->clear)();
}

static void method_newdel_1869( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsMap::PrecisionItem> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsMap::PrecisionItem> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsMap::PrecisionItem> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsMap::PrecisionItem> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsMap::PrecisionItem> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalElectronicsMap::PrecisionItem,std::allocator<HcalElectronicsMap::PrecisionItem> >")), ::Reflex::BaseOffset< ::std::vector<HcalElectronicsMap::PrecisionItem>,::std::_Vector_base<HcalElectronicsMap::PrecisionItem,std::allocator<HcalElectronicsMap::PrecisionItem> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalElectronicsMap::PrecisionItem> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalElectronicsMap::PrecisionItem> >::Generate();
}

//------Dictionary for class vector<HcalElectronicsMap::PrecisionItem,std::allocator<HcalElectronicsMap::PrecisionItem> > -------------------------------
void __std__vector_HcalElectronicsMap__PrecisionItem__db_datamem(Reflex::Class*);
void __std__vector_HcalElectronicsMap__PrecisionItem__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalElectronicsMap__PrecisionItem__datamem_bld(&__std__vector_HcalElectronicsMap__PrecisionItem__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalElectronicsMap__PrecisionItem__funcmem_bld(&__std__vector_HcalElectronicsMap__PrecisionItem__db_funcmem);
void __std__vector_HcalElectronicsMap__PrecisionItem__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>"), typeid(::std::vector<HcalElectronicsMap::PrecisionItem>), sizeof(::std::vector<HcalElectronicsMap::PrecisionItem>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1813, ::Reflex::BaseOffset< ::std::vector<HcalElectronicsMap::PrecisionItem>, ::std::_Vector_base<HcalElectronicsMap::PrecisionItem,std::allocator<HcalElectronicsMap::PrecisionItem> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2576, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::_Alloc_value_type"))
  .AddTypedef(type_1813, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::_Base"))
  .AddTypedef(type_2157, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::_Tp_alloc_type"))
  .AddTypedef(type_3908, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::_Alloc_traits"))
  .AddTypedef(type_2576, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::value_type"))
  .AddTypedef(type_5128, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::pointer"))
  .AddTypedef(type_6684, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::const_pointer"))
  .AddTypedef(type_6686, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::reference"))
  .AddTypedef(type_6688, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::const_reference"))
  .AddTypedef(type_3837, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::iterator"))
  .AddTypedef(type_3838, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::const_iterator"))
  .AddTypedef(type_2312, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::const_reverse_iterator"))
  .AddTypedef(type_2313, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::difference_type"))
  .AddTypedef(type_2157, Reflex::Literal("std::vector<HcalElectronicsMap::PrecisionItem>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6697, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12694), Reflex::Literal("vector"), constructor_6698, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6688, type_12694), Reflex::Literal("vector"), constructor_6699, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12895), Reflex::Literal("vector"), constructor_6700, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6701, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1869, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalElectronicsMap__PrecisionItem__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalElectronicsMap::PrecisionItem,std::allocator<HcalElectronicsMap::PrecisionItem> > -------------------
void __std__vector_HcalElectronicsMap__PrecisionItem__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalElectronicsMap::PrecisionItem,std::allocator<HcalElectronicsMap::PrecisionItem> > -------------------
void __std__vector_HcalElectronicsMap__PrecisionItem__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12896, type_12895), Reflex::Literal("operator="), operator_6702, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6688), Reflex::Literal("assign"), method_6703, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3837), Reflex::Literal("begin"), method_6704, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3838), Reflex::Literal("begin"), method_6705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3837), Reflex::Literal("end"), method_6706, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3838), Reflex::Literal("end"), method_6707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_2576), Reflex::Literal("resize"), method_6714, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6717, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6686, type_2122), Reflex::Literal("operator[]"), operator_6718, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6688, type_2122), Reflex::Literal("operator[]"), operator_6719, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6686, type_2122), Reflex::Literal("at"), method_6721, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6688, type_2122), Reflex::Literal("at"), method_6722, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6686), Reflex::Literal("front"), method_6723, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6688), Reflex::Literal("front"), method_6724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6686), Reflex::Literal("back"), method_6725, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6688), Reflex::Literal("back"), method_6726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5128), Reflex::Literal("data"), method_6727, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6684), Reflex::Literal("data"), method_6728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6688), Reflex::Literal("push_back"), method_6729, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6730, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3837, type_3837, type_6688), Reflex::Literal("insert"), method_6731, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3837, type_2122, type_6688), Reflex::Literal("insert"), method_6732, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3837, type_3837), Reflex::Literal("erase"), method_6733, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3837, type_3837, type_3837), Reflex::Literal("erase"), method_6734, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12896), Reflex::Literal("swap"), method_6735, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6736, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalCalibrationQIECoder,std::allocator<HcalCalibrationQIECoder> > -------------------------------
static void constructor_6762( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCalibrationQIECoder>();
  else ::new(mem) ::std::vector<HcalCalibrationQIECoder>();
}

static void constructor_6763( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCalibrationQIECoder>(*(const ::std::allocator<HcalCalibrationQIECoder>*)arg[0]);
  else ::new(mem) ::std::vector<HcalCalibrationQIECoder>(*(const ::std::allocator<HcalCalibrationQIECoder>*)arg[0]);
}

static void constructor_6764( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCalibrationQIECoder>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalCalibrationQIECoder>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCalibrationQIECoder>(*(::std::size_t*)arg[0],
      *(const ::HcalCalibrationQIECoder*)arg[1]);
  else ::new(mem) ::std::vector<HcalCalibrationQIECoder>(*(::std::size_t*)arg[0],
      *(const ::HcalCalibrationQIECoder*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCalibrationQIECoder>(*(::std::size_t*)arg[0],
      *(const ::HcalCalibrationQIECoder*)arg[1],
      *(const ::std::allocator<HcalCalibrationQIECoder>*)arg[2]);
  else ::new(mem) ::std::vector<HcalCalibrationQIECoder>(*(::std::size_t*)arg[0],
      *(const ::HcalCalibrationQIECoder*)arg[1],
      *(const ::std::allocator<HcalCalibrationQIECoder>*)arg[2]);
  }
}

static void constructor_6765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalCalibrationQIECoder>(*(const ::std::vector<HcalCalibrationQIECoder>*)arg[0]);
  else ::new(mem) ::std::vector<HcalCalibrationQIECoder>(*(const ::std::vector<HcalCalibrationQIECoder>*)arg[0]);
}

static void destructor_6766(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalCalibrationQIECoder>*)o)->::std::vector<HcalCalibrationQIECoder>::~vector)();
}
static  void operator_6767( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCalibrationQIECoder>*)o)->operator=)(*(const ::std::vector<HcalCalibrationQIECoder>*)arg[0]);
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->operator=)(*(const ::std::vector<HcalCalibrationQIECoder>*)arg[0]);
}

static  void method_6768( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCalibrationQIECoder>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalCalibrationQIECoder*)arg[1]);
}

static  void method_6769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >)((((::std::vector<HcalCalibrationQIECoder>*)o)->begin)());
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->begin)();
}

static  void method_6770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >)((((const ::std::vector<HcalCalibrationQIECoder>*)o)->begin)());
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->begin)();
}

static  void method_6771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >)((((::std::vector<HcalCalibrationQIECoder>*)o)->end)());
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->end)();
}

static  void method_6772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >)((((const ::std::vector<HcalCalibrationQIECoder>*)o)->end)());
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->end)();
}

static  void method_6777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalCalibrationQIECoder>*)o)->size)());
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->size)();
}

static  void method_6778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalCalibrationQIECoder>*)o)->max_size)());
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->max_size)();
}

static  void method_6779( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalCalibrationQIECoder>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalCalibrationQIECoder>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalCalibrationQIECoder*)arg[1]);
  }
}

static  void method_6780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalCalibrationQIECoder>*)o)->capacity)());
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->capacity)();
}

static  void method_6781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalCalibrationQIECoder>*)o)->empty)());
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->empty)();
}

static  void method_6782( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCalibrationQIECoder>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCalibrationQIECoder>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6784( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCalibrationQIECoder>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCalibrationQIECoder>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6787( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCalibrationQIECoder>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCalibrationQIECoder>*)o)->front)();
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->front)();
}

static  void method_6789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCalibrationQIECoder>*)o)->front)();
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->front)();
}

static  void method_6790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalCalibrationQIECoder>*)o)->back)();
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->back)();
}

static  void method_6791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalCalibrationQIECoder>*)o)->back)();
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->back)();
}

static  void method_6792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalCalibrationQIECoder>*)o)->data)());
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->data)();
}

static  void method_6793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalCalibrationQIECoder>*)o)->data)());
  else   (((const ::std::vector<HcalCalibrationQIECoder>*)o)->data)();
}

static  void method_6794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCalibrationQIECoder>*)o)->push_back)(*(const ::HcalCalibrationQIECoder*)arg[0]);
}

static  void method_6795( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalCalibrationQIECoder>*)o)->pop_back)();
}

static  void method_6796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >)((((::std::vector<HcalCalibrationQIECoder>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >*)arg[0],
    *(const ::HcalCalibrationQIECoder*)arg[1]));
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >*)arg[0],
    *(const ::HcalCalibrationQIECoder*)arg[1]);
}

static  void method_6797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCalibrationQIECoder>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalCalibrationQIECoder*)arg[2]);
}

static  void method_6798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >)((((::std::vector<HcalCalibrationQIECoder>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >*)arg[0]));
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >*)arg[0]);
}

static  void method_6799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >)((((::std::vector<HcalCalibrationQIECoder>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >*)arg[1]));
  else   (((::std::vector<HcalCalibrationQIECoder>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalCalibrationQIECoder*,std::vector<HcalCalibrationQIECoder> >*)arg[1]);
}

static  void method_6800( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalCalibrationQIECoder>*)o)->swap)(*(::std::vector<HcalCalibrationQIECoder>*)arg[0]);
}

static  void method_6801( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalCalibrationQIECoder>*)o)->clear)();
}

static void method_newdel_1870( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCalibrationQIECoder> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCalibrationQIECoder> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCalibrationQIECoder> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCalibrationQIECoder> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalCalibrationQIECoder> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalCalibrationQIECoder,std::allocator<HcalCalibrationQIECoder> >")), ::Reflex::BaseOffset< ::std::vector<HcalCalibrationQIECoder>,::std::_Vector_base<HcalCalibrationQIECoder,std::allocator<HcalCalibrationQIECoder> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalCalibrationQIECoder> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalCalibrationQIECoder> >::Generate();
}

//------Dictionary for class vector<HcalCalibrationQIECoder,std::allocator<HcalCalibrationQIECoder> > -------------------------------
void __std__vector_HcalCalibrationQIECoder__db_datamem(Reflex::Class*);
void __std__vector_HcalCalibrationQIECoder__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalCalibrationQIECoder__datamem_bld(&__std__vector_HcalCalibrationQIECoder__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalCalibrationQIECoder__funcmem_bld(&__std__vector_HcalCalibrationQIECoder__db_funcmem);
void __std__vector_HcalCalibrationQIECoder__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalCalibrationQIECoder>"), typeid(::std::vector<HcalCalibrationQIECoder>), sizeof(::std::vector<HcalCalibrationQIECoder>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1815, ::Reflex::BaseOffset< ::std::vector<HcalCalibrationQIECoder>, ::std::_Vector_base<HcalCalibrationQIECoder,std::allocator<HcalCalibrationQIECoder> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1252, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::_Alloc_value_type"))
  .AddTypedef(type_1815, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::_Base"))
  .AddTypedef(type_2158, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::_Tp_alloc_type"))
  .AddTypedef(type_3910, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::_Alloc_traits"))
  .AddTypedef(type_1252, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::value_type"))
  .AddTypedef(type_5166, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::pointer"))
  .AddTypedef(type_6749, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::const_pointer"))
  .AddTypedef(type_6751, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::reference"))
  .AddTypedef(type_6753, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::const_reference"))
  .AddTypedef(type_3841, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::iterator"))
  .AddTypedef(type_3842, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::const_iterator"))
  .AddTypedef(type_2316, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::const_reverse_iterator"))
  .AddTypedef(type_2317, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::difference_type"))
  .AddTypedef(type_2158, Reflex::Literal("std::vector<HcalCalibrationQIECoder>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6762, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12720), Reflex::Literal("vector"), constructor_6763, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6753, type_12720), Reflex::Literal("vector"), constructor_6764, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12898), Reflex::Literal("vector"), constructor_6765, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6766, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1870, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalCalibrationQIECoder__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalCalibrationQIECoder,std::allocator<HcalCalibrationQIECoder> > -------------------
void __std__vector_HcalCalibrationQIECoder__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalCalibrationQIECoder,std::allocator<HcalCalibrationQIECoder> > -------------------
void __std__vector_HcalCalibrationQIECoder__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12899, type_12898), Reflex::Literal("operator="), operator_6767, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6753), Reflex::Literal("assign"), method_6768, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3841), Reflex::Literal("begin"), method_6769, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3842), Reflex::Literal("begin"), method_6770, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3841), Reflex::Literal("end"), method_6771, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3842), Reflex::Literal("end"), method_6772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6777, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1252), Reflex::Literal("resize"), method_6779, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6782, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6751, type_2122), Reflex::Literal("operator[]"), operator_6783, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6753, type_2122), Reflex::Literal("operator[]"), operator_6784, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6751, type_2122), Reflex::Literal("at"), method_6786, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6753, type_2122), Reflex::Literal("at"), method_6787, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6751), Reflex::Literal("front"), method_6788, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6753), Reflex::Literal("front"), method_6789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6751), Reflex::Literal("back"), method_6790, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6753), Reflex::Literal("back"), method_6791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5166), Reflex::Literal("data"), method_6792, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6749), Reflex::Literal("data"), method_6793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6753), Reflex::Literal("push_back"), method_6794, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6795, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3841, type_3841, type_6753), Reflex::Literal("insert"), method_6796, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3841, type_2122, type_6753), Reflex::Literal("insert"), method_6797, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3841, type_3841), Reflex::Literal("erase"), method_6798, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3841, type_3841, type_3841), Reflex::Literal("erase"), method_6799, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12899), Reflex::Literal("swap"), method_6800, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6801, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalQIECoder,std::allocator<HcalQIECoder> > -------------------------------
static void constructor_6827( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalQIECoder>();
  else ::new(mem) ::std::vector<HcalQIECoder>();
}

static void constructor_6828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalQIECoder>(*(const ::std::allocator<HcalQIECoder>*)arg[0]);
  else ::new(mem) ::std::vector<HcalQIECoder>(*(const ::std::allocator<HcalQIECoder>*)arg[0]);
}

static void constructor_6829( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalQIECoder>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalQIECoder>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalQIECoder>(*(::std::size_t*)arg[0],
      *(const ::HcalQIECoder*)arg[1]);
  else ::new(mem) ::std::vector<HcalQIECoder>(*(::std::size_t*)arg[0],
      *(const ::HcalQIECoder*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalQIECoder>(*(::std::size_t*)arg[0],
      *(const ::HcalQIECoder*)arg[1],
      *(const ::std::allocator<HcalQIECoder>*)arg[2]);
  else ::new(mem) ::std::vector<HcalQIECoder>(*(::std::size_t*)arg[0],
      *(const ::HcalQIECoder*)arg[1],
      *(const ::std::allocator<HcalQIECoder>*)arg[2]);
  }
}

static void constructor_6830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalQIECoder>(*(const ::std::vector<HcalQIECoder>*)arg[0]);
  else ::new(mem) ::std::vector<HcalQIECoder>(*(const ::std::vector<HcalQIECoder>*)arg[0]);
}

static void destructor_6831(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalQIECoder>*)o)->::std::vector<HcalQIECoder>::~vector)();
}
static  void operator_6832( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalQIECoder>*)o)->operator=)(*(const ::std::vector<HcalQIECoder>*)arg[0]);
  else   (((::std::vector<HcalQIECoder>*)o)->operator=)(*(const ::std::vector<HcalQIECoder>*)arg[0]);
}

static  void method_6833( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalQIECoder>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalQIECoder*)arg[1]);
}

static  void method_6834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >)((((::std::vector<HcalQIECoder>*)o)->begin)());
  else   (((::std::vector<HcalQIECoder>*)o)->begin)();
}

static  void method_6835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalQIECoder*,std::vector<HcalQIECoder> >)((((const ::std::vector<HcalQIECoder>*)o)->begin)());
  else   (((const ::std::vector<HcalQIECoder>*)o)->begin)();
}

static  void method_6836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >)((((::std::vector<HcalQIECoder>*)o)->end)());
  else   (((::std::vector<HcalQIECoder>*)o)->end)();
}

static  void method_6837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalQIECoder*,std::vector<HcalQIECoder> >)((((const ::std::vector<HcalQIECoder>*)o)->end)());
  else   (((const ::std::vector<HcalQIECoder>*)o)->end)();
}

static  void method_6842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalQIECoder>*)o)->size)());
  else   (((const ::std::vector<HcalQIECoder>*)o)->size)();
}

static  void method_6843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalQIECoder>*)o)->max_size)());
  else   (((const ::std::vector<HcalQIECoder>*)o)->max_size)();
}

static  void method_6844( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalQIECoder>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalQIECoder>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalQIECoder*)arg[1]);
  }
}

static  void method_6845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalQIECoder>*)o)->capacity)());
  else   (((const ::std::vector<HcalQIECoder>*)o)->capacity)();
}

static  void method_6846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalQIECoder>*)o)->empty)());
  else   (((const ::std::vector<HcalQIECoder>*)o)->empty)();
}

static  void method_6847( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalQIECoder>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalQIECoder>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalQIECoder>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalQIECoder>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalQIECoder>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalQIECoder>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalQIECoder>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalQIECoder>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalQIECoder>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalQIECoder>*)o)->front)();
  else   (((::std::vector<HcalQIECoder>*)o)->front)();
}

static  void method_6854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalQIECoder>*)o)->front)();
  else   (((const ::std::vector<HcalQIECoder>*)o)->front)();
}

static  void method_6855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalQIECoder>*)o)->back)();
  else   (((::std::vector<HcalQIECoder>*)o)->back)();
}

static  void method_6856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalQIECoder>*)o)->back)();
  else   (((const ::std::vector<HcalQIECoder>*)o)->back)();
}

static  void method_6857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalQIECoder>*)o)->data)());
  else   (((::std::vector<HcalQIECoder>*)o)->data)();
}

static  void method_6858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalQIECoder>*)o)->data)());
  else   (((const ::std::vector<HcalQIECoder>*)o)->data)();
}

static  void method_6859( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalQIECoder>*)o)->push_back)(*(const ::HcalQIECoder*)arg[0]);
}

static  void method_6860( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalQIECoder>*)o)->pop_back)();
}

static  void method_6861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >)((((::std::vector<HcalQIECoder>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >*)arg[0],
    *(const ::HcalQIECoder*)arg[1]));
  else   (((::std::vector<HcalQIECoder>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >*)arg[0],
    *(const ::HcalQIECoder*)arg[1]);
}

static  void method_6862( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalQIECoder>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalQIECoder*)arg[2]);
}

static  void method_6863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >)((((::std::vector<HcalQIECoder>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >*)arg[0]));
  else   (((::std::vector<HcalQIECoder>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >*)arg[0]);
}

static  void method_6864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >)((((::std::vector<HcalQIECoder>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >*)arg[1]));
  else   (((::std::vector<HcalQIECoder>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalQIECoder*,std::vector<HcalQIECoder> >*)arg[1]);
}

static  void method_6865( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalQIECoder>*)o)->swap)(*(::std::vector<HcalQIECoder>*)arg[0]);
}

static  void method_6866( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalQIECoder>*)o)->clear)();
}

static void method_newdel_1871( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalQIECoder> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalQIECoder> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalQIECoder> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalQIECoder> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalQIECoder> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalQIECoder,std::allocator<HcalQIECoder> >")), ::Reflex::BaseOffset< ::std::vector<HcalQIECoder>,::std::_Vector_base<HcalQIECoder,std::allocator<HcalQIECoder> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalQIECoder> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalQIECoder> >::Generate();
}

//------Dictionary for class vector<HcalQIECoder,std::allocator<HcalQIECoder> > -------------------------------
void __std__vector_HcalQIECoder__db_datamem(Reflex::Class*);
void __std__vector_HcalQIECoder__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalQIECoder__datamem_bld(&__std__vector_HcalQIECoder__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalQIECoder__funcmem_bld(&__std__vector_HcalQIECoder__db_funcmem);
void __std__vector_HcalQIECoder__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalQIECoder>"), typeid(::std::vector<HcalQIECoder>), sizeof(::std::vector<HcalQIECoder>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1816, ::Reflex::BaseOffset< ::std::vector<HcalQIECoder>, ::std::_Vector_base<HcalQIECoder,std::allocator<HcalQIECoder> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_172, Reflex::Literal("std::vector<HcalQIECoder>::_Alloc_value_type"))
  .AddTypedef(type_1816, Reflex::Literal("std::vector<HcalQIECoder>::_Base"))
  .AddTypedef(type_2159, Reflex::Literal("std::vector<HcalQIECoder>::_Tp_alloc_type"))
  .AddTypedef(type_3911, Reflex::Literal("std::vector<HcalQIECoder>::_Alloc_traits"))
  .AddTypedef(type_172, Reflex::Literal("std::vector<HcalQIECoder>::value_type"))
  .AddTypedef(type_5185, Reflex::Literal("std::vector<HcalQIECoder>::pointer"))
  .AddTypedef(type_6814, Reflex::Literal("std::vector<HcalQIECoder>::const_pointer"))
  .AddTypedef(type_6816, Reflex::Literal("std::vector<HcalQIECoder>::reference"))
  .AddTypedef(type_6818, Reflex::Literal("std::vector<HcalQIECoder>::const_reference"))
  .AddTypedef(type_3843, Reflex::Literal("std::vector<HcalQIECoder>::iterator"))
  .AddTypedef(type_3844, Reflex::Literal("std::vector<HcalQIECoder>::const_iterator"))
  .AddTypedef(type_2318, Reflex::Literal("std::vector<HcalQIECoder>::const_reverse_iterator"))
  .AddTypedef(type_2319, Reflex::Literal("std::vector<HcalQIECoder>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalQIECoder>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalQIECoder>::difference_type"))
  .AddTypedef(type_2159, Reflex::Literal("std::vector<HcalQIECoder>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6827, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12733), Reflex::Literal("vector"), constructor_6828, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6818, type_12733), Reflex::Literal("vector"), constructor_6829, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12901), Reflex::Literal("vector"), constructor_6830, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6831, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1871, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalQIECoder__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalQIECoder,std::allocator<HcalQIECoder> > -------------------
void __std__vector_HcalQIECoder__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalQIECoder,std::allocator<HcalQIECoder> > -------------------
void __std__vector_HcalQIECoder__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12902, type_12901), Reflex::Literal("operator="), operator_6832, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6818), Reflex::Literal("assign"), method_6833, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3843), Reflex::Literal("begin"), method_6834, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3844), Reflex::Literal("begin"), method_6835, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3843), Reflex::Literal("end"), method_6836, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3844), Reflex::Literal("end"), method_6837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_172), Reflex::Literal("resize"), method_6844, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6846, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6847, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6816, type_2122), Reflex::Literal("operator[]"), operator_6848, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6818, type_2122), Reflex::Literal("operator[]"), operator_6849, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6816, type_2122), Reflex::Literal("at"), method_6851, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6818, type_2122), Reflex::Literal("at"), method_6852, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6816), Reflex::Literal("front"), method_6853, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6818), Reflex::Literal("front"), method_6854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6816), Reflex::Literal("back"), method_6855, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6818), Reflex::Literal("back"), method_6856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5185), Reflex::Literal("data"), method_6857, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6814), Reflex::Literal("data"), method_6858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6818), Reflex::Literal("push_back"), method_6859, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6860, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3843, type_3843, type_6818), Reflex::Literal("insert"), method_6861, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3843, type_2122, type_6818), Reflex::Literal("insert"), method_6862, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3843, type_3843), Reflex::Literal("erase"), method_6863, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3843, type_3843, type_3843), Reflex::Literal("erase"), method_6864, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12902), Reflex::Literal("swap"), method_6865, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6866, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalGainWidth,std::allocator<HcalGainWidth> > -------------------------------
static void constructor_6892( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGainWidth>();
  else ::new(mem) ::std::vector<HcalGainWidth>();
}

static void constructor_6893( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGainWidth>(*(const ::std::allocator<HcalGainWidth>*)arg[0]);
  else ::new(mem) ::std::vector<HcalGainWidth>(*(const ::std::allocator<HcalGainWidth>*)arg[0]);
}

static void constructor_6894( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGainWidth>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalGainWidth>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGainWidth>(*(::std::size_t*)arg[0],
      *(const ::HcalGainWidth*)arg[1]);
  else ::new(mem) ::std::vector<HcalGainWidth>(*(::std::size_t*)arg[0],
      *(const ::HcalGainWidth*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGainWidth>(*(::std::size_t*)arg[0],
      *(const ::HcalGainWidth*)arg[1],
      *(const ::std::allocator<HcalGainWidth>*)arg[2]);
  else ::new(mem) ::std::vector<HcalGainWidth>(*(::std::size_t*)arg[0],
      *(const ::HcalGainWidth*)arg[1],
      *(const ::std::allocator<HcalGainWidth>*)arg[2]);
  }
}

static void constructor_6895( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGainWidth>(*(const ::std::vector<HcalGainWidth>*)arg[0]);
  else ::new(mem) ::std::vector<HcalGainWidth>(*(const ::std::vector<HcalGainWidth>*)arg[0]);
}

static void destructor_6896(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalGainWidth>*)o)->::std::vector<HcalGainWidth>::~vector)();
}
static  void operator_6897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalGainWidth>*)o)->operator=)(*(const ::std::vector<HcalGainWidth>*)arg[0]);
  else   (((::std::vector<HcalGainWidth>*)o)->operator=)(*(const ::std::vector<HcalGainWidth>*)arg[0]);
}

static  void method_6898( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalGainWidth>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalGainWidth*)arg[1]);
}

static  void method_6899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >)((((::std::vector<HcalGainWidth>*)o)->begin)());
  else   (((::std::vector<HcalGainWidth>*)o)->begin)();
}

static  void method_6900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalGainWidth*,std::vector<HcalGainWidth> >)((((const ::std::vector<HcalGainWidth>*)o)->begin)());
  else   (((const ::std::vector<HcalGainWidth>*)o)->begin)();
}

static  void method_6901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >)((((::std::vector<HcalGainWidth>*)o)->end)());
  else   (((::std::vector<HcalGainWidth>*)o)->end)();
}

static  void method_6902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalGainWidth*,std::vector<HcalGainWidth> >)((((const ::std::vector<HcalGainWidth>*)o)->end)());
  else   (((const ::std::vector<HcalGainWidth>*)o)->end)();
}

static  void method_6907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalGainWidth>*)o)->size)());
  else   (((const ::std::vector<HcalGainWidth>*)o)->size)();
}

static  void method_6908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalGainWidth>*)o)->max_size)());
  else   (((const ::std::vector<HcalGainWidth>*)o)->max_size)();
}

static  void method_6909( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalGainWidth>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalGainWidth>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalGainWidth*)arg[1]);
  }
}

static  void method_6910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalGainWidth>*)o)->capacity)());
  else   (((const ::std::vector<HcalGainWidth>*)o)->capacity)();
}

static  void method_6911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalGainWidth>*)o)->empty)());
  else   (((const ::std::vector<HcalGainWidth>*)o)->empty)();
}

static  void method_6912( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalGainWidth>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalGainWidth>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalGainWidth>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalGainWidth>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalGainWidth>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalGainWidth>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalGainWidth>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6917( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalGainWidth>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalGainWidth>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalGainWidth>*)o)->front)();
  else   (((::std::vector<HcalGainWidth>*)o)->front)();
}

static  void method_6919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalGainWidth>*)o)->front)();
  else   (((const ::std::vector<HcalGainWidth>*)o)->front)();
}

static  void method_6920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalGainWidth>*)o)->back)();
  else   (((::std::vector<HcalGainWidth>*)o)->back)();
}

static  void method_6921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalGainWidth>*)o)->back)();
  else   (((const ::std::vector<HcalGainWidth>*)o)->back)();
}

static  void method_6922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalGainWidth>*)o)->data)());
  else   (((::std::vector<HcalGainWidth>*)o)->data)();
}

static  void method_6923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalGainWidth>*)o)->data)());
  else   (((const ::std::vector<HcalGainWidth>*)o)->data)();
}

static  void method_6924( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalGainWidth>*)o)->push_back)(*(const ::HcalGainWidth*)arg[0]);
}

static  void method_6925( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalGainWidth>*)o)->pop_back)();
}

static  void method_6926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >)((((::std::vector<HcalGainWidth>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >*)arg[0],
    *(const ::HcalGainWidth*)arg[1]));
  else   (((::std::vector<HcalGainWidth>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >*)arg[0],
    *(const ::HcalGainWidth*)arg[1]);
}

static  void method_6927( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalGainWidth>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalGainWidth*)arg[2]);
}

static  void method_6928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >)((((::std::vector<HcalGainWidth>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >*)arg[0]));
  else   (((::std::vector<HcalGainWidth>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >*)arg[0]);
}

static  void method_6929( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >)((((::std::vector<HcalGainWidth>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >*)arg[1]));
  else   (((::std::vector<HcalGainWidth>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalGainWidth*,std::vector<HcalGainWidth> >*)arg[1]);
}

static  void method_6930( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalGainWidth>*)o)->swap)(*(::std::vector<HcalGainWidth>*)arg[0]);
}

static  void method_6931( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalGainWidth>*)o)->clear)();
}

static void method_newdel_1872( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalGainWidth> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalGainWidth> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalGainWidth> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalGainWidth> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalGainWidth> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x164( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalGainWidth,std::allocator<HcalGainWidth> >")), ::Reflex::BaseOffset< ::std::vector<HcalGainWidth>,::std::_Vector_base<HcalGainWidth,std::allocator<HcalGainWidth> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalGainWidth> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalGainWidth> >::Generate();
}

//------Dictionary for class vector<HcalGainWidth,std::allocator<HcalGainWidth> > -------------------------------
void __std__vector_HcalGainWidth__db_datamem(Reflex::Class*);
void __std__vector_HcalGainWidth__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalGainWidth__datamem_bld(&__std__vector_HcalGainWidth__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalGainWidth__funcmem_bld(&__std__vector_HcalGainWidth__db_funcmem);
void __std__vector_HcalGainWidth__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalGainWidth>"), typeid(::std::vector<HcalGainWidth>), sizeof(::std::vector<HcalGainWidth>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1818, ::Reflex::BaseOffset< ::std::vector<HcalGainWidth>, ::std::_Vector_base<HcalGainWidth,std::allocator<HcalGainWidth> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_139, Reflex::Literal("std::vector<HcalGainWidth>::_Alloc_value_type"))
  .AddTypedef(type_1818, Reflex::Literal("std::vector<HcalGainWidth>::_Base"))
  .AddTypedef(type_2160, Reflex::Literal("std::vector<HcalGainWidth>::_Tp_alloc_type"))
  .AddTypedef(type_3913, Reflex::Literal("std::vector<HcalGainWidth>::_Alloc_traits"))
  .AddTypedef(type_139, Reflex::Literal("std::vector<HcalGainWidth>::value_type"))
  .AddTypedef(type_5222, Reflex::Literal("std::vector<HcalGainWidth>::pointer"))
  .AddTypedef(type_6879, Reflex::Literal("std::vector<HcalGainWidth>::const_pointer"))
  .AddTypedef(type_6881, Reflex::Literal("std::vector<HcalGainWidth>::reference"))
  .AddTypedef(type_6883, Reflex::Literal("std::vector<HcalGainWidth>::const_reference"))
  .AddTypedef(type_3847, Reflex::Literal("std::vector<HcalGainWidth>::iterator"))
  .AddTypedef(type_3848, Reflex::Literal("std::vector<HcalGainWidth>::const_iterator"))
  .AddTypedef(type_2322, Reflex::Literal("std::vector<HcalGainWidth>::const_reverse_iterator"))
  .AddTypedef(type_2323, Reflex::Literal("std::vector<HcalGainWidth>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalGainWidth>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalGainWidth>::difference_type"))
  .AddTypedef(type_2160, Reflex::Literal("std::vector<HcalGainWidth>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6892, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12759), Reflex::Literal("vector"), constructor_6893, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6883, type_12759), Reflex::Literal("vector"), constructor_6894, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12904), Reflex::Literal("vector"), constructor_6895, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6896, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1872, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalGainWidth__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalGainWidth,std::allocator<HcalGainWidth> > -------------------
void __std__vector_HcalGainWidth__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalGainWidth,std::allocator<HcalGainWidth> > -------------------
void __std__vector_HcalGainWidth__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12905, type_12904), Reflex::Literal("operator="), operator_6897, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6883), Reflex::Literal("assign"), method_6898, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3847), Reflex::Literal("begin"), method_6899, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3848), Reflex::Literal("begin"), method_6900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3847), Reflex::Literal("end"), method_6901, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3848), Reflex::Literal("end"), method_6902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_139), Reflex::Literal("resize"), method_6909, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6911, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6912, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6881, type_2122), Reflex::Literal("operator[]"), operator_6913, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6883, type_2122), Reflex::Literal("operator[]"), operator_6914, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6881, type_2122), Reflex::Literal("at"), method_6916, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6883, type_2122), Reflex::Literal("at"), method_6917, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6881), Reflex::Literal("front"), method_6918, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6883), Reflex::Literal("front"), method_6919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6881), Reflex::Literal("back"), method_6920, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6883), Reflex::Literal("back"), method_6921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5222), Reflex::Literal("data"), method_6922, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6879), Reflex::Literal("data"), method_6923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6883), Reflex::Literal("push_back"), method_6924, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6925, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3847, type_3847, type_6883), Reflex::Literal("insert"), method_6926, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3847, type_2122, type_6883), Reflex::Literal("insert"), method_6927, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3847, type_3847), Reflex::Literal("erase"), method_6928, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3847, type_3847, type_3847), Reflex::Literal("erase"), method_6929, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12905), Reflex::Literal("swap"), method_6930, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6931, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalGain,std::allocator<HcalGain> > -------------------------------
static void constructor_6957( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGain>();
  else ::new(mem) ::std::vector<HcalGain>();
}

static void constructor_6958( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGain>(*(const ::std::allocator<HcalGain>*)arg[0]);
  else ::new(mem) ::std::vector<HcalGain>(*(const ::std::allocator<HcalGain>*)arg[0]);
}

static void constructor_6959( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGain>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalGain>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGain>(*(::std::size_t*)arg[0],
      *(const ::HcalGain*)arg[1]);
  else ::new(mem) ::std::vector<HcalGain>(*(::std::size_t*)arg[0],
      *(const ::HcalGain*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGain>(*(::std::size_t*)arg[0],
      *(const ::HcalGain*)arg[1],
      *(const ::std::allocator<HcalGain>*)arg[2]);
  else ::new(mem) ::std::vector<HcalGain>(*(::std::size_t*)arg[0],
      *(const ::HcalGain*)arg[1],
      *(const ::std::allocator<HcalGain>*)arg[2]);
  }
}

static void constructor_6960( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalGain>(*(const ::std::vector<HcalGain>*)arg[0]);
  else ::new(mem) ::std::vector<HcalGain>(*(const ::std::vector<HcalGain>*)arg[0]);
}

static void destructor_6961(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalGain>*)o)->::std::vector<HcalGain>::~vector)();
}
static  void operator_6962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalGain>*)o)->operator=)(*(const ::std::vector<HcalGain>*)arg[0]);
  else   (((::std::vector<HcalGain>*)o)->operator=)(*(const ::std::vector<HcalGain>*)arg[0]);
}

static  void method_6963( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalGain>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalGain*)arg[1]);
}

static  void method_6964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >)((((::std::vector<HcalGain>*)o)->begin)());
  else   (((::std::vector<HcalGain>*)o)->begin)();
}

static  void method_6965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalGain*,std::vector<HcalGain> >)((((const ::std::vector<HcalGain>*)o)->begin)());
  else   (((const ::std::vector<HcalGain>*)o)->begin)();
}

static  void method_6966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >)((((::std::vector<HcalGain>*)o)->end)());
  else   (((::std::vector<HcalGain>*)o)->end)();
}

static  void method_6967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalGain*,std::vector<HcalGain> >)((((const ::std::vector<HcalGain>*)o)->end)());
  else   (((const ::std::vector<HcalGain>*)o)->end)();
}

static  void method_6972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalGain>*)o)->size)());
  else   (((const ::std::vector<HcalGain>*)o)->size)();
}

static  void method_6973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalGain>*)o)->max_size)());
  else   (((const ::std::vector<HcalGain>*)o)->max_size)();
}

static  void method_6974( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalGain>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalGain>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalGain*)arg[1]);
  }
}

static  void method_6975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalGain>*)o)->capacity)());
  else   (((const ::std::vector<HcalGain>*)o)->capacity)();
}

static  void method_6976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalGain>*)o)->empty)());
  else   (((const ::std::vector<HcalGain>*)o)->empty)();
}

static  void method_6977( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalGain>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalGain>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalGain>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalGain>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalGain>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalGain>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalGain>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalGain>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalGain>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalGain>*)o)->front)();
  else   (((::std::vector<HcalGain>*)o)->front)();
}

static  void method_6984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalGain>*)o)->front)();
  else   (((const ::std::vector<HcalGain>*)o)->front)();
}

static  void method_6985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalGain>*)o)->back)();
  else   (((::std::vector<HcalGain>*)o)->back)();
}

static  void method_6986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalGain>*)o)->back)();
  else   (((const ::std::vector<HcalGain>*)o)->back)();
}

static  void method_6987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalGain>*)o)->data)());
  else   (((::std::vector<HcalGain>*)o)->data)();
}

static  void method_6988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalGain>*)o)->data)());
  else   (((const ::std::vector<HcalGain>*)o)->data)();
}

static  void method_6989( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalGain>*)o)->push_back)(*(const ::HcalGain*)arg[0]);
}

static  void method_6990( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalGain>*)o)->pop_back)();
}

static  void method_6991( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >)((((::std::vector<HcalGain>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >*)arg[0],
    *(const ::HcalGain*)arg[1]));
  else   (((::std::vector<HcalGain>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >*)arg[0],
    *(const ::HcalGain*)arg[1]);
}

static  void method_6992( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalGain>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalGain*)arg[2]);
}

static  void method_6993( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >)((((::std::vector<HcalGain>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >*)arg[0]));
  else   (((::std::vector<HcalGain>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >*)arg[0]);
}

static  void method_6994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >)((((::std::vector<HcalGain>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >*)arg[1]));
  else   (((::std::vector<HcalGain>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalGain*,std::vector<HcalGain> >*)arg[1]);
}

static  void method_6995( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalGain>*)o)->swap)(*(::std::vector<HcalGain>*)arg[0]);
}

static  void method_6996( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalGain>*)o)->clear)();
}

static void method_newdel_1873( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalGain> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalGain> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalGain> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalGain> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalGain> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x167( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalGain,std::allocator<HcalGain> >")), ::Reflex::BaseOffset< ::std::vector<HcalGain>,::std::_Vector_base<HcalGain,std::allocator<HcalGain> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x168( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalGain> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalGain> >::Generate();
}

//------Dictionary for class vector<HcalGain,std::allocator<HcalGain> > -------------------------------
void __std__vector_HcalGain__db_datamem(Reflex::Class*);
void __std__vector_HcalGain__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalGain__datamem_bld(&__std__vector_HcalGain__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalGain__funcmem_bld(&__std__vector_HcalGain__db_funcmem);
void __std__vector_HcalGain__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalGain>"), typeid(::std::vector<HcalGain>), sizeof(::std::vector<HcalGain>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1820, ::Reflex::BaseOffset< ::std::vector<HcalGain>, ::std::_Vector_base<HcalGain,std::allocator<HcalGain> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1357, Reflex::Literal("std::vector<HcalGain>::_Alloc_value_type"))
  .AddTypedef(type_1820, Reflex::Literal("std::vector<HcalGain>::_Base"))
  .AddTypedef(type_2161, Reflex::Literal("std::vector<HcalGain>::_Tp_alloc_type"))
  .AddTypedef(type_3915, Reflex::Literal("std::vector<HcalGain>::_Alloc_traits"))
  .AddTypedef(type_1357, Reflex::Literal("std::vector<HcalGain>::value_type"))
  .AddTypedef(type_5260, Reflex::Literal("std::vector<HcalGain>::pointer"))
  .AddTypedef(type_6944, Reflex::Literal("std::vector<HcalGain>::const_pointer"))
  .AddTypedef(type_6946, Reflex::Literal("std::vector<HcalGain>::reference"))
  .AddTypedef(type_6948, Reflex::Literal("std::vector<HcalGain>::const_reference"))
  .AddTypedef(type_3851, Reflex::Literal("std::vector<HcalGain>::iterator"))
  .AddTypedef(type_3852, Reflex::Literal("std::vector<HcalGain>::const_iterator"))
  .AddTypedef(type_2326, Reflex::Literal("std::vector<HcalGain>::const_reverse_iterator"))
  .AddTypedef(type_2327, Reflex::Literal("std::vector<HcalGain>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalGain>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalGain>::difference_type"))
  .AddTypedef(type_2161, Reflex::Literal("std::vector<HcalGain>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6957, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12785), Reflex::Literal("vector"), constructor_6958, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_6948, type_12785), Reflex::Literal("vector"), constructor_6959, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12907), Reflex::Literal("vector"), constructor_6960, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6961, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1873, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x167, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalGain__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalGain,std::allocator<HcalGain> > -------------------
void __std__vector_HcalGain__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalGain,std::allocator<HcalGain> > -------------------
void __std__vector_HcalGain__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12908, type_12907), Reflex::Literal("operator="), operator_6962, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_6948), Reflex::Literal("assign"), method_6963, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3851), Reflex::Literal("begin"), method_6964, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3852), Reflex::Literal("begin"), method_6965, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3851), Reflex::Literal("end"), method_6966, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3852), Reflex::Literal("end"), method_6967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_6972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_6973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1357), Reflex::Literal("resize"), method_6974, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_6975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_6976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_6977, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6946, type_2122), Reflex::Literal("operator[]"), operator_6978, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6948, type_2122), Reflex::Literal("operator[]"), operator_6979, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6946, type_2122), Reflex::Literal("at"), method_6981, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6948, type_2122), Reflex::Literal("at"), method_6982, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6946), Reflex::Literal("front"), method_6983, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6948), Reflex::Literal("front"), method_6984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6946), Reflex::Literal("back"), method_6985, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6948), Reflex::Literal("back"), method_6986, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5260), Reflex::Literal("data"), method_6987, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6944), Reflex::Literal("data"), method_6988, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_6948), Reflex::Literal("push_back"), method_6989, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_6990, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3851, type_3851, type_6948), Reflex::Literal("insert"), method_6991, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3851, type_2122, type_6948), Reflex::Literal("insert"), method_6992, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3851, type_3851), Reflex::Literal("erase"), method_6993, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3851, type_3851, type_3851), Reflex::Literal("erase"), method_6994, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12908), Reflex::Literal("swap"), method_6995, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_6996, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalPedestalWidth,std::allocator<HcalPedestalWidth> > -------------------------------
static void constructor_7022( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestalWidth>();
  else ::new(mem) ::std::vector<HcalPedestalWidth>();
}

static void constructor_7023( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestalWidth>(*(const ::std::allocator<HcalPedestalWidth>*)arg[0]);
  else ::new(mem) ::std::vector<HcalPedestalWidth>(*(const ::std::allocator<HcalPedestalWidth>*)arg[0]);
}

static void constructor_7024( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestalWidth>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalPedestalWidth>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestalWidth>(*(::std::size_t*)arg[0],
      *(const ::HcalPedestalWidth*)arg[1]);
  else ::new(mem) ::std::vector<HcalPedestalWidth>(*(::std::size_t*)arg[0],
      *(const ::HcalPedestalWidth*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestalWidth>(*(::std::size_t*)arg[0],
      *(const ::HcalPedestalWidth*)arg[1],
      *(const ::std::allocator<HcalPedestalWidth>*)arg[2]);
  else ::new(mem) ::std::vector<HcalPedestalWidth>(*(::std::size_t*)arg[0],
      *(const ::HcalPedestalWidth*)arg[1],
      *(const ::std::allocator<HcalPedestalWidth>*)arg[2]);
  }
}

static void constructor_7025( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestalWidth>(*(const ::std::vector<HcalPedestalWidth>*)arg[0]);
  else ::new(mem) ::std::vector<HcalPedestalWidth>(*(const ::std::vector<HcalPedestalWidth>*)arg[0]);
}

static void destructor_7026(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalPedestalWidth>*)o)->::std::vector<HcalPedestalWidth>::~vector)();
}
static  void operator_7027( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPedestalWidth>*)o)->operator=)(*(const ::std::vector<HcalPedestalWidth>*)arg[0]);
  else   (((::std::vector<HcalPedestalWidth>*)o)->operator=)(*(const ::std::vector<HcalPedestalWidth>*)arg[0]);
}

static  void method_7028( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPedestalWidth>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalPedestalWidth*)arg[1]);
}

static  void method_7029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >)((((::std::vector<HcalPedestalWidth>*)o)->begin)());
  else   (((::std::vector<HcalPedestalWidth>*)o)->begin)();
}

static  void method_7030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalPedestalWidth*,std::vector<HcalPedestalWidth> >)((((const ::std::vector<HcalPedestalWidth>*)o)->begin)());
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->begin)();
}

static  void method_7031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >)((((::std::vector<HcalPedestalWidth>*)o)->end)());
  else   (((::std::vector<HcalPedestalWidth>*)o)->end)();
}

static  void method_7032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalPedestalWidth*,std::vector<HcalPedestalWidth> >)((((const ::std::vector<HcalPedestalWidth>*)o)->end)());
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->end)();
}

static  void method_7037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalPedestalWidth>*)o)->size)());
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->size)();
}

static  void method_7038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalPedestalWidth>*)o)->max_size)());
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->max_size)();
}

static  void method_7039( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalPedestalWidth>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalPedestalWidth>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalPedestalWidth*)arg[1]);
  }
}

static  void method_7040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalPedestalWidth>*)o)->capacity)());
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->capacity)();
}

static  void method_7041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalPedestalWidth>*)o)->empty)());
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->empty)();
}

static  void method_7042( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPedestalWidth>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_7043( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPedestalWidth>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalPedestalWidth>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_7044( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPedestalWidth>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_7046( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPedestalWidth>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalPedestalWidth>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPedestalWidth>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPedestalWidth>*)o)->front)();
  else   (((::std::vector<HcalPedestalWidth>*)o)->front)();
}

static  void method_7049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPedestalWidth>*)o)->front)();
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->front)();
}

static  void method_7050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPedestalWidth>*)o)->back)();
  else   (((::std::vector<HcalPedestalWidth>*)o)->back)();
}

static  void method_7051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPedestalWidth>*)o)->back)();
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->back)();
}

static  void method_7052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalPedestalWidth>*)o)->data)());
  else   (((::std::vector<HcalPedestalWidth>*)o)->data)();
}

static  void method_7053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalPedestalWidth>*)o)->data)());
  else   (((const ::std::vector<HcalPedestalWidth>*)o)->data)();
}

static  void method_7054( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPedestalWidth>*)o)->push_back)(*(const ::HcalPedestalWidth*)arg[0]);
}

static  void method_7055( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalPedestalWidth>*)o)->pop_back)();
}

static  void method_7056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >)((((::std::vector<HcalPedestalWidth>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >*)arg[0],
    *(const ::HcalPedestalWidth*)arg[1]));
  else   (((::std::vector<HcalPedestalWidth>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >*)arg[0],
    *(const ::HcalPedestalWidth*)arg[1]);
}

static  void method_7057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPedestalWidth>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalPedestalWidth*)arg[2]);
}

static  void method_7058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >)((((::std::vector<HcalPedestalWidth>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >*)arg[0]));
  else   (((::std::vector<HcalPedestalWidth>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >*)arg[0]);
}

static  void method_7059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >)((((::std::vector<HcalPedestalWidth>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >*)arg[1]));
  else   (((::std::vector<HcalPedestalWidth>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalPedestalWidth*,std::vector<HcalPedestalWidth> >*)arg[1]);
}

static  void method_7060( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPedestalWidth>*)o)->swap)(*(::std::vector<HcalPedestalWidth>*)arg[0]);
}

static  void method_7061( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalPedestalWidth>*)o)->clear)();
}

static void method_newdel_1874( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPedestalWidth> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPedestalWidth> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPedestalWidth> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPedestalWidth> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPedestalWidth> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalPedestalWidth,std::allocator<HcalPedestalWidth> >")), ::Reflex::BaseOffset< ::std::vector<HcalPedestalWidth>,::std::_Vector_base<HcalPedestalWidth,std::allocator<HcalPedestalWidth> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x171( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalPedestalWidth> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalPedestalWidth> >::Generate();
}

//------Dictionary for class vector<HcalPedestalWidth,std::allocator<HcalPedestalWidth> > -------------------------------
void __std__vector_HcalPedestalWidth__db_datamem(Reflex::Class*);
void __std__vector_HcalPedestalWidth__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalPedestalWidth__datamem_bld(&__std__vector_HcalPedestalWidth__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalPedestalWidth__funcmem_bld(&__std__vector_HcalPedestalWidth__db_funcmem);
void __std__vector_HcalPedestalWidth__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalPedestalWidth>"), typeid(::std::vector<HcalPedestalWidth>), sizeof(::std::vector<HcalPedestalWidth>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1821, ::Reflex::BaseOffset< ::std::vector<HcalPedestalWidth>, ::std::_Vector_base<HcalPedestalWidth,std::allocator<HcalPedestalWidth> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_716, Reflex::Literal("std::vector<HcalPedestalWidth>::_Alloc_value_type"))
  .AddTypedef(type_1821, Reflex::Literal("std::vector<HcalPedestalWidth>::_Base"))
  .AddTypedef(type_2162, Reflex::Literal("std::vector<HcalPedestalWidth>::_Tp_alloc_type"))
  .AddTypedef(type_3916, Reflex::Literal("std::vector<HcalPedestalWidth>::_Alloc_traits"))
  .AddTypedef(type_716, Reflex::Literal("std::vector<HcalPedestalWidth>::value_type"))
  .AddTypedef(type_5279, Reflex::Literal("std::vector<HcalPedestalWidth>::pointer"))
  .AddTypedef(type_7009, Reflex::Literal("std::vector<HcalPedestalWidth>::const_pointer"))
  .AddTypedef(type_7011, Reflex::Literal("std::vector<HcalPedestalWidth>::reference"))
  .AddTypedef(type_7013, Reflex::Literal("std::vector<HcalPedestalWidth>::const_reference"))
  .AddTypedef(type_3853, Reflex::Literal("std::vector<HcalPedestalWidth>::iterator"))
  .AddTypedef(type_3854, Reflex::Literal("std::vector<HcalPedestalWidth>::const_iterator"))
  .AddTypedef(type_2328, Reflex::Literal("std::vector<HcalPedestalWidth>::const_reverse_iterator"))
  .AddTypedef(type_2329, Reflex::Literal("std::vector<HcalPedestalWidth>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalPedestalWidth>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalPedestalWidth>::difference_type"))
  .AddTypedef(type_2162, Reflex::Literal("std::vector<HcalPedestalWidth>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_7022, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12798), Reflex::Literal("vector"), constructor_7023, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_7013, type_12798), Reflex::Literal("vector"), constructor_7024, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12910), Reflex::Literal("vector"), constructor_7025, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_7026, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1874, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x171, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalPedestalWidth__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalPedestalWidth,std::allocator<HcalPedestalWidth> > -------------------
void __std__vector_HcalPedestalWidth__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalPedestalWidth,std::allocator<HcalPedestalWidth> > -------------------
void __std__vector_HcalPedestalWidth__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12911, type_12910), Reflex::Literal("operator="), operator_7027, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_7013), Reflex::Literal("assign"), method_7028, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3853), Reflex::Literal("begin"), method_7029, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3854), Reflex::Literal("begin"), method_7030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3853), Reflex::Literal("end"), method_7031, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3854), Reflex::Literal("end"), method_7032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_7037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_7038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_716), Reflex::Literal("resize"), method_7039, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_7040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_7041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_7042, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7011, type_2122), Reflex::Literal("operator[]"), operator_7043, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7013, type_2122), Reflex::Literal("operator[]"), operator_7044, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7011, type_2122), Reflex::Literal("at"), method_7046, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7013, type_2122), Reflex::Literal("at"), method_7047, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7011), Reflex::Literal("front"), method_7048, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7013), Reflex::Literal("front"), method_7049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7011), Reflex::Literal("back"), method_7050, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7013), Reflex::Literal("back"), method_7051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5279), Reflex::Literal("data"), method_7052, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7009), Reflex::Literal("data"), method_7053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_7013), Reflex::Literal("push_back"), method_7054, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_7055, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3853, type_3853, type_7013), Reflex::Literal("insert"), method_7056, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3853, type_2122, type_7013), Reflex::Literal("insert"), method_7057, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3853, type_3853), Reflex::Literal("erase"), method_7058, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3853, type_3853, type_3853), Reflex::Literal("erase"), method_7059, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12911), Reflex::Literal("swap"), method_7060, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_7061, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalPedestal,std::allocator<HcalPedestal> > -------------------------------
static void constructor_7087( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestal>();
  else ::new(mem) ::std::vector<HcalPedestal>();
}

static void constructor_7088( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestal>(*(const ::std::allocator<HcalPedestal>*)arg[0]);
  else ::new(mem) ::std::vector<HcalPedestal>(*(const ::std::allocator<HcalPedestal>*)arg[0]);
}

static void constructor_7089( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestal>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalPedestal>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestal>(*(::std::size_t*)arg[0],
      *(const ::HcalPedestal*)arg[1]);
  else ::new(mem) ::std::vector<HcalPedestal>(*(::std::size_t*)arg[0],
      *(const ::HcalPedestal*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestal>(*(::std::size_t*)arg[0],
      *(const ::HcalPedestal*)arg[1],
      *(const ::std::allocator<HcalPedestal>*)arg[2]);
  else ::new(mem) ::std::vector<HcalPedestal>(*(::std::size_t*)arg[0],
      *(const ::HcalPedestal*)arg[1],
      *(const ::std::allocator<HcalPedestal>*)arg[2]);
  }
}

static void constructor_7090( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalPedestal>(*(const ::std::vector<HcalPedestal>*)arg[0]);
  else ::new(mem) ::std::vector<HcalPedestal>(*(const ::std::vector<HcalPedestal>*)arg[0]);
}

static void destructor_7091(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalPedestal>*)o)->::std::vector<HcalPedestal>::~vector)();
}
static  void operator_7092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPedestal>*)o)->operator=)(*(const ::std::vector<HcalPedestal>*)arg[0]);
  else   (((::std::vector<HcalPedestal>*)o)->operator=)(*(const ::std::vector<HcalPedestal>*)arg[0]);
}

static  void method_7093( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPedestal>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalPedestal*)arg[1]);
}

static  void method_7094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >)((((::std::vector<HcalPedestal>*)o)->begin)());
  else   (((::std::vector<HcalPedestal>*)o)->begin)();
}

static  void method_7095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalPedestal*,std::vector<HcalPedestal> >)((((const ::std::vector<HcalPedestal>*)o)->begin)());
  else   (((const ::std::vector<HcalPedestal>*)o)->begin)();
}

static  void method_7096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >)((((::std::vector<HcalPedestal>*)o)->end)());
  else   (((::std::vector<HcalPedestal>*)o)->end)();
}

static  void method_7097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalPedestal*,std::vector<HcalPedestal> >)((((const ::std::vector<HcalPedestal>*)o)->end)());
  else   (((const ::std::vector<HcalPedestal>*)o)->end)();
}

static  void method_7102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalPedestal>*)o)->size)());
  else   (((const ::std::vector<HcalPedestal>*)o)->size)();
}

static  void method_7103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalPedestal>*)o)->max_size)());
  else   (((const ::std::vector<HcalPedestal>*)o)->max_size)();
}

static  void method_7104( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalPedestal>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalPedestal>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalPedestal*)arg[1]);
  }
}

static  void method_7105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalPedestal>*)o)->capacity)());
  else   (((const ::std::vector<HcalPedestal>*)o)->capacity)();
}

static  void method_7106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalPedestal>*)o)->empty)());
  else   (((const ::std::vector<HcalPedestal>*)o)->empty)();
}

static  void method_7107( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPedestal>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_7108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPedestal>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalPedestal>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_7109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPedestal>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalPedestal>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_7111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPedestal>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalPedestal>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPedestal>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalPedestal>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPedestal>*)o)->front)();
  else   (((::std::vector<HcalPedestal>*)o)->front)();
}

static  void method_7114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPedestal>*)o)->front)();
  else   (((const ::std::vector<HcalPedestal>*)o)->front)();
}

static  void method_7115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalPedestal>*)o)->back)();
  else   (((::std::vector<HcalPedestal>*)o)->back)();
}

static  void method_7116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalPedestal>*)o)->back)();
  else   (((const ::std::vector<HcalPedestal>*)o)->back)();
}

static  void method_7117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalPedestal>*)o)->data)());
  else   (((::std::vector<HcalPedestal>*)o)->data)();
}

static  void method_7118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalPedestal>*)o)->data)());
  else   (((const ::std::vector<HcalPedestal>*)o)->data)();
}

static  void method_7119( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPedestal>*)o)->push_back)(*(const ::HcalPedestal*)arg[0]);
}

static  void method_7120( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalPedestal>*)o)->pop_back)();
}

static  void method_7121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >)((((::std::vector<HcalPedestal>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >*)arg[0],
    *(const ::HcalPedestal*)arg[1]));
  else   (((::std::vector<HcalPedestal>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >*)arg[0],
    *(const ::HcalPedestal*)arg[1]);
}

static  void method_7122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPedestal>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalPedestal*)arg[2]);
}

static  void method_7123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >)((((::std::vector<HcalPedestal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >*)arg[0]));
  else   (((::std::vector<HcalPedestal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >*)arg[0]);
}

static  void method_7124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >)((((::std::vector<HcalPedestal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >*)arg[1]));
  else   (((::std::vector<HcalPedestal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalPedestal*,std::vector<HcalPedestal> >*)arg[1]);
}

static  void method_7125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalPedestal>*)o)->swap)(*(::std::vector<HcalPedestal>*)arg[0]);
}

static  void method_7126( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalPedestal>*)o)->clear)();
}

static void method_newdel_1875( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPedestal> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPedestal> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPedestal> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPedestal> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalPedestal> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x173( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalPedestal,std::allocator<HcalPedestal> >")), ::Reflex::BaseOffset< ::std::vector<HcalPedestal>,::std::_Vector_base<HcalPedestal,std::allocator<HcalPedestal> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x174( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalPedestal> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalPedestal> >::Generate();
}

//------Dictionary for class vector<HcalPedestal,std::allocator<HcalPedestal> > -------------------------------
void __std__vector_HcalPedestal__db_datamem(Reflex::Class*);
void __std__vector_HcalPedestal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalPedestal__datamem_bld(&__std__vector_HcalPedestal__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalPedestal__funcmem_bld(&__std__vector_HcalPedestal__db_funcmem);
void __std__vector_HcalPedestal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalPedestal>"), typeid(::std::vector<HcalPedestal>), sizeof(::std::vector<HcalPedestal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1822, ::Reflex::BaseOffset< ::std::vector<HcalPedestal>, ::std::_Vector_base<HcalPedestal,std::allocator<HcalPedestal> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1230, Reflex::Literal("std::vector<HcalPedestal>::_Alloc_value_type"))
  .AddTypedef(type_1822, Reflex::Literal("std::vector<HcalPedestal>::_Base"))
  .AddTypedef(type_2163, Reflex::Literal("std::vector<HcalPedestal>::_Tp_alloc_type"))
  .AddTypedef(type_3917, Reflex::Literal("std::vector<HcalPedestal>::_Alloc_traits"))
  .AddTypedef(type_1230, Reflex::Literal("std::vector<HcalPedestal>::value_type"))
  .AddTypedef(type_5298, Reflex::Literal("std::vector<HcalPedestal>::pointer"))
  .AddTypedef(type_7074, Reflex::Literal("std::vector<HcalPedestal>::const_pointer"))
  .AddTypedef(type_7076, Reflex::Literal("std::vector<HcalPedestal>::reference"))
  .AddTypedef(type_7078, Reflex::Literal("std::vector<HcalPedestal>::const_reference"))
  .AddTypedef(type_3855, Reflex::Literal("std::vector<HcalPedestal>::iterator"))
  .AddTypedef(type_3856, Reflex::Literal("std::vector<HcalPedestal>::const_iterator"))
  .AddTypedef(type_2330, Reflex::Literal("std::vector<HcalPedestal>::const_reverse_iterator"))
  .AddTypedef(type_2331, Reflex::Literal("std::vector<HcalPedestal>::reverse_iterator"))
  .AddTypedef(type_2122, Reflex::Literal("std::vector<HcalPedestal>::size_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<HcalPedestal>::difference_type"))
  .AddTypedef(type_2163, Reflex::Literal("std::vector<HcalPedestal>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_7087, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12811), Reflex::Literal("vector"), constructor_7088, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2122, type_7078, type_12811), Reflex::Literal("vector"), constructor_7089, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12913), Reflex::Literal("vector"), constructor_7090, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_7091, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1875, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalPedestal__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalPedestal,std::allocator<HcalPedestal> > -------------------
void __std__vector_HcalPedestal__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalPedestal,std::allocator<HcalPedestal> > -------------------
void __std__vector_HcalPedestal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12914, type_12913), Reflex::Literal("operator="), operator_7092, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_7078), Reflex::Literal("assign"), method_7093, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3855), Reflex::Literal("begin"), method_7094, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3856), Reflex::Literal("begin"), method_7095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3855), Reflex::Literal("end"), method_7096, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3856), Reflex::Literal("end"), method_7097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("size"), method_7102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("max_size"), method_7103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122, type_1230), Reflex::Literal("resize"), method_7104, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2122), Reflex::Literal("capacity"), method_7105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2461), Reflex::Literal("empty"), method_7106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_2122), Reflex::Literal("reserve"), method_7107, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7076, type_2122), Reflex::Literal("operator[]"), operator_7108, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7078, type_2122), Reflex::Literal("operator[]"), operator_7109, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7076, type_2122), Reflex::Literal("at"), method_7111, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7078, type_2122), Reflex::Literal("at"), method_7112, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7076), Reflex::Literal("front"), method_7113, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7078), Reflex::Literal("front"), method_7114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7076), Reflex::Literal("back"), method_7115, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7078), Reflex::Literal("back"), method_7116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5298), Reflex::Literal("data"), method_7117, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7074), Reflex::Literal("data"), method_7118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_7078), Reflex::Literal("push_back"), method_7119, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("pop_back"), method_7120, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3855, type_3855, type_7078), Reflex::Literal("insert"), method_7121, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_3855, type_2122, type_7078), Reflex::Literal("insert"), method_7122, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3855, type_3855), Reflex::Literal("erase"), method_7123, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3855, type_3855, type_3855), Reflex::Literal("erase"), method_7124, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549, type_12914), Reflex::Literal("swap"), method_7125, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("clear"), method_7126, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class NonChannelData -------------------------------
static void destructor_11968(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalLutMetadata::NonChannelData*)o)->::HcalLutMetadata::NonChannelData::~NonChannelData)();
}
static  void operator_11969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalLutMetadata::NonChannelData*)o)->operator=)(*(const ::HcalLutMetadata::NonChannelData*)arg[0]);
  else   (((::HcalLutMetadata::NonChannelData*)o)->operator=)(*(const ::HcalLutMetadata::NonChannelData*)arg[0]);
}

static void constructor_11970( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLutMetadata::NonChannelData(*(const ::HcalLutMetadata::NonChannelData*)arg[0]);
  else ::new(mem) ::HcalLutMetadata::NonChannelData(*(const ::HcalLutMetadata::NonChannelData*)arg[0]);
}

static void constructor_11971( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalLutMetadata::NonChannelData();
  else ::new(mem) ::HcalLutMetadata::NonChannelData();
}

static void method_newdel_4282( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalLutMetadata::NonChannelData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalLutMetadata::NonChannelData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalLutMetadata::NonChannelData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalLutMetadata::NonChannelData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalLutMetadata::NonChannelData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class NonChannelData -------------------------------
void __HcalLutMetadata__NonChannelData_db_datamem(Reflex::Class*);
void __HcalLutMetadata__NonChannelData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalLutMetadata__NonChannelData_datamem_bld(&__HcalLutMetadata__NonChannelData_db_datamem);
Reflex::GenreflexMemberBuilder __HcalLutMetadata__NonChannelData_funcmem_bld(&__HcalLutMetadata__NonChannelData_db_funcmem);
void __HcalLutMetadata__NonChannelData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalLutMetadata::NonChannelData"), typeid(::HcalLutMetadata::NonChannelData), sizeof(::HcalLutMetadata::NonChannelData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NonChannelData"), destructor_11968, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13813, type_13814), Reflex::Literal("operator="), operator_11969, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13814), Reflex::Literal("NonChannelData"), constructor_11970, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("NonChannelData"), constructor_11971, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4282, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalLutMetadata__NonChannelData_datamem_bld);
}

//------Delayed data member builder for class NonChannelData -------------------
void __HcalLutMetadata__NonChannelData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1181, Reflex::Literal("mRctLsb"), OffsetOf(__shadow__::__HcalLutMetadata__NonChannelData, mRctLsb), ::Reflex::PROTECTED)
  .AddDataMember(type_1181, Reflex::Literal("mNominalGain"), OffsetOf(__shadow__::__HcalLutMetadata__NonChannelData, mNominalGain), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class NonChannelData -------------------
void __HcalLutMetadata__NonChannelData_db_funcmem(Reflex::Class*) {

}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __HcalLongRecoParams_dict(); 
      __HcalTimeCorr_dict(); 
      __HcalValidationCorr_dict(); 
      __HcalTimingParam_dict(); 
      __HcalMCParams_dict(); 
      __HcalGainWidth_dict(); 
      __HcalElectronicsMap_dict(); 
      __HcalQIECoder_dict(); 
      __HcalCondObjectContainer_HcalTimingParam__dict(); 
      __HcalFlagHFDigiTimeParam_dict(); 
      __HcalCondObjectContainer_HcalFlagHFDigiTimeParam__dict(); 
      __HcalMCParam_dict(); 
      __HcalCondObjectContainer_HcalMCParam__dict(); 
      __HcalLongRecoParam_dict(); 
      __HcalCondObjectContainer_HcalLongRecoParam__dict(); 
      __HcalRecoParam_dict(); 
      __HcalCondObjectContainer_HcalRecoParam__dict(); 
      __HcalLutMetadatum_dict(); 
      __HcalCondObjectContainer_HcalLutMetadatum__dict(); 
      __HcalCondObjectContainer_HcalValidationCorr__dict(); 
      __HcalPFCorr_dict(); 
      __HcalCondObjectContainer_HcalPFCorr__dict(); 
      __HcalLUTCorr_dict(); 
      __HcalCondObjectContainer_HcalLUTCorr__dict(); 
      __HcalCondObjectContainer_HcalTimeCorr__dict(); 
      __HcalL1TriggerObject_dict(); 
      __HcalCondObjectContainer_HcalL1TriggerObject__dict(); 
      __HcalRespCorr_dict(); 
      __HcalCondObjectContainer_HcalRespCorr__dict(); 
      __HcalZSThreshold_dict(); 
      __HcalCondObjectContainer_HcalZSThreshold__dict(); 
      __HcalChannelStatus_dict(); 
      __HcalCondObjectContainer_HcalChannelStatus__dict(); 
      __HcalCalibrationQIECoder_dict(); 
      __HcalCondObjectContainer_HcalCalibrationQIECoder__dict(); 
      __HcalCondObjectContainer_HcalQIECoder__dict(); 
      __HcalCondObjectContainer_HcalGainWidth__dict(); 
      __HcalGain_dict(); 
      __HcalCondObjectContainer_HcalGain__dict(); 
      __HcalPedestalWidth_dict(); 
      __HcalCondObjectContainer_HcalPedestalWidth__dict(); 
      __HcalPedestal_dict(); 
      __HcalCondObjectContainer_HcalPedestal__dict(); 
      __HcalDcsMap_dict(); 
      __HcalPedestalWidths_dict(); 
      __HcalL1TriggerObjects_dict(); 
      __HcalRecoParams_dict(); 
      __HcalCovarianceMatrix_dict(); 
      __HcalCholeskyMatrices_dict(); 
      __HcalCondObjectContainerBase_dict(); 
      __HcalDcsValues_dict(); 
      __HcalZSThresholds_dict(); 
      __HcalGains_dict(); 
      __HcalChannelQuality_dict(); 
      __HcalPFCorrs_dict(); 
      __HcalFlagHFDigiTimeParams_dict(); 
      __HcalLUTCorrs_dict(); 
      __HcalValidationCorrs_dict(); 
      __HcalGainWidths_dict(); 
      __HcalCalibrationQIEData_dict(); 
      __HcalPedestals_dict(); 
      __HcalTimeCorrs_dict(); 
      __HcalDcsValue_dict(); 
      __HcalQIEData_dict(); 
      __HcalCovarianceMatrices_dict(); 
      __HcalLutMetadata_dict(); 
      __HcalRespCorrs_dict(); 
      __HcalCholeskyMatrix_dict(); 
      __HcalTimingParams_dict(); 
      __std__vector_HcalTimingParam__dict(); 
      __std__vector_HcalFlagHFDigiTimeParam__dict(); 
      __std__vector_HcalMCParam__dict(); 
      __std__vector_HcalRecoParam__dict(); 
      __std__vector_HcalLongRecoParam__dict(); 
      __HcalDcsMap__Item_dict(); 
      __std__vector_HcalDcsMap__Item__dict(); 
      __std__vector_HcalDcsValue__dict(); 
      __std__vector_HcalCovarianceMatrix__dict(); 
      __std__vector_HcalCholeskyMatrix__dict(); 
      __std__vector_HcalLutMetadatum__dict(); 
      __std__vector_HcalValidationCorr__dict(); 
      __std__vector_HcalTimeCorr__dict(); 
      __std__vector_HcalL1TriggerObject__dict(); 
      __std__vector_HcalPFCorr__dict(); 
      __std__vector_HcalLUTCorr__dict(); 
      __std__vector_HcalRespCorr__dict(); 
      __std__vector_HcalZSThreshold__dict(); 
      __std__vector_HcalChannelStatus__dict(); 
      __HcalElectronicsMap__TriggerItem_dict(); 
      __std__vector_HcalElectronicsMap__TriggerItem__dict(); 
      __HcalElectronicsMap__PrecisionItem_dict(); 
      __std__vector_HcalElectronicsMap__PrecisionItem__dict(); 
      __std__vector_HcalCalibrationQIECoder__dict(); 
      __std__vector_HcalQIECoder__dict(); 
      __std__vector_HcalGainWidth__dict(); 
      __std__vector_HcalGain__dict(); 
      __std__vector_HcalPedestalWidth__dict(); 
      __std__vector_HcalPedestal__dict(); 
      __HcalLutMetadata__NonChannelData_dict(); 
    }
    ~Dictionaries() {
      type_4.Unload(); // class HcalLongRecoParams 
      type_27.Unload(); // class HcalTimeCorr 
      type_50.Unload(); // class HcalValidationCorr 
      type_103.Unload(); // class HcalTimingParam 
      type_110.Unload(); // class HcalMCParams 
      type_139.Unload(); // class HcalGainWidth 
      type_159.Unload(); // class HcalElectronicsMap 
      type_172.Unload(); // class HcalQIECoder 
      type_173.Unload(); // class HcalCondObjectContainer<HcalTimingParam> 
      type_1145.Unload(); // class HcalFlagHFDigiTimeParam 
      type_174.Unload(); // class HcalCondObjectContainer<HcalFlagHFDigiTimeParam> 
      type_1074.Unload(); // class HcalMCParam 
      type_175.Unload(); // class HcalCondObjectContainer<HcalMCParam> 
      type_1748.Unload(); // class HcalLongRecoParam 
      type_176.Unload(); // class HcalCondObjectContainer<HcalLongRecoParam> 
      type_745.Unload(); // class HcalRecoParam 
      type_177.Unload(); // class HcalCondObjectContainer<HcalRecoParam> 
      type_1624.Unload(); // class HcalLutMetadatum 
      type_178.Unload(); // class HcalCondObjectContainer<HcalLutMetadatum> 
      type_179.Unload(); // class HcalCondObjectContainer<HcalValidationCorr> 
      type_1530.Unload(); // class HcalPFCorr 
      type_180.Unload(); // class HcalCondObjectContainer<HcalPFCorr> 
      type_1511.Unload(); // class HcalLUTCorr 
      type_181.Unload(); // class HcalCondObjectContainer<HcalLUTCorr> 
      type_182.Unload(); // class HcalCondObjectContainer<HcalTimeCorr> 
      type_491.Unload(); // class HcalL1TriggerObject 
      type_183.Unload(); // class HcalCondObjectContainer<HcalL1TriggerObject> 
      type_231.Unload(); // class HcalRespCorr 
      type_184.Unload(); // class HcalCondObjectContainer<HcalRespCorr> 
      type_530.Unload(); // class HcalZSThreshold 
      type_185.Unload(); // class HcalCondObjectContainer<HcalZSThreshold> 
      type_1391.Unload(); // class HcalChannelStatus 
      type_186.Unload(); // class HcalCondObjectContainer<HcalChannelStatus> 
      type_1252.Unload(); // class HcalCalibrationQIECoder 
      type_187.Unload(); // class HcalCondObjectContainer<HcalCalibrationQIECoder> 
      type_188.Unload(); // class HcalCondObjectContainer<HcalQIECoder> 
      type_189.Unload(); // class HcalCondObjectContainer<HcalGainWidth> 
      type_1357.Unload(); // class HcalGain 
      type_190.Unload(); // class HcalCondObjectContainer<HcalGain> 
      type_716.Unload(); // class HcalPedestalWidth 
      type_191.Unload(); // class HcalCondObjectContainer<HcalPedestalWidth> 
      type_1230.Unload(); // class HcalPedestal 
      type_192.Unload(); // class HcalCondObjectContainer<HcalPedestal> 
      type_219.Unload(); // class HcalDcsMap 
      type_278.Unload(); // class HcalPedestalWidths 
      type_300.Unload(); // class HcalL1TriggerObjects 
      type_309.Unload(); // class HcalRecoParams 
      type_333.Unload(); // class HcalCovarianceMatrix 
      type_506.Unload(); // class HcalCholeskyMatrices 
      type_524.Unload(); // class HcalCondObjectContainerBase 
      type_656.Unload(); // class HcalDcsValues 
      type_753.Unload(); // class HcalZSThresholds 
      type_804.Unload(); // class HcalGains 
      type_868.Unload(); // class HcalChannelQuality 
      type_900.Unload(); // class HcalPFCorrs 
      type_1120.Unload(); // class HcalFlagHFDigiTimeParams 
      type_1162.Unload(); // class HcalLUTCorrs 
      type_1187.Unload(); // class HcalValidationCorrs 
      type_1297.Unload(); // class HcalGainWidths 
      type_1300.Unload(); // class HcalCalibrationQIEData 
      type_1306.Unload(); // class HcalPedestals 
      type_1350.Unload(); // class HcalTimeCorrs 
      type_1419.Unload(); // class HcalDcsValue 
      type_1432.Unload(); // class HcalQIEData 
      type_1469.Unload(); // class HcalCovarianceMatrices 
      type_1491.Unload(); // class HcalLutMetadata 
      type_1567.Unload(); // class HcalRespCorrs 
      type_1671.Unload(); // class HcalCholeskyMatrix 
      type_1729.Unload(); // class HcalTimingParams 
      type_1849.Unload(); // class std::vector<HcalTimingParam> 
      type_1850.Unload(); // class std::vector<HcalFlagHFDigiTimeParam> 
      type_1851.Unload(); // class std::vector<HcalMCParam> 
      type_1852.Unload(); // class std::vector<HcalRecoParam> 
      type_1854.Unload(); // class std::vector<HcalLongRecoParam> 
      type_3088.Unload(); // class HcalDcsMap::Item 
      type_1855.Unload(); // class std::vector<HcalDcsMap::Item> 
      type_1856.Unload(); // class std::vector<HcalDcsValue> 
      type_1857.Unload(); // class std::vector<HcalCovarianceMatrix> 
      type_1858.Unload(); // class std::vector<HcalCholeskyMatrix> 
      type_1859.Unload(); // class std::vector<HcalLutMetadatum> 
      type_1860.Unload(); // class std::vector<HcalValidationCorr> 
      type_1861.Unload(); // class std::vector<HcalTimeCorr> 
      type_1862.Unload(); // class std::vector<HcalL1TriggerObject> 
      type_1863.Unload(); // class std::vector<HcalPFCorr> 
      type_1864.Unload(); // class std::vector<HcalLUTCorr> 
      type_1865.Unload(); // class std::vector<HcalRespCorr> 
      type_1866.Unload(); // class std::vector<HcalZSThreshold> 
      type_1867.Unload(); // class std::vector<HcalChannelStatus> 
      type_2577.Unload(); // class HcalElectronicsMap::TriggerItem 
      type_1868.Unload(); // class std::vector<HcalElectronicsMap::TriggerItem> 
      type_2576.Unload(); // class HcalElectronicsMap::PrecisionItem 
      type_1869.Unload(); // class std::vector<HcalElectronicsMap::PrecisionItem> 
      type_1870.Unload(); // class std::vector<HcalCalibrationQIECoder> 
      type_1871.Unload(); // class std::vector<HcalQIECoder> 
      type_1872.Unload(); // class std::vector<HcalGainWidth> 
      type_1873.Unload(); // class std::vector<HcalGain> 
      type_1874.Unload(); // class std::vector<HcalPedestalWidth> 
      type_1875.Unload(); // class std::vector<HcalPedestal> 
      type_4282.Unload(); // class HcalLutMetadata::NonChannelData 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
