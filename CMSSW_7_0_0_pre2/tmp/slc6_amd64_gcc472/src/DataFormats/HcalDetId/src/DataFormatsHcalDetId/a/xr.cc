// Generated at Fri Feb 20 10:30:14 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc472/external/gccxml/20110825-cms4/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc472/external/gccxml/20110825-cms4/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc472/external/gccxml/20110825-cms4/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.7.2"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='7' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gccxml/20110825-cms4/share/gccxml-0.9/GCC/4.7" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc472/external/gccxml/20110825-cms4/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.7.2
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/HcalDetId/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_29 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_63 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_738 = ::Reflex::TypeBuilder(Reflex::Literal("DetId"));
  ::Reflex::Type type_1493 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1630 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_500 = ::Reflex::TypeBuilder(Reflex::Literal("HcalDetId"));
  ::Reflex::Type type_70 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_369 = ::Reflex::TypeBuilder(Reflex::Literal("HcalDcsDetId"));
  ::Reflex::Type type_545 = ::Reflex::TypeBuilder(Reflex::Literal("HcalZDCDetId"));
  ::Reflex::Type type_23 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_103 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCalibDetId"));
  ::Reflex::Type type_1046 = ::Reflex::TypeBuilder(Reflex::Literal("HcalOtherDetId"));
  ::Reflex::Type type_335 = ::Reflex::TypeBuilder(Reflex::Literal("HcalCastorDetId"));
  ::Reflex::Type type_1079 = ::Reflex::TypeBuilder(Reflex::Literal("HcalFrontEndId"));
  ::Reflex::Type type_1025 = ::Reflex::TypeBuilder(Reflex::Literal("HcalElectronicsId"));
  ::Reflex::Type type_797 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HcalSubdetector"));
  ::Reflex::Type type_774 = ::Reflex::TypeBuilder(Reflex::Literal("CastorElectronicsId"));
  ::Reflex::Type type_1040 = ::Reflex::TypeBuilder(Reflex::Literal("HcalTrigTowerDetId"));
  ::Reflex::Type type_1182 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_368 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HcalOtherSubdetector"));
  ::Reflex::Type type_1804 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HcalDcsDetId::DcsType"));
  ::Reflex::Type type_1876 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HcalZDCDetId::Section"));
  ::Reflex::Type type_1157 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalFrontEndId>"));
  ::Reflex::Type type_1764 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HcalCastorDetId::Section"));
  ::Reflex::Type type_1262 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalFrontEndId>"));
  ::Reflex::Type type_1158 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HcalElectronicsId>"));
  ::Reflex::Type type_1565 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HcalCalibDetId::CalibDetType"));
  ::Reflex::Type type_1156 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<CastorElectronicsId>"));
  ::Reflex::Type type_1263 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HcalElectronicsId>"));
  ::Reflex::Type type_1261 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<CastorElectronicsId>"));
  ::Reflex::Type type_1658 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalFrontEndId> >"));
  ::Reflex::Type type_1659 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HcalElectronicsId> >"));
  ::Reflex::Type type_1657 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<CastorElectronicsId> >"));
  ::Reflex::Type type_1378 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalFrontEndId,std::allocator<HcalFrontEndId> >"));
  ::Reflex::Type type_1379 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalElectronicsId,std::allocator<HcalElectronicsId> >"));
  ::Reflex::Type type_1701 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >"));
  ::Reflex::Type type_1377 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<CastorElectronicsId,std::allocator<CastorElectronicsId> >"));
  ::Reflex::Type type_1702 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalFrontEndId*,std::vector<HcalFrontEndId> >"));
  ::Reflex::Type type_1703 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >"));
  ::Reflex::Type type_1699 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >"));
  ::Reflex::Type type_1704 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HcalElectronicsId*,std::vector<HcalElectronicsId> >"));
  ::Reflex::Type type_1700 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const CastorElectronicsId*,std::vector<CastorElectronicsId> >"));
  ::Reflex::Type type_1328 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> > >"));
  ::Reflex::Type type_1327 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalFrontEndId*,std::vector<HcalFrontEndId> > >"));
  ::Reflex::Type type_1330 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> > >"));
  ::Reflex::Type type_1326 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> > >"));
  ::Reflex::Type type_1329 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HcalElectronicsId*,std::vector<HcalElectronicsId> > >"));
  ::Reflex::Type type_1325 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const CastorElectronicsId*,std::vector<CastorElectronicsId> > >"));
  ::Reflex::Type type_4056 = ::Reflex::ReferenceBuilder(type_103);
  ::Reflex::Type type_103c = ::Reflex::ConstBuilder(type_103);
  ::Reflex::Type type_2007 = ::Reflex::ReferenceBuilder(type_103c);
  ::Reflex::Type type_419 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_70);
  ::Reflex::Type type_738c = ::Reflex::ConstBuilder(type_738);
  ::Reflex::Type type_4057 = ::Reflex::ReferenceBuilder(type_738c);
  ::Reflex::Type type_1193 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_1182);
  ::Reflex::Type type_4411 = ::Reflex::ReferenceBuilder(type_335);
  ::Reflex::Type type_335c = ::Reflex::ConstBuilder(type_335);
  ::Reflex::Type type_2004 = ::Reflex::ReferenceBuilder(type_335c);
  ::Reflex::Type type_4419 = ::Reflex::ReferenceBuilder(type_369);
  ::Reflex::Type type_369c = ::Reflex::ConstBuilder(type_369);
  ::Reflex::Type type_2005 = ::Reflex::ReferenceBuilder(type_369c);
  ::Reflex::Type type_1193c = ::Reflex::ConstBuilder(type_1193);
  ::Reflex::Type type_2925 = ::Reflex::ReferenceBuilder(type_1193c);
  ::Reflex::Type type_500c = ::Reflex::ConstBuilder(type_500);
  ::Reflex::Type type_4439 = ::Reflex::ReferenceBuilder(type_500);
  ::Reflex::Type type_2009 = ::Reflex::ReferenceBuilder(type_500c);
  ::Reflex::Type type_4452 = ::Reflex::ReferenceBuilder(type_545);
  ::Reflex::Type type_545c = ::Reflex::ConstBuilder(type_545);
  ::Reflex::Type type_2006 = ::Reflex::ReferenceBuilder(type_545c);
  ::Reflex::Type type_2531 = ::Reflex::ReferenceBuilder(type_774);
  ::Reflex::Type type_774c = ::Reflex::ConstBuilder(type_774);
  ::Reflex::Type type_2003 = ::Reflex::ReferenceBuilder(type_774c);
  ::Reflex::Type type_2661 = ::Reflex::ReferenceBuilder(type_1025);
  ::Reflex::Type type_1025c = ::Reflex::ConstBuilder(type_1025);
  ::Reflex::Type type_2011 = ::Reflex::ReferenceBuilder(type_1025c);
  ::Reflex::Type type_1040c = ::Reflex::ConstBuilder(type_1040);
  ::Reflex::Type type_4549 = ::Reflex::ReferenceBuilder(type_1040);
  ::Reflex::Type type_2008 = ::Reflex::ReferenceBuilder(type_1040c);
  ::Reflex::Type type_4550 = ::Reflex::ReferenceBuilder(type_1046);
  ::Reflex::Type type_1046c = ::Reflex::ConstBuilder(type_1046);
  ::Reflex::Type type_4551 = ::Reflex::ReferenceBuilder(type_1046c);
  ::Reflex::Type type_2596 = ::Reflex::ReferenceBuilder(type_1079);
  ::Reflex::Type type_1079c = ::Reflex::ConstBuilder(type_1079);
  ::Reflex::Type type_2010 = ::Reflex::ReferenceBuilder(type_1079c);
  ::Reflex::Type type_2527 = ::Reflex::PointerBuilder(type_774);
  ::Reflex::Type type_2529 = ::Reflex::PointerBuilder(type_774c);
  ::Reflex::Type type_1322 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_23);
  ::Reflex::Type type_1281 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_63);
  ::Reflex::Type type_1261c = ::Reflex::ConstBuilder(type_1261);
  ::Reflex::Type type_4628 = ::Reflex::ReferenceBuilder(type_1261c);
  ::Reflex::Type type_1156c = ::Reflex::ConstBuilder(type_1156);
  ::Reflex::Type type_4629 = ::Reflex::ReferenceBuilder(type_1156c);
  ::Reflex::Type type_4630 = ::Reflex::ReferenceBuilder(type_1156);
  ::Reflex::Type type_2592 = ::Reflex::PointerBuilder(type_1079);
  ::Reflex::Type type_2594 = ::Reflex::PointerBuilder(type_1079c);
  ::Reflex::Type type_1262c = ::Reflex::ConstBuilder(type_1262);
  ::Reflex::Type type_4631 = ::Reflex::ReferenceBuilder(type_1262c);
  ::Reflex::Type type_1157c = ::Reflex::ConstBuilder(type_1157);
  ::Reflex::Type type_4632 = ::Reflex::ReferenceBuilder(type_1157c);
  ::Reflex::Type type_4633 = ::Reflex::ReferenceBuilder(type_1157);
  ::Reflex::Type type_2657 = ::Reflex::PointerBuilder(type_1025);
  ::Reflex::Type type_2659 = ::Reflex::PointerBuilder(type_1025c);
  ::Reflex::Type type_1263c = ::Reflex::ConstBuilder(type_1263);
  ::Reflex::Type type_4634 = ::Reflex::ReferenceBuilder(type_1263c);
  ::Reflex::Type type_1158c = ::Reflex::ConstBuilder(type_1158);
  ::Reflex::Type type_4635 = ::Reflex::ReferenceBuilder(type_1158c);
  ::Reflex::Type type_4636 = ::Reflex::ReferenceBuilder(type_1158);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __HcalCalibDetId
#undef __HcalCalibDetId
#endif
class __HcalCalibDetId : public ::HcalOtherDetId {
  public:
  __HcalCalibDetId();
};
#ifdef __HcalCastorDetId
#undef __HcalCastorDetId
#endif
class __HcalCastorDetId : public ::DetId {
  public:
  __HcalCastorDetId();
};
#ifdef __HcalDcsDetId
#undef __HcalDcsDetId
#endif
class __HcalDcsDetId : public ::HcalOtherDetId {
  public:
  __HcalDcsDetId();
};
#ifdef __HcalDetId
#undef __HcalDetId
#endif
class __HcalDetId : public ::DetId {
  public:
  __HcalDetId();
};
#ifdef __HcalZDCDetId
#undef __HcalZDCDetId
#endif
class __HcalZDCDetId : public ::DetId {
  public:
  __HcalZDCDetId();
#ifdef __HcalZDCDetId____79
#undef __HcalZDCDetId____79
#endif
  enum __HcalZDCDetId____79 {};
};
#ifdef __CastorElectronicsId
#undef __CastorElectronicsId
#endif
class __CastorElectronicsId {
  public:
  __CastorElectronicsId();
  ::uint32_t castorElectronicsId_;
};
#ifdef __HcalElectronicsId
#undef __HcalElectronicsId
#endif
class __HcalElectronicsId {
  public:
  __HcalElectronicsId();
  ::uint32_t hcalElectronicsId_;
};
#ifdef __HcalTrigTowerDetId
#undef __HcalTrigTowerDetId
#endif
class __HcalTrigTowerDetId : public ::DetId {
  public:
  __HcalTrigTowerDetId();
};
#ifdef __HcalOtherDetId
#undef __HcalOtherDetId
#endif
class __HcalOtherDetId : public ::DetId {
  public:
  __HcalOtherDetId();
};
#ifdef __HcalFrontEndId
#undef __HcalFrontEndId
#endif
class __HcalFrontEndId {
  public:
  __HcalFrontEndId();
  ::uint32_t hcalFrontEndId_;
};
#ifdef __std__vector_CastorElectronicsId_
#undef __std__vector_CastorElectronicsId_
#endif
class __std__vector_CastorElectronicsId_ : protected ::std::_Vector_base<CastorElectronicsId,std::allocator<CastorElectronicsId> > {
  public:
  __std__vector_CastorElectronicsId_();
};
#ifdef __std__vector_HcalFrontEndId_
#undef __std__vector_HcalFrontEndId_
#endif
class __std__vector_HcalFrontEndId_ : protected ::std::_Vector_base<HcalFrontEndId,std::allocator<HcalFrontEndId> > {
  public:
  __std__vector_HcalFrontEndId_();
};
#ifdef __std__vector_HcalElectronicsId_
#undef __std__vector_HcalElectronicsId_
#endif
class __std__vector_HcalElectronicsId_ : protected ::std::_Vector_base<HcalElectronicsId,std::allocator<HcalElectronicsId> > {
  public:
  __std__vector_HcalElectronicsId_();
};
}


#endif // __CINT__
namespace {
//------Stub functions for class HcalCalibDetId -------------------------------
static void destructor_1566(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCalibDetId*)o)->::HcalCalibDetId::~HcalCalibDetId)();
}
static  void operator_1567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCalibDetId*)o)->operator=)(*(const ::HcalCalibDetId*)arg[0]);
  else   (((::HcalCalibDetId*)o)->operator=)(*(const ::HcalCalibDetId*)arg[0]);
}

static void constructor_1568( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibDetId(*(const ::HcalCalibDetId*)arg[0]);
  else ::new(mem) ::HcalCalibDetId(*(const ::HcalCalibDetId*)arg[0]);
}

static void constructor_1569( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibDetId();
  else ::new(mem) ::HcalCalibDetId();
}

static void constructor_1570( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibDetId(*(::uint32_t*)arg[0]);
  else ::new(mem) ::HcalCalibDetId(*(::uint32_t*)arg[0]);
}

static void constructor_1571( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibDetId(*(const ::DetId*)arg[0]);
  else ::new(mem) ::HcalCalibDetId(*(const ::DetId*)arg[0]);
}

static  void operator_1572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCalibDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
  else   (((::HcalCalibDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
}

static void constructor_1573( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibDetId(*(::HcalSubdetector*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  else ::new(mem) ::HcalCalibDetId(*(::HcalSubdetector*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
}

static void constructor_1574( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCalibDetId(*(int*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::HcalCalibDetId(*(int*)arg[0],
      *(int*)arg[1]);
}

static  void method_1575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCalibDetId*)o)->calibFlavor)());
  else   (((const ::HcalCalibDetId*)o)->calibFlavor)();
}

static  void method_1576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCalibDetId*)o)->hcalSubdet)());
  else   (((const ::HcalCalibDetId*)o)->hcalSubdet)();
}

static  void method_1577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCalibDetId*)o)->ieta)());
  else   (((const ::HcalCalibDetId*)o)->ieta)();
}

static  void method_1578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCalibDetId*)o)->iphi)());
  else   (((const ::HcalCalibDetId*)o)->iphi)();
}

static  void method_1579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCalibDetId*)o)->cboxChannel)());
  else   (((const ::HcalCalibDetId*)o)->cboxChannel)();
}

static  void method_1580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalCalibDetId*)o)->cboxChannelString)());
  else   (((const ::HcalCalibDetId*)o)->cboxChannelString)();
}

static  void method_1581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCalibDetId*)o)->zside)());
  else   (((const ::HcalCalibDetId*)o)->zside)();
}

static void method_newdel_103( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalCalibDetId >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalCalibDetId >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalCalibDetId >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalCalibDetId >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalCalibDetId >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalOtherDetId")), ::Reflex::BaseOffset< ::HcalCalibDetId,::HcalOtherDetId >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DetId")), ::Reflex::BaseOffset< ::HcalCalibDetId,::DetId >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCalibDetId -------------------------------
void __HcalCalibDetId_db_datamem(Reflex::Class*);
void __HcalCalibDetId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCalibDetId_datamem_bld(&__HcalCalibDetId_db_datamem);
Reflex::GenreflexMemberBuilder __HcalCalibDetId_funcmem_bld(&__HcalCalibDetId_db_funcmem);
void __HcalCalibDetId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCalibDetId"), typeid(::HcalCalibDetId), sizeof(::HcalCalibDetId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_1046, ::Reflex::BaseOffset< ::HcalCalibDetId, ::HcalOtherDetId >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("HcalCalibDetId::CalibDetType"), Reflex::Literal("CalibrationBox=1;HOCrosstalk=2"), &typeid(HcalCalibDetId::CalibDetType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCalibDetId"), destructor_1566, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4056, type_2007), Reflex::Literal("operator="), operator_1567, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2007), Reflex::Literal("HcalCalibDetId"), constructor_1568, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalCalibDetId"), constructor_1569, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_419), Reflex::Literal("HcalCalibDetId"), constructor_1570, 0, "rawid", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4057), Reflex::Literal("HcalCalibDetId"), constructor_1571, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_797, type_29, type_29, type_29), Reflex::Literal("HcalCalibDetId"), constructor_1573, 0, "subdet;ieta;iphi;ctype", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29, type_29), Reflex::Literal("HcalCalibDetId"), constructor_1574, 0, "ieta;iphi", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalCalibDetId_funcmem_bld);
}

//------Delayed data member builder for class HcalCalibDetId -------------------
void __HcalCalibDetId_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalCalibDetId -------------------
void __HcalCalibDetId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4056, type_4057), Reflex::Literal("operator="), operator_1572, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1565), Reflex::Literal("calibFlavor"), method_1575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_797), Reflex::Literal("hcalSubdet"), method_1576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("ieta"), method_1577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("iphi"), method_1578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("cboxChannel"), method_1579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1193), Reflex::Literal("cboxChannelString"), method_1580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("zside"), method_1581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalCastorDetId -------------------------------
static void destructor_1766(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalCastorDetId*)o)->::HcalCastorDetId::~HcalCastorDetId)();
}
static  void operator_1767( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCastorDetId*)o)->operator=)(*(const ::HcalCastorDetId*)arg[0]);
  else   (((::HcalCastorDetId*)o)->operator=)(*(const ::HcalCastorDetId*)arg[0]);
}

static void constructor_1768( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCastorDetId(*(const ::HcalCastorDetId*)arg[0]);
  else ::new(mem) ::HcalCastorDetId(*(const ::HcalCastorDetId*)arg[0]);
}

static void constructor_1769( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCastorDetId();
  else ::new(mem) ::HcalCastorDetId();
}

static void constructor_1770( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCastorDetId(*(::uint32_t*)arg[0]);
  else ::new(mem) ::HcalCastorDetId(*(::uint32_t*)arg[0]);
}

static void constructor_1771( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCastorDetId(*(::HcalCastorDetId::Section*)arg[0],
      *(bool*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  else ::new(mem) ::HcalCastorDetId(*(::HcalCastorDetId::Section*)arg[0],
      *(bool*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
}

static void constructor_1772( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCastorDetId(*(bool*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  else ::new(mem) ::HcalCastorDetId(*(bool*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
}

static void constructor_1773( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalCastorDetId(*(const ::DetId*)arg[0]);
  else ::new(mem) ::HcalCastorDetId(*(const ::DetId*)arg[0]);
}

static  void operator_1774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalCastorDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
  else   (((::HcalCastorDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
}

static  void method_1775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCastorDetId*)o)->zside)());
  else   (((const ::HcalCastorDetId*)o)->zside)();
}

static  void method_1776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCastorDetId*)o)->section)());
  else   (((const ::HcalCastorDetId*)o)->section)();
}

static  void method_1777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCastorDetId*)o)->module)());
  else   (((const ::HcalCastorDetId*)o)->module)();
}

static  void method_1778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalCastorDetId*)o)->sector)());
  else   (((const ::HcalCastorDetId*)o)->sector)();
}

static  void method_1779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalCastorDetId*)o)->denseIndex)());
  else   (((const ::HcalCastorDetId*)o)->denseIndex)();
}

static  void method_1780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCastorDetId*)o)->validDetId)(*(::HcalCastorDetId::Section*)arg[0],
    *(bool*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]));
  else   (((::HcalCastorDetId*)o)->validDetId)(*(::HcalCastorDetId::Section*)arg[0],
    *(bool*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]);
}

static  void method_1781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalCastorDetId*)o)->validDenseIndex)(*(::uint32_t*)arg[0]));
  else   (((::HcalCastorDetId*)o)->validDenseIndex)(*(::uint32_t*)arg[0]);
}

static  void method_1782( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HcalCastorDetId)((((::HcalCastorDetId*)o)->detIdFromDenseIndex)(*(::uint32_t*)arg[0]));
  else   (((::HcalCastorDetId*)o)->detIdFromDenseIndex)(*(::uint32_t*)arg[0]);
}

static void method_newdel_335( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalCastorDetId >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalCastorDetId >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalCastorDetId >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalCastorDetId >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalCastorDetId >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DetId")), ::Reflex::BaseOffset< ::HcalCastorDetId,::DetId >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalCastorDetId -------------------------------
void __HcalCastorDetId_db_datamem(Reflex::Class*);
void __HcalCastorDetId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalCastorDetId_datamem_bld(&__HcalCastorDetId_db_datamem);
Reflex::GenreflexMemberBuilder __HcalCastorDetId_funcmem_bld(&__HcalCastorDetId_db_funcmem);
void __HcalCastorDetId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalCastorDetId"), typeid(::HcalCastorDetId), sizeof(::HcalCastorDetId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_738, ::Reflex::BaseOffset< ::HcalCastorDetId, ::DetId >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("HcalCastorDetId::Section"), Reflex::Literal("Unknown=0;EM=1;HAD=2"), &typeid(HcalCastorDetId::Section), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_81"), Reflex::Literal("kNumberModulesPerEnd=14;kNumberSectorsPerEnd=16;kNumberCellsPerEnd=224;kSizeForDenseIndexing=224"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalCastorDetId"), destructor_1766, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4411, type_2004), Reflex::Literal("operator="), operator_1767, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2004), Reflex::Literal("HcalCastorDetId"), constructor_1768, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalCastorDetId"), constructor_1769, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_419), Reflex::Literal("HcalCastorDetId"), constructor_1770, 0, "rawid", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1764, type_1493, type_29, type_29), Reflex::Literal("HcalCastorDetId"), constructor_1771, 0, "section;true_for_positive_eta;sector;module", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1493, type_29, type_29), Reflex::Literal("HcalCastorDetId"), constructor_1772, 0, "true_for_positive_eta;sector;module", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4057), Reflex::Literal("HcalCastorDetId"), constructor_1773, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_335, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalCastorDetId_funcmem_bld);
}

//------Delayed data member builder for class HcalCastorDetId -------------------
void __HcalCastorDetId_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalCastorDetId -------------------
void __HcalCastorDetId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4411, type_4057), Reflex::Literal("operator="), operator_1774, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("zside"), method_1775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1764), Reflex::Literal("section"), method_1776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("module"), method_1777, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("sector"), method_1778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_419), Reflex::Literal("denseIndex"), method_1779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1493, type_1764, type_1493, type_29, type_29), Reflex::Literal("validDetId"), method_1780, 0, "iSection;posEta;iSector;iMod", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1493, type_419), Reflex::Literal("validDenseIndex"), method_1781, 0, "din", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_335, type_419), Reflex::Literal("detIdFromDenseIndex"), method_1782, 0, "di", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class HcalDcsDetId -------------------------------
static void destructor_1805(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalDcsDetId*)o)->::HcalDcsDetId::~HcalDcsDetId)();
}
static  void operator_1806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalDcsDetId*)o)->operator=)(*(const ::HcalDcsDetId*)arg[0]);
  else   (((::HcalDcsDetId*)o)->operator=)(*(const ::HcalDcsDetId*)arg[0]);
}

static void constructor_1807( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsDetId(*(const ::HcalDcsDetId*)arg[0]);
  else ::new(mem) ::HcalDcsDetId(*(const ::HcalDcsDetId*)arg[0]);
}

static void constructor_1808( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsDetId();
  else ::new(mem) ::HcalDcsDetId();
}

static void constructor_1809( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsDetId(*(::uint32_t*)arg[0]);
  else ::new(mem) ::HcalDcsDetId(*(::uint32_t*)arg[0]);
}

static void constructor_1810( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsDetId(*(const ::DetId*)arg[0]);
  else ::new(mem) ::HcalDcsDetId(*(const ::DetId*)arg[0]);
}

static void constructor_1811( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDcsDetId(*(::HcalOtherSubdetector*)arg[0],
      *(int*)arg[1],
      *(unsigned int*)arg[2],
      *(::HcalDcsDetId::DcsType*)arg[3],
      *(unsigned int*)arg[4]);
  else ::new(mem) ::HcalDcsDetId(*(::HcalOtherSubdetector*)arg[0],
      *(int*)arg[1],
      *(unsigned int*)arg[2],
      *(::HcalDcsDetId::DcsType*)arg[3],
      *(unsigned int*)arg[4]);
}

static  void method_1812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::HcalDcsDetId*)o)->DcsTypeFromString)(*(const ::std::string*)arg[0]));
  else   (((::HcalDcsDetId*)o)->DcsTypeFromString)(*(const ::std::string*)arg[0]);
}

static  void method_1813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::HcalDcsDetId*)o)->typeString)(*(::HcalDcsDetId::DcsType*)arg[0]));
  else   (((::HcalDcsDetId*)o)->typeString)(*(::HcalDcsDetId::DcsType*)arg[0]);
}

static  void method_1814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDcsDetId*)o)->zside)());
  else   (((const ::HcalDcsDetId*)o)->zside)();
}

static  void method_1815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDcsDetId*)o)->ring)());
  else   (((const ::HcalDcsDetId*)o)->ring)();
}

static  void method_1816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDcsDetId*)o)->slice)());
  else   (((const ::HcalDcsDetId*)o)->slice)();
}

static  void method_1817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDcsDetId*)o)->type)());
  else   (((const ::HcalDcsDetId*)o)->type)();
}

static  void method_1818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDcsDetId*)o)->subchannel)());
  else   (((const ::HcalDcsDetId*)o)->subchannel)();
}

static void method_newdel_369( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalDcsDetId >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalDcsDetId >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalDcsDetId >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalDcsDetId >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalDcsDetId >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("HcalOtherDetId")), ::Reflex::BaseOffset< ::HcalDcsDetId,::HcalOtherDetId >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DetId")), ::Reflex::BaseOffset< ::HcalDcsDetId,::DetId >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalDcsDetId -------------------------------
void __HcalDcsDetId_db_datamem(Reflex::Class*);
void __HcalDcsDetId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalDcsDetId_datamem_bld(&__HcalDcsDetId_db_datamem);
Reflex::GenreflexMemberBuilder __HcalDcsDetId_funcmem_bld(&__HcalDcsDetId_db_funcmem);
void __HcalDcsDetId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalDcsDetId"), typeid(::HcalDcsDetId), sizeof(::HcalDcsDetId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_1046, ::Reflex::BaseOffset< ::HcalDcsDetId, ::HcalOtherDetId >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("HcalDcsDetId::DcsType"), Reflex::Literal("HV=1;BV=2;CATH=3;DYN7=4;DYN8=5;RM_TEMP=6;CCM_TEMP=7;CALIB_TEMP=8;LVTTM_TEMP=9;TEMP=10;QPLL_LOCK=11;STATUS=12;DCSUNKNOWN=15;DCS_MAX=16"), &typeid(HcalDcsDetId::DcsType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalDcsDetId"), destructor_1805, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4419, type_2005), Reflex::Literal("operator="), operator_1806, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2005), Reflex::Literal("HcalDcsDetId"), constructor_1807, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalDcsDetId"), constructor_1808, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_419), Reflex::Literal("HcalDcsDetId"), constructor_1809, 0, "rawid", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4057), Reflex::Literal("HcalDcsDetId"), constructor_1810, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_368, type_29, type_70, type_1804, type_70), Reflex::Literal("HcalDcsDetId"), constructor_1811, 0, "subd;side_or_ring;slc;ty;subchan", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_369, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalDcsDetId_funcmem_bld);
}

//------Delayed data member builder for class HcalDcsDetId -------------------
void __HcalDcsDetId_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalDcsDetId -------------------
void __HcalDcsDetId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1804, type_2925), Reflex::Literal("DcsTypeFromString"), method_1812, 0, "str", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1193, type_1804), Reflex::Literal("typeString"), method_1813, 0, "typ", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("zside"), method_1814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("ring"), method_1815, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("slice"), method_1816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1804), Reflex::Literal("type"), method_1817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("subchannel"), method_1818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalDetId -------------------------------
static void destructor_1843(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalDetId*)o)->::HcalDetId::~HcalDetId)();
}
static  void operator_1844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalDetId*)o)->operator=)(*(const ::HcalDetId*)arg[0]);
  else   (((::HcalDetId*)o)->operator=)(*(const ::HcalDetId*)arg[0]);
}

static void constructor_1845( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDetId(*(const ::HcalDetId*)arg[0]);
  else ::new(mem) ::HcalDetId(*(const ::HcalDetId*)arg[0]);
}

static void constructor_1846( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDetId();
  else ::new(mem) ::HcalDetId();
}

static void constructor_1847( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDetId(*(::uint32_t*)arg[0]);
  else ::new(mem) ::HcalDetId(*(::uint32_t*)arg[0]);
}

static void constructor_1848( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDetId(*(::HcalSubdetector*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  else ::new(mem) ::HcalDetId(*(::HcalSubdetector*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
}

static void constructor_1849( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalDetId(*(const ::DetId*)arg[0]);
  else ::new(mem) ::HcalDetId(*(const ::DetId*)arg[0]);
}

static  void operator_1850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
  else   (((::HcalDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
}

static  void method_1851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDetId*)o)->subdet)());
  else   (((const ::HcalDetId*)o)->subdet)();
}

static  void method_1852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDetId*)o)->zside)());
  else   (((const ::HcalDetId*)o)->zside)();
}

static  void method_1853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDetId*)o)->ietaAbs)());
  else   (((const ::HcalDetId*)o)->ietaAbs)();
}

static  void method_1854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDetId*)o)->ieta)());
  else   (((const ::HcalDetId*)o)->ieta)();
}

static  void method_1855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDetId*)o)->iphi)());
  else   (((const ::HcalDetId*)o)->iphi)();
}

static  void method_1856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDetId*)o)->depth)());
  else   (((const ::HcalDetId*)o)->depth)();
}

static  void method_1857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDetId*)o)->crystal_ieta_low)());
  else   (((const ::HcalDetId*)o)->crystal_ieta_low)();
}

static  void method_1858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDetId*)o)->crystal_ieta_high)());
  else   (((const ::HcalDetId*)o)->crystal_ieta_high)();
}

static  void method_1859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDetId*)o)->crystal_iphi_low)());
  else   (((const ::HcalDetId*)o)->crystal_iphi_low)();
}

static  void method_1860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalDetId*)o)->crystal_iphi_high)());
  else   (((const ::HcalDetId*)o)->crystal_iphi_high)();
}

static void method_newdel_500( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalDetId >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalDetId >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalDetId >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalDetId >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalDetId >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DetId")), ::Reflex::BaseOffset< ::HcalDetId,::DetId >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalDetId -------------------------------
void __HcalDetId_db_datamem(Reflex::Class*);
void __HcalDetId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalDetId_datamem_bld(&__HcalDetId_db_datamem);
Reflex::GenreflexMemberBuilder __HcalDetId_funcmem_bld(&__HcalDetId_db_funcmem);
void __HcalDetId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalDetId"), typeid(::HcalDetId), sizeof(::HcalDetId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_738, ::Reflex::BaseOffset< ::HcalDetId, ::DetId >::Get(), ::Reflex::PUBLIC)
  .AddDataMember(type_500c, Reflex::Literal("Undefined"), (size_t)&HcalDetId::Undefined, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC | Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalDetId"), destructor_1843, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4439, type_2009), Reflex::Literal("operator="), operator_1844, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2009), Reflex::Literal("HcalDetId"), constructor_1845, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalDetId"), constructor_1846, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_419), Reflex::Literal("HcalDetId"), constructor_1847, 0, "rawid", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_797, type_29, type_29, type_29), Reflex::Literal("HcalDetId"), constructor_1848, 0, "subdet;tower_ieta;tower_iphi;depth", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4057), Reflex::Literal("HcalDetId"), constructor_1849, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_500, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalDetId_funcmem_bld);
}

//------Delayed data member builder for class HcalDetId -------------------
void __HcalDetId_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalDetId -------------------
void __HcalDetId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4439, type_4057), Reflex::Literal("operator="), operator_1850, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_797), Reflex::Literal("subdet"), method_1851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("zside"), method_1852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("ietaAbs"), method_1853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("ieta"), method_1854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("iphi"), method_1855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("depth"), method_1856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("crystal_ieta_low"), method_1857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("crystal_ieta_high"), method_1858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("crystal_iphi_low"), method_1859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("crystal_iphi_high"), method_1860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalZDCDetId -------------------------------
static void destructor_1879(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalZDCDetId*)o)->::HcalZDCDetId::~HcalZDCDetId)();
}
static  void operator_1880( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalZDCDetId*)o)->operator=)(*(const ::HcalZDCDetId*)arg[0]);
  else   (((::HcalZDCDetId*)o)->operator=)(*(const ::HcalZDCDetId*)arg[0]);
}

static void constructor_1881( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZDCDetId(*(const ::HcalZDCDetId*)arg[0]);
  else ::new(mem) ::HcalZDCDetId(*(const ::HcalZDCDetId*)arg[0]);
}

static void constructor_1882( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZDCDetId();
  else ::new(mem) ::HcalZDCDetId();
}

static void constructor_1883( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZDCDetId(*(::uint32_t*)arg[0]);
  else ::new(mem) ::HcalZDCDetId(*(::uint32_t*)arg[0]);
}

static void constructor_1884( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZDCDetId(*(::HcalZDCDetId::Section*)arg[0],
      *(bool*)arg[1],
      *(int*)arg[2]);
  else ::new(mem) ::HcalZDCDetId(*(::HcalZDCDetId::Section*)arg[0],
      *(bool*)arg[1],
      *(int*)arg[2]);
}

static void constructor_1885( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalZDCDetId(*(const ::DetId*)arg[0]);
  else ::new(mem) ::HcalZDCDetId(*(const ::DetId*)arg[0]);
}

static  void operator_1886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalZDCDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
  else   (((::HcalZDCDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
}

static  void method_1887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalZDCDetId*)o)->zside)());
  else   (((const ::HcalZDCDetId*)o)->zside)();
}

static  void method_1888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalZDCDetId*)o)->section)());
  else   (((const ::HcalZDCDetId*)o)->section)();
}

static  void method_1889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalZDCDetId*)o)->depth)());
  else   (((const ::HcalZDCDetId*)o)->depth)();
}

static  void method_1890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalZDCDetId*)o)->channel)());
  else   (((const ::HcalZDCDetId*)o)->channel)();
}

static  void method_1891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalZDCDetId*)o)->denseIndex)());
  else   (((const ::HcalZDCDetId*)o)->denseIndex)();
}

static  void method_1892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalZDCDetId*)o)->validDenseIndex)(*(::uint32_t*)arg[0]));
  else   (((::HcalZDCDetId*)o)->validDenseIndex)(*(::uint32_t*)arg[0]);
}

static  void method_1893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HcalZDCDetId)((((::HcalZDCDetId*)o)->detIdFromDenseIndex)(*(::uint32_t*)arg[0]));
  else   (((::HcalZDCDetId*)o)->detIdFromDenseIndex)(*(::uint32_t*)arg[0]);
}

static  void method_1894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HcalZDCDetId*)o)->validDetId)(*(::HcalZDCDetId::Section*)arg[0],
    *(int*)arg[1]));
  else   (((::HcalZDCDetId*)o)->validDetId)(*(::HcalZDCDetId::Section*)arg[0],
    *(int*)arg[1]);
}

static void method_newdel_545( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalZDCDetId >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalZDCDetId >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalZDCDetId >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalZDCDetId >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalZDCDetId >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DetId")), ::Reflex::BaseOffset< ::HcalZDCDetId,::DetId >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalZDCDetId -------------------------------
void __HcalZDCDetId_db_datamem(Reflex::Class*);
void __HcalZDCDetId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalZDCDetId_datamem_bld(&__HcalZDCDetId_db_datamem);
Reflex::GenreflexMemberBuilder __HcalZDCDetId_funcmem_bld(&__HcalZDCDetId_db_funcmem);
void __HcalZDCDetId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalZDCDetId"), typeid(::HcalZDCDetId), sizeof(::HcalZDCDetId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_738, ::Reflex::BaseOffset< ::HcalZDCDetId, ::DetId >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("HcalZDCDetId::Section"), Reflex::Literal("Unknown=0;EM=1;HAD=2;LUM=3"), &typeid(HcalZDCDetId::Section), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_79"), Reflex::Literal("kDepEM=5;kDepHAD=4;kDepLUM=2;kDepTot=11"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_80"), Reflex::Literal("kSizeForDenseIndexing=22"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalZDCDetId"), destructor_1879, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4452, type_2006), Reflex::Literal("operator="), operator_1880, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2006), Reflex::Literal("HcalZDCDetId"), constructor_1881, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalZDCDetId"), constructor_1882, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_419), Reflex::Literal("HcalZDCDetId"), constructor_1883, 0, "rawid", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1876, type_1493, type_29), Reflex::Literal("HcalZDCDetId"), constructor_1884, 0, "section;true_for_positive_eta;channel", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4057), Reflex::Literal("HcalZDCDetId"), constructor_1885, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_545, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalZDCDetId_funcmem_bld);
}

//------Delayed data member builder for class HcalZDCDetId -------------------
void __HcalZDCDetId_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalZDCDetId -------------------
void __HcalZDCDetId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4452, type_4057), Reflex::Literal("operator="), operator_1886, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("zside"), method_1887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1876), Reflex::Literal("section"), method_1888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("depth"), method_1889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("channel"), method_1890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_419), Reflex::Literal("denseIndex"), method_1891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1493, type_419), Reflex::Literal("validDenseIndex"), method_1892, 0, "di", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_545, type_419), Reflex::Literal("detIdFromDenseIndex"), method_1893, 0, "di", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1493, type_1876, type_29), Reflex::Literal("validDetId"), method_1894, 0, "se;dp", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class CastorElectronicsId -------------------------------
static void destructor_1966(void*, void * o, const std::vector<void*>&, void *) {
(((::CastorElectronicsId*)o)->::CastorElectronicsId::~CastorElectronicsId)();
}
static  void operator_1967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CastorElectronicsId*)o)->operator=)(*(const ::CastorElectronicsId*)arg[0]);
  else   (((::CastorElectronicsId*)o)->operator=)(*(const ::CastorElectronicsId*)arg[0]);
}

static void constructor_1968( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CastorElectronicsId(*(const ::CastorElectronicsId*)arg[0]);
  else ::new(mem) ::CastorElectronicsId(*(const ::CastorElectronicsId*)arg[0]);
}

static void constructor_1969( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CastorElectronicsId();
  else ::new(mem) ::CastorElectronicsId();
}

static void constructor_1970( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CastorElectronicsId(*(::uint32_t*)arg[0]);
  else ::new(mem) ::CastorElectronicsId(*(::uint32_t*)arg[0]);
}

static void constructor_1971( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CastorElectronicsId(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  else ::new(mem) ::CastorElectronicsId(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
}

static void constructor_1972( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CastorElectronicsId(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6]);
  else ::new(mem) ::CastorElectronicsId(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6]);
}

static  void operator_1973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((::CastorElectronicsId*)o)->operator())());
  else   (((::CastorElectronicsId*)o)->operator())();
}

static  void method_1974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::CastorElectronicsId*)o)->rawId)());
  else   (((const ::CastorElectronicsId*)o)->rawId)();
}

static  void method_1975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CastorElectronicsId*)o)->isTriggerChainId)());
  else   (((const ::CastorElectronicsId*)o)->isTriggerChainId)();
}

static  void method_1976( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CastorElectronicsId*)o)->setHTR)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_1977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->fiberChanId)());
  else   (((const ::CastorElectronicsId*)o)->fiberChanId)();
}

static  void method_1978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->fiberIndex)());
  else   (((const ::CastorElectronicsId*)o)->fiberIndex)();
}

static  void method_1979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->slbChannelIndex)());
  else   (((const ::CastorElectronicsId*)o)->slbChannelIndex)();
}

static  void method_1980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->slbSiteNumber)());
  else   (((const ::CastorElectronicsId*)o)->slbSiteNumber)();
}

static  void method_1981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::CastorElectronicsId*)o)->slbChannelCode)());
  else   (((const ::CastorElectronicsId*)o)->slbChannelCode)();
}

static  void method_1982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->htrChanId)());
  else   (((const ::CastorElectronicsId*)o)->htrChanId)();
}

static  void method_1983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->spigot)());
  else   (((const ::CastorElectronicsId*)o)->spigot)();
}

static  void method_1984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->dccid)());
  else   (((const ::CastorElectronicsId*)o)->dccid)();
}

static  void method_1985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->htrSlot)());
  else   (((const ::CastorElectronicsId*)o)->htrSlot)();
}

static  void method_1986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->htrTopBottom)());
  else   (((const ::CastorElectronicsId*)o)->htrTopBottom)();
}

static  void method_1987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->readoutVMECrateId)());
  else   (((const ::CastorElectronicsId*)o)->readoutVMECrateId)();
}

static  void method_1988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->linearIndex)());
  else   (((const ::CastorElectronicsId*)o)->linearIndex)();
}

static  void operator_1989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->operator==)(*(const ::CastorElectronicsId*)arg[0]));
  else   (((const ::CastorElectronicsId*)o)->operator==)(*(const ::CastorElectronicsId*)arg[0]);
}

static  void operator_1990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->operator!=)(*(const ::CastorElectronicsId*)arg[0]));
  else   (((const ::CastorElectronicsId*)o)->operator!=)(*(const ::CastorElectronicsId*)arg[0]);
}

static  void operator_1991( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CastorElectronicsId*)o)->operator<)(*(const ::CastorElectronicsId*)arg[0]));
  else   (((const ::CastorElectronicsId*)o)->operator<)(*(const ::CastorElectronicsId*)arg[0]);
}

static void method_newdel_774( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CastorElectronicsId >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CastorElectronicsId >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CastorElectronicsId >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CastorElectronicsId >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CastorElectronicsId >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CastorElectronicsId -------------------------------
void __CastorElectronicsId_db_datamem(Reflex::Class*);
void __CastorElectronicsId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CastorElectronicsId_datamem_bld(&__CastorElectronicsId_db_datamem);
Reflex::GenreflexMemberBuilder __CastorElectronicsId_funcmem_bld(&__CastorElectronicsId_db_funcmem);
void __CastorElectronicsId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CastorElectronicsId"), typeid(::CastorElectronicsId), sizeof(::CastorElectronicsId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CastorElectronicsId"), destructor_1966, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2531, type_2003), Reflex::Literal("operator="), operator_1967, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2003), Reflex::Literal("CastorElectronicsId"), constructor_1968, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CastorElectronicsId"), constructor_1969, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_419), Reflex::Literal("CastorElectronicsId"), constructor_1970, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29, type_29, type_29, type_29), Reflex::Literal("CastorElectronicsId"), constructor_1971, 0, "fiberChan;fiberIndex;spigot;dccid", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29, type_29, type_29, type_29, type_29, type_29, type_29), Reflex::Literal("CastorElectronicsId"), constructor_1972, 0, "slbChan;slbSite;spigot;dccid;crate;slot;tb", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_774, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CastorElectronicsId_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CastorElectronicsId_funcmem_bld);
}

//------Delayed data member builder for class CastorElectronicsId -------------------
void __CastorElectronicsId_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_419, Reflex::Literal("castorElectronicsId_"), OffsetOf(__shadow__::__CastorElectronicsId, castorElectronicsId_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class CastorElectronicsId -------------------
void __CastorElectronicsId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_419), Reflex::Literal("operator()"), operator_1973, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_419), Reflex::Literal("rawId"), method_1974, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1493), Reflex::Literal("isTriggerChainId"), method_1975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_29, type_29, type_29), Reflex::Literal("setHTR"), method_1976, 0, "crate;slot;tb", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("fiberChanId"), method_1977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("fiberIndex"), method_1978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("slbChannelIndex"), method_1979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("slbSiteNumber"), method_1980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1193), Reflex::Literal("slbChannelCode"), method_1981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("htrChanId"), method_1982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("spigot"), method_1983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("dccid"), method_1984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("htrSlot"), method_1985, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("htrTopBottom"), method_1986, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("readoutVMECrateId"), method_1987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("linearIndex"), method_1988, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29, type_2003), Reflex::Literal("operator=="), operator_1989, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29, type_2003), Reflex::Literal("operator!="), operator_1990, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29, type_2003), Reflex::Literal("operator<"), operator_1991, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class HcalElectronicsId -------------------------------
static void destructor_2091(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalElectronicsId*)o)->::HcalElectronicsId::~HcalElectronicsId)();
}
static  void operator_2092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalElectronicsId*)o)->operator=)(*(const ::HcalElectronicsId*)arg[0]);
  else   (((::HcalElectronicsId*)o)->operator=)(*(const ::HcalElectronicsId*)arg[0]);
}

static void constructor_2093( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsId(*(const ::HcalElectronicsId*)arg[0]);
  else ::new(mem) ::HcalElectronicsId(*(const ::HcalElectronicsId*)arg[0]);
}

static void constructor_2094( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsId();
  else ::new(mem) ::HcalElectronicsId();
}

static void constructor_2095( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsId(*(::uint32_t*)arg[0]);
  else ::new(mem) ::HcalElectronicsId(*(::uint32_t*)arg[0]);
}

static void constructor_2096( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsId(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  else ::new(mem) ::HcalElectronicsId(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
}

static void constructor_2097( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalElectronicsId(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6]);
  else ::new(mem) ::HcalElectronicsId(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6]);
}

static  void operator_2098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((::HcalElectronicsId*)o)->operator())());
  else   (((::HcalElectronicsId*)o)->operator())();
}

static  void method_2099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalElectronicsId*)o)->rawId)());
  else   (((const ::HcalElectronicsId*)o)->rawId)();
}

static  void method_2100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalElectronicsId*)o)->isTriggerChainId)());
  else   (((const ::HcalElectronicsId*)o)->isTriggerChainId)();
}

static  void method_2101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HcalElectronicsId*)o)->setHTR)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_2102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->fiberChanId)());
  else   (((const ::HcalElectronicsId*)o)->fiberChanId)();
}

static  void method_2103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->fiberIndex)());
  else   (((const ::HcalElectronicsId*)o)->fiberIndex)();
}

static  void method_2104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->slbChannelIndex)());
  else   (((const ::HcalElectronicsId*)o)->slbChannelIndex)();
}

static  void method_2105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->slbSiteNumber)());
  else   (((const ::HcalElectronicsId*)o)->slbSiteNumber)();
}

static  void method_2106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalElectronicsId*)o)->slbChannelCode)());
  else   (((const ::HcalElectronicsId*)o)->slbChannelCode)();
}

static  void method_2107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->htrChanId)());
  else   (((const ::HcalElectronicsId*)o)->htrChanId)();
}

static  void method_2108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->spigot)());
  else   (((const ::HcalElectronicsId*)o)->spigot)();
}

static  void method_2109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->dccid)());
  else   (((const ::HcalElectronicsId*)o)->dccid)();
}

static  void method_2110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->htrSlot)());
  else   (((const ::HcalElectronicsId*)o)->htrSlot)();
}

static  void method_2111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->htrTopBottom)());
  else   (((const ::HcalElectronicsId*)o)->htrTopBottom)();
}

static  void method_2112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->readoutVMECrateId)());
  else   (((const ::HcalElectronicsId*)o)->readoutVMECrateId)();
}

static  void method_2113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->linearIndex)());
  else   (((const ::HcalElectronicsId*)o)->linearIndex)();
}

static  void operator_2114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->operator==)(*(const ::HcalElectronicsId*)arg[0]));
  else   (((const ::HcalElectronicsId*)o)->operator==)(*(const ::HcalElectronicsId*)arg[0]);
}

static  void operator_2115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->operator!=)(*(const ::HcalElectronicsId*)arg[0]));
  else   (((const ::HcalElectronicsId*)o)->operator!=)(*(const ::HcalElectronicsId*)arg[0]);
}

static  void operator_2116( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalElectronicsId*)o)->operator<)(*(const ::HcalElectronicsId*)arg[0]));
  else   (((const ::HcalElectronicsId*)o)->operator<)(*(const ::HcalElectronicsId*)arg[0]);
}

static void method_newdel_1025( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalElectronicsId >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalElectronicsId >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalElectronicsId >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalElectronicsId >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalElectronicsId >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalElectronicsId -------------------------------
void __HcalElectronicsId_db_datamem(Reflex::Class*);
void __HcalElectronicsId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalElectronicsId_datamem_bld(&__HcalElectronicsId_db_datamem);
Reflex::GenreflexMemberBuilder __HcalElectronicsId_funcmem_bld(&__HcalElectronicsId_db_funcmem);
void __HcalElectronicsId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalElectronicsId"), typeid(::HcalElectronicsId), sizeof(::HcalElectronicsId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalElectronicsId"), destructor_2091, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2661, type_2011), Reflex::Literal("operator="), operator_2092, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2011), Reflex::Literal("HcalElectronicsId"), constructor_2093, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalElectronicsId"), constructor_2094, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_419), Reflex::Literal("HcalElectronicsId"), constructor_2095, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29, type_29, type_29, type_29), Reflex::Literal("HcalElectronicsId"), constructor_2096, 0, "fiberChan;fiberIndex;spigot;dccid", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29, type_29, type_29, type_29, type_29, type_29, type_29), Reflex::Literal("HcalElectronicsId"), constructor_2097, 0, "slbChan;slbSite;spigot;dccid;crate;slot;tb", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1025, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalElectronicsId_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalElectronicsId_funcmem_bld);
}

//------Delayed data member builder for class HcalElectronicsId -------------------
void __HcalElectronicsId_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_419, Reflex::Literal("hcalElectronicsId_"), OffsetOf(__shadow__::__HcalElectronicsId, hcalElectronicsId_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalElectronicsId -------------------
void __HcalElectronicsId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_419), Reflex::Literal("operator()"), operator_2098, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_419), Reflex::Literal("rawId"), method_2099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1493), Reflex::Literal("isTriggerChainId"), method_2100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_29, type_29, type_29), Reflex::Literal("setHTR"), method_2101, 0, "crate;slot;tb", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("fiberChanId"), method_2102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("fiberIndex"), method_2103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("slbChannelIndex"), method_2104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("slbSiteNumber"), method_2105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1193), Reflex::Literal("slbChannelCode"), method_2106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("htrChanId"), method_2107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("spigot"), method_2108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("dccid"), method_2109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("htrSlot"), method_2110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("htrTopBottom"), method_2111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("readoutVMECrateId"), method_2112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("linearIndex"), method_2113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29, type_2011), Reflex::Literal("operator=="), operator_2114, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29, type_2011), Reflex::Literal("operator!="), operator_2115, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29, type_2011), Reflex::Literal("operator<"), operator_2116, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class HcalTrigTowerDetId -------------------------------
static void destructor_2118(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalTrigTowerDetId*)o)->::HcalTrigTowerDetId::~HcalTrigTowerDetId)();
}
static  void operator_2119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalTrigTowerDetId*)o)->operator=)(*(const ::HcalTrigTowerDetId*)arg[0]);
  else   (((::HcalTrigTowerDetId*)o)->operator=)(*(const ::HcalTrigTowerDetId*)arg[0]);
}

static void constructor_2120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTrigTowerDetId(*(const ::HcalTrigTowerDetId*)arg[0]);
  else ::new(mem) ::HcalTrigTowerDetId(*(const ::HcalTrigTowerDetId*)arg[0]);
}

static void constructor_2121( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTrigTowerDetId();
  else ::new(mem) ::HcalTrigTowerDetId();
}

static void constructor_2122( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTrigTowerDetId(*(::uint32_t*)arg[0]);
  else ::new(mem) ::HcalTrigTowerDetId(*(::uint32_t*)arg[0]);
}

static void constructor_2123( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTrigTowerDetId(*(int*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::HcalTrigTowerDetId(*(int*)arg[0],
      *(int*)arg[1]);
}

static void constructor_2124( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTrigTowerDetId(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  else ::new(mem) ::HcalTrigTowerDetId(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
}

static void constructor_2125( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalTrigTowerDetId(*(const ::DetId*)arg[0]);
  else ::new(mem) ::HcalTrigTowerDetId(*(const ::DetId*)arg[0]);
}

static  void operator_2126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalTrigTowerDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
  else   (((::HcalTrigTowerDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
}

static  void method_2127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalTrigTowerDetId*)o)->subdet)());
  else   (((const ::HcalTrigTowerDetId*)o)->subdet)();
}

static  void method_2128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalTrigTowerDetId*)o)->zside)());
  else   (((const ::HcalTrigTowerDetId*)o)->zside)();
}

static  void method_2129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalTrigTowerDetId*)o)->ietaAbs)());
  else   (((const ::HcalTrigTowerDetId*)o)->ietaAbs)();
}

static  void method_2130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalTrigTowerDetId*)o)->ieta)());
  else   (((const ::HcalTrigTowerDetId*)o)->ieta)();
}

static  void method_2131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalTrigTowerDetId*)o)->iphi)());
  else   (((const ::HcalTrigTowerDetId*)o)->iphi)();
}

static  void method_2132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalTrigTowerDetId*)o)->depth)());
  else   (((const ::HcalTrigTowerDetId*)o)->depth)();
}

static void method_newdel_1040( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalTrigTowerDetId >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalTrigTowerDetId >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalTrigTowerDetId >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalTrigTowerDetId >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalTrigTowerDetId >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DetId")), ::Reflex::BaseOffset< ::HcalTrigTowerDetId,::DetId >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalTrigTowerDetId -------------------------------
void __HcalTrigTowerDetId_db_datamem(Reflex::Class*);
void __HcalTrigTowerDetId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalTrigTowerDetId_datamem_bld(&__HcalTrigTowerDetId_db_datamem);
Reflex::GenreflexMemberBuilder __HcalTrigTowerDetId_funcmem_bld(&__HcalTrigTowerDetId_db_funcmem);
void __HcalTrigTowerDetId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalTrigTowerDetId"), typeid(::HcalTrigTowerDetId), sizeof(::HcalTrigTowerDetId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_738, ::Reflex::BaseOffset< ::HcalTrigTowerDetId, ::DetId >::Get(), ::Reflex::PUBLIC)
  .AddDataMember(type_1040c, Reflex::Literal("Undefined"), (size_t)&HcalTrigTowerDetId::Undefined, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC | Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalTrigTowerDetId"), destructor_2118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4549, type_2008), Reflex::Literal("operator="), operator_2119, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2008), Reflex::Literal("HcalTrigTowerDetId"), constructor_2120, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalTrigTowerDetId"), constructor_2121, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_419), Reflex::Literal("HcalTrigTowerDetId"), constructor_2122, 0, "rawid", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29, type_29), Reflex::Literal("HcalTrigTowerDetId"), constructor_2123, 0, "ieta;iphi", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29, type_29, type_29), Reflex::Literal("HcalTrigTowerDetId"), constructor_2124, 0, "ieta;iphi;depth", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4057), Reflex::Literal("HcalTrigTowerDetId"), constructor_2125, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1040, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalTrigTowerDetId_funcmem_bld);
}

//------Delayed data member builder for class HcalTrigTowerDetId -------------------
void __HcalTrigTowerDetId_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalTrigTowerDetId -------------------
void __HcalTrigTowerDetId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4549, type_4057), Reflex::Literal("operator="), operator_2126, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_797), Reflex::Literal("subdet"), method_2127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("zside"), method_2128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("ietaAbs"), method_2129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("ieta"), method_2130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("iphi"), method_2131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("depth"), method_2132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalOtherDetId -------------------------------
static void destructor_2133(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalOtherDetId*)o)->::HcalOtherDetId::~HcalOtherDetId)();
}
static  void operator_2134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalOtherDetId*)o)->operator=)(*(const ::HcalOtherDetId*)arg[0]);
  else   (((::HcalOtherDetId*)o)->operator=)(*(const ::HcalOtherDetId*)arg[0]);
}

static void constructor_2135( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalOtherDetId(*(const ::HcalOtherDetId*)arg[0]);
  else ::new(mem) ::HcalOtherDetId(*(const ::HcalOtherDetId*)arg[0]);
}

static void constructor_2136( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalOtherDetId(*(const ::DetId*)arg[0]);
  else ::new(mem) ::HcalOtherDetId(*(const ::DetId*)arg[0]);
}

static  void operator_2137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalOtherDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
  else   (((::HcalOtherDetId*)o)->operator=)(*(const ::DetId*)arg[0]);
}

static  void method_2138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalOtherDetId*)o)->subdet)());
  else   (((const ::HcalOtherDetId*)o)->subdet)();
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DetId")), ::Reflex::BaseOffset< ::HcalOtherDetId,::DetId >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class HcalOtherDetId -------------------------------
void __HcalOtherDetId_db_datamem(Reflex::Class*);
void __HcalOtherDetId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalOtherDetId_datamem_bld(&__HcalOtherDetId_db_datamem);
Reflex::GenreflexMemberBuilder __HcalOtherDetId_funcmem_bld(&__HcalOtherDetId_db_funcmem);
void __HcalOtherDetId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalOtherDetId"), typeid(::HcalOtherDetId), sizeof(::HcalOtherDetId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_738, ::Reflex::BaseOffset< ::HcalOtherDetId, ::DetId >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalOtherDetId"), destructor_2133, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4550, type_4551), Reflex::Literal("operator="), operator_2134, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4551), Reflex::Literal("HcalOtherDetId"), constructor_2135, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4057), Reflex::Literal("HcalOtherDetId"), constructor_2136, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__HcalOtherDetId_funcmem_bld);
}

//------Delayed data member builder for class HcalOtherDetId -------------------
void __HcalOtherDetId_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class HcalOtherDetId -------------------
void __HcalOtherDetId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4550, type_4057), Reflex::Literal("operator="), operator_2137, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_368), Reflex::Literal("subdet"), method_2138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalFrontEndId -------------------------------
static  void operator_2147( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalFrontEndId*)o)->operator=)(*(const ::HcalFrontEndId*)arg[0]);
  else   (((::HcalFrontEndId*)o)->operator=)(*(const ::HcalFrontEndId*)arg[0]);
}

static void constructor_2148( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalFrontEndId(*(const ::HcalFrontEndId*)arg[0]);
  else ::new(mem) ::HcalFrontEndId(*(const ::HcalFrontEndId*)arg[0]);
}

static void constructor_2149( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalFrontEndId();
  else ::new(mem) ::HcalFrontEndId();
}

static void constructor_2150( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalFrontEndId(*(::uint32_t*)arg[0]);
  else ::new(mem) ::HcalFrontEndId(*(::uint32_t*)arg[0]);
}

static void constructor_2151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalFrontEndId(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6]);
  else ::new(mem) ::HcalFrontEndId(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6]);
}

static void destructor_2152(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalFrontEndId*)o)->::HcalFrontEndId::~HcalFrontEndId)();
}
static  void method_2153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::HcalFrontEndId*)o)->rawId)());
  else   (((const ::HcalFrontEndId*)o)->rawId)();
}

static  void method_2154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->rbxIndex)());
  else   (((const ::HcalFrontEndId*)o)->rbxIndex)();
}

static  void method_2155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->rmIndex)());
  else   (((const ::HcalFrontEndId*)o)->rmIndex)();
}

static  void method_2156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalFrontEndId*)o)->null)());
  else   (((const ::HcalFrontEndId*)o)->null)();
}

static  void method_2157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HcalFrontEndId*)o)->rbx)());
  else   (((const ::HcalFrontEndId*)o)->rbx)();
}

static  void method_2158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->rm)());
  else   (((const ::HcalFrontEndId*)o)->rm)();
}

static  void method_2159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->pixel)());
  else   (((const ::HcalFrontEndId*)o)->pixel)();
}

static  void method_2160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->rmFiber)());
  else   (((const ::HcalFrontEndId*)o)->rmFiber)();
}

static  void method_2161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->fiberChannel)());
  else   (((const ::HcalFrontEndId*)o)->fiberChannel)();
}

static  void method_2162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->qieCard)());
  else   (((const ::HcalFrontEndId*)o)->qieCard)();
}

static  void method_2163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->adc)());
  else   (((const ::HcalFrontEndId*)o)->adc)();
}

static  void operator_2164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->operator==)(*(const ::HcalFrontEndId*)arg[0]));
  else   (((const ::HcalFrontEndId*)o)->operator==)(*(const ::HcalFrontEndId*)arg[0]);
}

static  void operator_2165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->operator!=)(*(const ::HcalFrontEndId*)arg[0]));
  else   (((const ::HcalFrontEndId*)o)->operator!=)(*(const ::HcalFrontEndId*)arg[0]);
}

static  void operator_2166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalFrontEndId*)o)->operator<)(*(const ::HcalFrontEndId*)arg[0]));
  else   (((const ::HcalFrontEndId*)o)->operator<)(*(const ::HcalFrontEndId*)arg[0]);
}

static void method_newdel_1079( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalFrontEndId >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalFrontEndId >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalFrontEndId >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalFrontEndId >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalFrontEndId >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalFrontEndId -------------------------------
void __HcalFrontEndId_db_datamem(Reflex::Class*);
void __HcalFrontEndId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalFrontEndId_datamem_bld(&__HcalFrontEndId_db_datamem);
Reflex::GenreflexMemberBuilder __HcalFrontEndId_funcmem_bld(&__HcalFrontEndId_db_funcmem);
void __HcalFrontEndId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalFrontEndId"), typeid(::HcalFrontEndId), sizeof(::HcalFrontEndId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2596, type_2010), Reflex::Literal("operator="), operator_2147, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2010), Reflex::Literal("HcalFrontEndId"), constructor_2148, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalFrontEndId"), constructor_2149, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_419), Reflex::Literal("HcalFrontEndId"), constructor_2150, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2925, type_29, type_29, type_29, type_29, type_29, type_29), Reflex::Literal("HcalFrontEndId"), constructor_2151, 0, "rbx;rm;pixel;rmfiber;fiberchannel;qiecard;adc", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalFrontEndId"), destructor_2152, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1079, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalFrontEndId_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalFrontEndId_funcmem_bld);
}

//------Delayed data member builder for class HcalFrontEndId -------------------
void __HcalFrontEndId_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_419, Reflex::Literal("hcalFrontEndId_"), OffsetOf(__shadow__::__HcalFrontEndId, hcalFrontEndId_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalFrontEndId -------------------
void __HcalFrontEndId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_419), Reflex::Literal("rawId"), method_2153, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("rbxIndex"), method_2154, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("rmIndex"), method_2155, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1493), Reflex::Literal("null"), method_2156, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1193), Reflex::Literal("rbx"), method_2157, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("rm"), method_2158, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("pixel"), method_2159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("rmFiber"), method_2160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("fiberChannel"), method_2161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("qieCard"), method_2162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("adc"), method_2163, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29, type_2010), Reflex::Literal("operator=="), operator_2164, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29, type_2010), Reflex::Literal("operator!="), operator_2165, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29, type_2010), Reflex::Literal("operator<"), operator_2166, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class vector<CastorElectronicsId,std::allocator<CastorElectronicsId> > -------------------------------
static void constructor_2541( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CastorElectronicsId>();
  else ::new(mem) ::std::vector<CastorElectronicsId>();
}

static void constructor_2542( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CastorElectronicsId>(*(const ::std::allocator<CastorElectronicsId>*)arg[0]);
  else ::new(mem) ::std::vector<CastorElectronicsId>(*(const ::std::allocator<CastorElectronicsId>*)arg[0]);
}

static void constructor_2543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CastorElectronicsId>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<CastorElectronicsId>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CastorElectronicsId>(*(::std::size_t*)arg[0],
      *(const ::CastorElectronicsId*)arg[1]);
  else ::new(mem) ::std::vector<CastorElectronicsId>(*(::std::size_t*)arg[0],
      *(const ::CastorElectronicsId*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CastorElectronicsId>(*(::std::size_t*)arg[0],
      *(const ::CastorElectronicsId*)arg[1],
      *(const ::std::allocator<CastorElectronicsId>*)arg[2]);
  else ::new(mem) ::std::vector<CastorElectronicsId>(*(::std::size_t*)arg[0],
      *(const ::CastorElectronicsId*)arg[1],
      *(const ::std::allocator<CastorElectronicsId>*)arg[2]);
  }
}

static void constructor_2544( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CastorElectronicsId>(*(const ::std::vector<CastorElectronicsId>*)arg[0]);
  else ::new(mem) ::std::vector<CastorElectronicsId>(*(const ::std::vector<CastorElectronicsId>*)arg[0]);
}

static void destructor_2545(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<CastorElectronicsId>*)o)->::std::vector<CastorElectronicsId>::~vector)();
}
static  void operator_2546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CastorElectronicsId>*)o)->operator=)(*(const ::std::vector<CastorElectronicsId>*)arg[0]);
  else   (((::std::vector<CastorElectronicsId>*)o)->operator=)(*(const ::std::vector<CastorElectronicsId>*)arg[0]);
}

static  void method_2547( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CastorElectronicsId>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::CastorElectronicsId*)arg[1]);
}

static  void method_2548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >)((((::std::vector<CastorElectronicsId>*)o)->begin)());
  else   (((::std::vector<CastorElectronicsId>*)o)->begin)();
}

static  void method_2549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const CastorElectronicsId*,std::vector<CastorElectronicsId> >)((((const ::std::vector<CastorElectronicsId>*)o)->begin)());
  else   (((const ::std::vector<CastorElectronicsId>*)o)->begin)();
}

static  void method_2550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >)((((::std::vector<CastorElectronicsId>*)o)->end)());
  else   (((::std::vector<CastorElectronicsId>*)o)->end)();
}

static  void method_2551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const CastorElectronicsId*,std::vector<CastorElectronicsId> >)((((const ::std::vector<CastorElectronicsId>*)o)->end)());
  else   (((const ::std::vector<CastorElectronicsId>*)o)->end)();
}

static  void method_2556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CastorElectronicsId>*)o)->size)());
  else   (((const ::std::vector<CastorElectronicsId>*)o)->size)();
}

static  void method_2557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CastorElectronicsId>*)o)->max_size)());
  else   (((const ::std::vector<CastorElectronicsId>*)o)->max_size)();
}

static  void method_2558( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<CastorElectronicsId>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<CastorElectronicsId>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::CastorElectronicsId*)arg[1]);
  }
}

static  void method_2559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CastorElectronicsId>*)o)->capacity)());
  else   (((const ::std::vector<CastorElectronicsId>*)o)->capacity)();
}

static  void method_2560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<CastorElectronicsId>*)o)->empty)());
  else   (((const ::std::vector<CastorElectronicsId>*)o)->empty)();
}

static  void method_2561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CastorElectronicsId>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CastorElectronicsId>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<CastorElectronicsId>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CastorElectronicsId>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<CastorElectronicsId>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CastorElectronicsId>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<CastorElectronicsId>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CastorElectronicsId>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<CastorElectronicsId>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CastorElectronicsId>*)o)->front)();
  else   (((::std::vector<CastorElectronicsId>*)o)->front)();
}

static  void method_2568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CastorElectronicsId>*)o)->front)();
  else   (((const ::std::vector<CastorElectronicsId>*)o)->front)();
}

static  void method_2569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CastorElectronicsId>*)o)->back)();
  else   (((::std::vector<CastorElectronicsId>*)o)->back)();
}

static  void method_2570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CastorElectronicsId>*)o)->back)();
  else   (((const ::std::vector<CastorElectronicsId>*)o)->back)();
}

static  void method_2571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<CastorElectronicsId>*)o)->data)());
  else   (((::std::vector<CastorElectronicsId>*)o)->data)();
}

static  void method_2572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<CastorElectronicsId>*)o)->data)());
  else   (((const ::std::vector<CastorElectronicsId>*)o)->data)();
}

static  void method_2573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CastorElectronicsId>*)o)->push_back)(*(const ::CastorElectronicsId*)arg[0]);
}

static  void method_2574( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<CastorElectronicsId>*)o)->pop_back)();
}

static  void method_2575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >)((((::std::vector<CastorElectronicsId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >*)arg[0],
    *(const ::CastorElectronicsId*)arg[1]));
  else   (((::std::vector<CastorElectronicsId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >*)arg[0],
    *(const ::CastorElectronicsId*)arg[1]);
}

static  void method_2576( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CastorElectronicsId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::CastorElectronicsId*)arg[2]);
}

static  void method_2577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >)((((::std::vector<CastorElectronicsId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >*)arg[0]));
  else   (((::std::vector<CastorElectronicsId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >*)arg[0]);
}

static  void method_2578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >)((((::std::vector<CastorElectronicsId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >*)arg[1]));
  else   (((::std::vector<CastorElectronicsId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<CastorElectronicsId*,std::vector<CastorElectronicsId> >*)arg[1]);
}

static  void method_2579( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CastorElectronicsId>*)o)->swap)(*(::std::vector<CastorElectronicsId>*)arg[0]);
}

static  void method_2580( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<CastorElectronicsId>*)o)->clear)();
}

static void method_newdel_1156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<CastorElectronicsId> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<CastorElectronicsId> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<CastorElectronicsId> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<CastorElectronicsId> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<CastorElectronicsId> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<CastorElectronicsId,std::allocator<CastorElectronicsId> >")), ::Reflex::BaseOffset< ::std::vector<CastorElectronicsId>,::std::_Vector_base<CastorElectronicsId,std::allocator<CastorElectronicsId> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<CastorElectronicsId> >::Generate();
  else ::Reflex::Proxy< ::std::vector<CastorElectronicsId> >::Generate();
}

//------Dictionary for class vector<CastorElectronicsId,std::allocator<CastorElectronicsId> > -------------------------------
void __std__vector_CastorElectronicsId__db_datamem(Reflex::Class*);
void __std__vector_CastorElectronicsId__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_CastorElectronicsId__datamem_bld(&__std__vector_CastorElectronicsId__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_CastorElectronicsId__funcmem_bld(&__std__vector_CastorElectronicsId__db_funcmem);
void __std__vector_CastorElectronicsId__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<CastorElectronicsId>"), typeid(::std::vector<CastorElectronicsId>), sizeof(::std::vector<CastorElectronicsId>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1377, ::Reflex::BaseOffset< ::std::vector<CastorElectronicsId>, ::std::_Vector_base<CastorElectronicsId,std::allocator<CastorElectronicsId> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_774, Reflex::Literal("std::vector<CastorElectronicsId>::_Alloc_value_type"))
  .AddTypedef(type_1377, Reflex::Literal("std::vector<CastorElectronicsId>::_Base"))
  .AddTypedef(type_1261, Reflex::Literal("std::vector<CastorElectronicsId>::_Tp_alloc_type"))
  .AddTypedef(type_1657, Reflex::Literal("std::vector<CastorElectronicsId>::_Alloc_traits"))
  .AddTypedef(type_774, Reflex::Literal("std::vector<CastorElectronicsId>::value_type"))
  .AddTypedef(type_2527, Reflex::Literal("std::vector<CastorElectronicsId>::pointer"))
  .AddTypedef(type_2529, Reflex::Literal("std::vector<CastorElectronicsId>::const_pointer"))
  .AddTypedef(type_2531, Reflex::Literal("std::vector<CastorElectronicsId>::reference"))
  .AddTypedef(type_2003, Reflex::Literal("std::vector<CastorElectronicsId>::const_reference"))
  .AddTypedef(type_1699, Reflex::Literal("std::vector<CastorElectronicsId>::iterator"))
  .AddTypedef(type_1700, Reflex::Literal("std::vector<CastorElectronicsId>::const_iterator"))
  .AddTypedef(type_1325, Reflex::Literal("std::vector<CastorElectronicsId>::const_reverse_iterator"))
  .AddTypedef(type_1326, Reflex::Literal("std::vector<CastorElectronicsId>::reverse_iterator"))
  .AddTypedef(type_1322, Reflex::Literal("std::vector<CastorElectronicsId>::size_type"))
  .AddTypedef(type_1281, Reflex::Literal("std::vector<CastorElectronicsId>::difference_type"))
  .AddTypedef(type_1261, Reflex::Literal("std::vector<CastorElectronicsId>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2541, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4628), Reflex::Literal("vector"), constructor_2542, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1322, type_2003, type_4628), Reflex::Literal("vector"), constructor_2543, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4629), Reflex::Literal("vector"), constructor_2544, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2545, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_CastorElectronicsId__funcmem_bld);
}

//------Delayed data member builder for class vector<CastorElectronicsId,std::allocator<CastorElectronicsId> > -------------------
void __std__vector_CastorElectronicsId__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<CastorElectronicsId,std::allocator<CastorElectronicsId> > -------------------
void __std__vector_CastorElectronicsId__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4630, type_4629), Reflex::Literal("operator="), operator_2546, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1322, type_2003), Reflex::Literal("assign"), method_2547, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1699), Reflex::Literal("begin"), method_2548, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1700), Reflex::Literal("begin"), method_2549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1699), Reflex::Literal("end"), method_2550, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1700), Reflex::Literal("end"), method_2551, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1322), Reflex::Literal("size"), method_2556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1322), Reflex::Literal("max_size"), method_2557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1322, type_774), Reflex::Literal("resize"), method_2558, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1322), Reflex::Literal("capacity"), method_2559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1493), Reflex::Literal("empty"), method_2560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1322), Reflex::Literal("reserve"), method_2561, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2531, type_1322), Reflex::Literal("operator[]"), operator_2562, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2003, type_1322), Reflex::Literal("operator[]"), operator_2563, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2531, type_1322), Reflex::Literal("at"), method_2565, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2003, type_1322), Reflex::Literal("at"), method_2566, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2531), Reflex::Literal("front"), method_2567, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2003), Reflex::Literal("front"), method_2568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2531), Reflex::Literal("back"), method_2569, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2003), Reflex::Literal("back"), method_2570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2527), Reflex::Literal("data"), method_2571, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2529), Reflex::Literal("data"), method_2572, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_2003), Reflex::Literal("push_back"), method_2573, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630), Reflex::Literal("pop_back"), method_2574, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1699, type_1699, type_2003), Reflex::Literal("insert"), method_2575, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1699, type_1322, type_2003), Reflex::Literal("insert"), method_2576, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1699, type_1699), Reflex::Literal("erase"), method_2577, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1699, type_1699, type_1699), Reflex::Literal("erase"), method_2578, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_4630), Reflex::Literal("swap"), method_2579, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630), Reflex::Literal("clear"), method_2580, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalFrontEndId,std::allocator<HcalFrontEndId> > -------------------------------
static void constructor_2606( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFrontEndId>();
  else ::new(mem) ::std::vector<HcalFrontEndId>();
}

static void constructor_2607( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFrontEndId>(*(const ::std::allocator<HcalFrontEndId>*)arg[0]);
  else ::new(mem) ::std::vector<HcalFrontEndId>(*(const ::std::allocator<HcalFrontEndId>*)arg[0]);
}

static void constructor_2608( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFrontEndId>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalFrontEndId>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFrontEndId>(*(::std::size_t*)arg[0],
      *(const ::HcalFrontEndId*)arg[1]);
  else ::new(mem) ::std::vector<HcalFrontEndId>(*(::std::size_t*)arg[0],
      *(const ::HcalFrontEndId*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFrontEndId>(*(::std::size_t*)arg[0],
      *(const ::HcalFrontEndId*)arg[1],
      *(const ::std::allocator<HcalFrontEndId>*)arg[2]);
  else ::new(mem) ::std::vector<HcalFrontEndId>(*(::std::size_t*)arg[0],
      *(const ::HcalFrontEndId*)arg[1],
      *(const ::std::allocator<HcalFrontEndId>*)arg[2]);
  }
}

static void constructor_2609( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalFrontEndId>(*(const ::std::vector<HcalFrontEndId>*)arg[0]);
  else ::new(mem) ::std::vector<HcalFrontEndId>(*(const ::std::vector<HcalFrontEndId>*)arg[0]);
}

static void destructor_2610(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalFrontEndId>*)o)->::std::vector<HcalFrontEndId>::~vector)();
}
static  void operator_2611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalFrontEndId>*)o)->operator=)(*(const ::std::vector<HcalFrontEndId>*)arg[0]);
  else   (((::std::vector<HcalFrontEndId>*)o)->operator=)(*(const ::std::vector<HcalFrontEndId>*)arg[0]);
}

static  void method_2612( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalFrontEndId>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalFrontEndId*)arg[1]);
}

static  void method_2613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >)((((::std::vector<HcalFrontEndId>*)o)->begin)());
  else   (((::std::vector<HcalFrontEndId>*)o)->begin)();
}

static  void method_2614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalFrontEndId*,std::vector<HcalFrontEndId> >)((((const ::std::vector<HcalFrontEndId>*)o)->begin)());
  else   (((const ::std::vector<HcalFrontEndId>*)o)->begin)();
}

static  void method_2615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >)((((::std::vector<HcalFrontEndId>*)o)->end)());
  else   (((::std::vector<HcalFrontEndId>*)o)->end)();
}

static  void method_2616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalFrontEndId*,std::vector<HcalFrontEndId> >)((((const ::std::vector<HcalFrontEndId>*)o)->end)());
  else   (((const ::std::vector<HcalFrontEndId>*)o)->end)();
}

static  void method_2621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalFrontEndId>*)o)->size)());
  else   (((const ::std::vector<HcalFrontEndId>*)o)->size)();
}

static  void method_2622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalFrontEndId>*)o)->max_size)());
  else   (((const ::std::vector<HcalFrontEndId>*)o)->max_size)();
}

static  void method_2623( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalFrontEndId>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalFrontEndId>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalFrontEndId*)arg[1]);
  }
}

static  void method_2624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalFrontEndId>*)o)->capacity)());
  else   (((const ::std::vector<HcalFrontEndId>*)o)->capacity)();
}

static  void method_2625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalFrontEndId>*)o)->empty)());
  else   (((const ::std::vector<HcalFrontEndId>*)o)->empty)();
}

static  void method_2626( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalFrontEndId>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2627( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalFrontEndId>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalFrontEndId>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalFrontEndId>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalFrontEndId>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2630( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalFrontEndId>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalFrontEndId>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalFrontEndId>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalFrontEndId>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalFrontEndId>*)o)->front)();
  else   (((::std::vector<HcalFrontEndId>*)o)->front)();
}

static  void method_2633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalFrontEndId>*)o)->front)();
  else   (((const ::std::vector<HcalFrontEndId>*)o)->front)();
}

static  void method_2634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalFrontEndId>*)o)->back)();
  else   (((::std::vector<HcalFrontEndId>*)o)->back)();
}

static  void method_2635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalFrontEndId>*)o)->back)();
  else   (((const ::std::vector<HcalFrontEndId>*)o)->back)();
}

static  void method_2636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalFrontEndId>*)o)->data)());
  else   (((::std::vector<HcalFrontEndId>*)o)->data)();
}

static  void method_2637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalFrontEndId>*)o)->data)());
  else   (((const ::std::vector<HcalFrontEndId>*)o)->data)();
}

static  void method_2638( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalFrontEndId>*)o)->push_back)(*(const ::HcalFrontEndId*)arg[0]);
}

static  void method_2639( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalFrontEndId>*)o)->pop_back)();
}

static  void method_2640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >)((((::std::vector<HcalFrontEndId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >*)arg[0],
    *(const ::HcalFrontEndId*)arg[1]));
  else   (((::std::vector<HcalFrontEndId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >*)arg[0],
    *(const ::HcalFrontEndId*)arg[1]);
}

static  void method_2641( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalFrontEndId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalFrontEndId*)arg[2]);
}

static  void method_2642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >)((((::std::vector<HcalFrontEndId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >*)arg[0]));
  else   (((::std::vector<HcalFrontEndId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >*)arg[0]);
}

static  void method_2643( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >)((((::std::vector<HcalFrontEndId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >*)arg[1]));
  else   (((::std::vector<HcalFrontEndId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalFrontEndId*,std::vector<HcalFrontEndId> >*)arg[1]);
}

static  void method_2644( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalFrontEndId>*)o)->swap)(*(::std::vector<HcalFrontEndId>*)arg[0]);
}

static  void method_2645( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalFrontEndId>*)o)->clear)();
}

static void method_newdel_1157( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalFrontEndId> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalFrontEndId> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalFrontEndId> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalFrontEndId> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalFrontEndId> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalFrontEndId,std::allocator<HcalFrontEndId> >")), ::Reflex::BaseOffset< ::std::vector<HcalFrontEndId>,::std::_Vector_base<HcalFrontEndId,std::allocator<HcalFrontEndId> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalFrontEndId> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalFrontEndId> >::Generate();
}

//------Dictionary for class vector<HcalFrontEndId,std::allocator<HcalFrontEndId> > -------------------------------
void __std__vector_HcalFrontEndId__db_datamem(Reflex::Class*);
void __std__vector_HcalFrontEndId__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalFrontEndId__datamem_bld(&__std__vector_HcalFrontEndId__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalFrontEndId__funcmem_bld(&__std__vector_HcalFrontEndId__db_funcmem);
void __std__vector_HcalFrontEndId__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalFrontEndId>"), typeid(::std::vector<HcalFrontEndId>), sizeof(::std::vector<HcalFrontEndId>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1378, ::Reflex::BaseOffset< ::std::vector<HcalFrontEndId>, ::std::_Vector_base<HcalFrontEndId,std::allocator<HcalFrontEndId> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1079, Reflex::Literal("std::vector<HcalFrontEndId>::_Alloc_value_type"))
  .AddTypedef(type_1378, Reflex::Literal("std::vector<HcalFrontEndId>::_Base"))
  .AddTypedef(type_1262, Reflex::Literal("std::vector<HcalFrontEndId>::_Tp_alloc_type"))
  .AddTypedef(type_1658, Reflex::Literal("std::vector<HcalFrontEndId>::_Alloc_traits"))
  .AddTypedef(type_1079, Reflex::Literal("std::vector<HcalFrontEndId>::value_type"))
  .AddTypedef(type_2592, Reflex::Literal("std::vector<HcalFrontEndId>::pointer"))
  .AddTypedef(type_2594, Reflex::Literal("std::vector<HcalFrontEndId>::const_pointer"))
  .AddTypedef(type_2596, Reflex::Literal("std::vector<HcalFrontEndId>::reference"))
  .AddTypedef(type_2010, Reflex::Literal("std::vector<HcalFrontEndId>::const_reference"))
  .AddTypedef(type_1701, Reflex::Literal("std::vector<HcalFrontEndId>::iterator"))
  .AddTypedef(type_1702, Reflex::Literal("std::vector<HcalFrontEndId>::const_iterator"))
  .AddTypedef(type_1327, Reflex::Literal("std::vector<HcalFrontEndId>::const_reverse_iterator"))
  .AddTypedef(type_1328, Reflex::Literal("std::vector<HcalFrontEndId>::reverse_iterator"))
  .AddTypedef(type_1322, Reflex::Literal("std::vector<HcalFrontEndId>::size_type"))
  .AddTypedef(type_1281, Reflex::Literal("std::vector<HcalFrontEndId>::difference_type"))
  .AddTypedef(type_1262, Reflex::Literal("std::vector<HcalFrontEndId>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2606, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4631), Reflex::Literal("vector"), constructor_2607, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1322, type_2010, type_4631), Reflex::Literal("vector"), constructor_2608, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4632), Reflex::Literal("vector"), constructor_2609, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2610, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1157, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalFrontEndId__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalFrontEndId,std::allocator<HcalFrontEndId> > -------------------
void __std__vector_HcalFrontEndId__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalFrontEndId,std::allocator<HcalFrontEndId> > -------------------
void __std__vector_HcalFrontEndId__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4633, type_4632), Reflex::Literal("operator="), operator_2611, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1322, type_2010), Reflex::Literal("assign"), method_2612, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1701), Reflex::Literal("begin"), method_2613, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1702), Reflex::Literal("begin"), method_2614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1701), Reflex::Literal("end"), method_2615, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1702), Reflex::Literal("end"), method_2616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1322), Reflex::Literal("size"), method_2621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1322), Reflex::Literal("max_size"), method_2622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1322, type_1079), Reflex::Literal("resize"), method_2623, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1322), Reflex::Literal("capacity"), method_2624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1493), Reflex::Literal("empty"), method_2625, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1322), Reflex::Literal("reserve"), method_2626, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2596, type_1322), Reflex::Literal("operator[]"), operator_2627, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2010, type_1322), Reflex::Literal("operator[]"), operator_2628, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2596, type_1322), Reflex::Literal("at"), method_2630, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2010, type_1322), Reflex::Literal("at"), method_2631, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2596), Reflex::Literal("front"), method_2632, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2010), Reflex::Literal("front"), method_2633, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2596), Reflex::Literal("back"), method_2634, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2010), Reflex::Literal("back"), method_2635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2592), Reflex::Literal("data"), method_2636, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2594), Reflex::Literal("data"), method_2637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_2010), Reflex::Literal("push_back"), method_2638, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630), Reflex::Literal("pop_back"), method_2639, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1701, type_1701, type_2010), Reflex::Literal("insert"), method_2640, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1701, type_1322, type_2010), Reflex::Literal("insert"), method_2641, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1701, type_1701), Reflex::Literal("erase"), method_2642, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1701, type_1701, type_1701), Reflex::Literal("erase"), method_2643, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_4633), Reflex::Literal("swap"), method_2644, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630), Reflex::Literal("clear"), method_2645, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HcalElectronicsId,std::allocator<HcalElectronicsId> > -------------------------------
static void constructor_2671( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsId>();
  else ::new(mem) ::std::vector<HcalElectronicsId>();
}

static void constructor_2672( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsId>(*(const ::std::allocator<HcalElectronicsId>*)arg[0]);
  else ::new(mem) ::std::vector<HcalElectronicsId>(*(const ::std::allocator<HcalElectronicsId>*)arg[0]);
}

static void constructor_2673( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsId>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HcalElectronicsId>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsId>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsId*)arg[1]);
  else ::new(mem) ::std::vector<HcalElectronicsId>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsId*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsId>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsId*)arg[1],
      *(const ::std::allocator<HcalElectronicsId>*)arg[2]);
  else ::new(mem) ::std::vector<HcalElectronicsId>(*(::std::size_t*)arg[0],
      *(const ::HcalElectronicsId*)arg[1],
      *(const ::std::allocator<HcalElectronicsId>*)arg[2]);
  }
}

static void constructor_2674( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HcalElectronicsId>(*(const ::std::vector<HcalElectronicsId>*)arg[0]);
  else ::new(mem) ::std::vector<HcalElectronicsId>(*(const ::std::vector<HcalElectronicsId>*)arg[0]);
}

static void destructor_2675(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HcalElectronicsId>*)o)->::std::vector<HcalElectronicsId>::~vector)();
}
static  void operator_2676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsId>*)o)->operator=)(*(const ::std::vector<HcalElectronicsId>*)arg[0]);
  else   (((::std::vector<HcalElectronicsId>*)o)->operator=)(*(const ::std::vector<HcalElectronicsId>*)arg[0]);
}

static  void method_2677( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsId>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HcalElectronicsId*)arg[1]);
}

static  void method_2678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >)((((::std::vector<HcalElectronicsId>*)o)->begin)());
  else   (((::std::vector<HcalElectronicsId>*)o)->begin)();
}

static  void method_2679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalElectronicsId*,std::vector<HcalElectronicsId> >)((((const ::std::vector<HcalElectronicsId>*)o)->begin)());
  else   (((const ::std::vector<HcalElectronicsId>*)o)->begin)();
}

static  void method_2680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >)((((::std::vector<HcalElectronicsId>*)o)->end)());
  else   (((::std::vector<HcalElectronicsId>*)o)->end)();
}

static  void method_2681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HcalElectronicsId*,std::vector<HcalElectronicsId> >)((((const ::std::vector<HcalElectronicsId>*)o)->end)());
  else   (((const ::std::vector<HcalElectronicsId>*)o)->end)();
}

static  void method_2686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalElectronicsId>*)o)->size)());
  else   (((const ::std::vector<HcalElectronicsId>*)o)->size)();
}

static  void method_2687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalElectronicsId>*)o)->max_size)());
  else   (((const ::std::vector<HcalElectronicsId>*)o)->max_size)();
}

static  void method_2688( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HcalElectronicsId>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HcalElectronicsId>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HcalElectronicsId*)arg[1]);
  }
}

static  void method_2689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HcalElectronicsId>*)o)->capacity)());
  else   (((const ::std::vector<HcalElectronicsId>*)o)->capacity)();
}

static  void method_2690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HcalElectronicsId>*)o)->empty)());
  else   (((const ::std::vector<HcalElectronicsId>*)o)->empty)();
}

static  void method_2691( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsId>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2692( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsId>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalElectronicsId>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2693( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsId>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalElectronicsId>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsId>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HcalElectronicsId>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsId>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HcalElectronicsId>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsId>*)o)->front)();
  else   (((::std::vector<HcalElectronicsId>*)o)->front)();
}

static  void method_2698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsId>*)o)->front)();
  else   (((const ::std::vector<HcalElectronicsId>*)o)->front)();
}

static  void method_2699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HcalElectronicsId>*)o)->back)();
  else   (((::std::vector<HcalElectronicsId>*)o)->back)();
}

static  void method_2700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HcalElectronicsId>*)o)->back)();
  else   (((const ::std::vector<HcalElectronicsId>*)o)->back)();
}

static  void method_2701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HcalElectronicsId>*)o)->data)());
  else   (((::std::vector<HcalElectronicsId>*)o)->data)();
}

static  void method_2702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HcalElectronicsId>*)o)->data)());
  else   (((const ::std::vector<HcalElectronicsId>*)o)->data)();
}

static  void method_2703( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsId>*)o)->push_back)(*(const ::HcalElectronicsId*)arg[0]);
}

static  void method_2704( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalElectronicsId>*)o)->pop_back)();
}

static  void method_2705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >)((((::std::vector<HcalElectronicsId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >*)arg[0],
    *(const ::HcalElectronicsId*)arg[1]));
  else   (((::std::vector<HcalElectronicsId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >*)arg[0],
    *(const ::HcalElectronicsId*)arg[1]);
}

static  void method_2706( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HcalElectronicsId*)arg[2]);
}

static  void method_2707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >)((((::std::vector<HcalElectronicsId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >*)arg[0]));
  else   (((::std::vector<HcalElectronicsId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >*)arg[0]);
}

static  void method_2708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >)((((::std::vector<HcalElectronicsId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >*)arg[1]));
  else   (((::std::vector<HcalElectronicsId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HcalElectronicsId*,std::vector<HcalElectronicsId> >*)arg[1]);
}

static  void method_2709( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HcalElectronicsId>*)o)->swap)(*(::std::vector<HcalElectronicsId>*)arg[0]);
}

static  void method_2710( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HcalElectronicsId>*)o)->clear)();
}

static void method_newdel_1158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsId> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsId> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsId> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsId> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HcalElectronicsId> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HcalElectronicsId,std::allocator<HcalElectronicsId> >")), ::Reflex::BaseOffset< ::std::vector<HcalElectronicsId>,::std::_Vector_base<HcalElectronicsId,std::allocator<HcalElectronicsId> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HcalElectronicsId> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HcalElectronicsId> >::Generate();
}

//------Dictionary for class vector<HcalElectronicsId,std::allocator<HcalElectronicsId> > -------------------------------
void __std__vector_HcalElectronicsId__db_datamem(Reflex::Class*);
void __std__vector_HcalElectronicsId__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HcalElectronicsId__datamem_bld(&__std__vector_HcalElectronicsId__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HcalElectronicsId__funcmem_bld(&__std__vector_HcalElectronicsId__db_funcmem);
void __std__vector_HcalElectronicsId__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HcalElectronicsId>"), typeid(::std::vector<HcalElectronicsId>), sizeof(::std::vector<HcalElectronicsId>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1379, ::Reflex::BaseOffset< ::std::vector<HcalElectronicsId>, ::std::_Vector_base<HcalElectronicsId,std::allocator<HcalElectronicsId> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1025, Reflex::Literal("std::vector<HcalElectronicsId>::_Alloc_value_type"))
  .AddTypedef(type_1379, Reflex::Literal("std::vector<HcalElectronicsId>::_Base"))
  .AddTypedef(type_1263, Reflex::Literal("std::vector<HcalElectronicsId>::_Tp_alloc_type"))
  .AddTypedef(type_1659, Reflex::Literal("std::vector<HcalElectronicsId>::_Alloc_traits"))
  .AddTypedef(type_1025, Reflex::Literal("std::vector<HcalElectronicsId>::value_type"))
  .AddTypedef(type_2657, Reflex::Literal("std::vector<HcalElectronicsId>::pointer"))
  .AddTypedef(type_2659, Reflex::Literal("std::vector<HcalElectronicsId>::const_pointer"))
  .AddTypedef(type_2661, Reflex::Literal("std::vector<HcalElectronicsId>::reference"))
  .AddTypedef(type_2011, Reflex::Literal("std::vector<HcalElectronicsId>::const_reference"))
  .AddTypedef(type_1703, Reflex::Literal("std::vector<HcalElectronicsId>::iterator"))
  .AddTypedef(type_1704, Reflex::Literal("std::vector<HcalElectronicsId>::const_iterator"))
  .AddTypedef(type_1329, Reflex::Literal("std::vector<HcalElectronicsId>::const_reverse_iterator"))
  .AddTypedef(type_1330, Reflex::Literal("std::vector<HcalElectronicsId>::reverse_iterator"))
  .AddTypedef(type_1322, Reflex::Literal("std::vector<HcalElectronicsId>::size_type"))
  .AddTypedef(type_1281, Reflex::Literal("std::vector<HcalElectronicsId>::difference_type"))
  .AddTypedef(type_1263, Reflex::Literal("std::vector<HcalElectronicsId>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2671, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4634), Reflex::Literal("vector"), constructor_2672, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1322, type_2011, type_4634), Reflex::Literal("vector"), constructor_2673, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4635), Reflex::Literal("vector"), constructor_2674, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2675, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HcalElectronicsId__funcmem_bld);
}

//------Delayed data member builder for class vector<HcalElectronicsId,std::allocator<HcalElectronicsId> > -------------------
void __std__vector_HcalElectronicsId__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HcalElectronicsId,std::allocator<HcalElectronicsId> > -------------------
void __std__vector_HcalElectronicsId__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4636, type_4635), Reflex::Literal("operator="), operator_2676, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1322, type_2011), Reflex::Literal("assign"), method_2677, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1703), Reflex::Literal("begin"), method_2678, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1704), Reflex::Literal("begin"), method_2679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1703), Reflex::Literal("end"), method_2680, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1704), Reflex::Literal("end"), method_2681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1322), Reflex::Literal("size"), method_2686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1322), Reflex::Literal("max_size"), method_2687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1322, type_1025), Reflex::Literal("resize"), method_2688, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1322), Reflex::Literal("capacity"), method_2689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1493), Reflex::Literal("empty"), method_2690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1322), Reflex::Literal("reserve"), method_2691, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2661, type_1322), Reflex::Literal("operator[]"), operator_2692, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2011, type_1322), Reflex::Literal("operator[]"), operator_2693, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2661, type_1322), Reflex::Literal("at"), method_2695, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2011, type_1322), Reflex::Literal("at"), method_2696, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2661), Reflex::Literal("front"), method_2697, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2011), Reflex::Literal("front"), method_2698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2661), Reflex::Literal("back"), method_2699, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2011), Reflex::Literal("back"), method_2700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("data"), method_2701, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2659), Reflex::Literal("data"), method_2702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_2011), Reflex::Literal("push_back"), method_2703, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630), Reflex::Literal("pop_back"), method_2704, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1703, type_1703, type_2011), Reflex::Literal("insert"), method_2705, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_1703, type_1322, type_2011), Reflex::Literal("insert"), method_2706, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1703, type_1703), Reflex::Literal("erase"), method_2707, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1703, type_1703, type_1703), Reflex::Literal("erase"), method_2708, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_4636), Reflex::Literal("swap"), method_2709, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630), Reflex::Literal("clear"), method_2710, 0, 0, ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __HcalCalibDetId_dict(); 
      __HcalCastorDetId_dict(); 
      __HcalDcsDetId_dict(); 
      __HcalDetId_dict(); 
      __HcalZDCDetId_dict(); 
      __CastorElectronicsId_dict(); 
      __HcalElectronicsId_dict(); 
      __HcalTrigTowerDetId_dict(); 
      __HcalOtherDetId_dict(); 
      __HcalFrontEndId_dict(); 
      __std__vector_CastorElectronicsId__dict(); 
      __std__vector_HcalFrontEndId__dict(); 
      __std__vector_HcalElectronicsId__dict(); 
    }
    ~Dictionaries() {
      type_103.Unload(); // class HcalCalibDetId 
      type_335.Unload(); // class HcalCastorDetId 
      type_369.Unload(); // class HcalDcsDetId 
      type_500.Unload(); // class HcalDetId 
      type_545.Unload(); // class HcalZDCDetId 
      type_774.Unload(); // class CastorElectronicsId 
      type_1025.Unload(); // class HcalElectronicsId 
      type_1040.Unload(); // class HcalTrigTowerDetId 
      type_1046.Unload(); // class HcalOtherDetId 
      type_1079.Unload(); // class HcalFrontEndId 
      type_1156.Unload(); // class std::vector<CastorElectronicsId> 
      type_1157.Unload(); // class std::vector<HcalFrontEndId> 
      type_1158.Unload(); // class std::vector<HcalElectronicsId> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
